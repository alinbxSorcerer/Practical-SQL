<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_241"/><strong><span class="big">14</span></strong><br/><strong>ANALYZING SPATIAL DATA WITH POSTGIS</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">These days, mobile apps can provide a list of coffee shops near you within seconds. They can do that because they’re powered by a <em>geographic information system (GIS)</em>, which is any system that allows for storing, editing, analyzing, and displaying spatial data. As you can imagine, GIS has many practical applications today, from helping city planners decide where to build schools based on population patterns to finding the best detour around a traffic jam.</p>
<p class="indent"><em>Spatial data</em> refers to information about the location and shape of objects, which can be two and three dimensional. For example, the spatial data we’ll use in this chapter contains coordinates describing geometric shapes, such as points, lines, and polygons. These shapes in turn represent features you would find on a map, such as roads, lakes, or countries.</p>
<p class="indent">Conveniently, you can use PostgreSQL to store and analyze spatial data, which allows you to calculate the distance between points, compute the size of areas, and identify whether two objects intersect. However, to enable spatial analysis and store spatial data types in PostgreSQL, you <span epub:type="pagebreak" id="page_242"/>need to install an open source extension called PostGIS. The PostGIS extension also provides additional functions and operators that work specifically with spatial data.</p>
<p class="indent">In this chapter, you’ll learn to use PostGIS to analyze roadways in Santa Fe, New Mexico as well as the location of farmers’ markets across the United States. You’ll learn how to construct and query spatial data types and how to work with different geographic data formats you might encounter when you obtain data from public and private data sources. You’ll also learn about map projections and grid systems. The goal is to give you tools to glean information from spatial data, similar to how you’ve analyzed numbers and text.</p>
<p class="indent">We’ll begin by setting up PostGIS so we can explore different types of spatial data. All code and data for the exercises are available with the book’s resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>.</p>
<h3 class="h3" id="lev235">Installing PostGIS and Creating a Spatial Database</h3>
<p class="noindent">PostGIS is a free, open source project created by the Canadian geospatial company Refractions Research and maintained by an international team of developers under the Open Source Geospatial Foundation. You’ll find documentation and updates at <em><a href="http://postgis.net/">http://postgis.net/</a></em>. If you’re using Windows or macOS and have installed PostgreSQL following the steps in the book’s Introduction, PostGIS should be on your machine. It’s also often installed on PostgreSQL on cloud providers, such as Amazon Web Services. But if you’re using Linux or if you installed PostgreSQL some other way on Windows or macOS, follow the installation instructions at <em><a href="http://postgis.net/install/">http://postgis.net/install/</a></em>.</p>
<p class="indent">Let’s create a database and enable PostGIS. The process is similar to the one you used to create your first database in <a href="ch01.xhtml#ch01">Chapter 1</a> but with a few extra steps. Follow these steps in pgAdmin to make a database called <span class="literal">gis_analysis</span>:</p>
<ol>
<li class="noindent"><p class="list">In the pgAdmin object browser (left pane), connect to your server and expand the <strong>Databases</strong> node by clicking the plus sign.</p></li>
<li class="noindent"><p class="list">Click once on the <span class="literal">analysis</span> database you’ve used for past exercises.</p></li>
<li class="noindent"><p class="list">Choose <strong>Tools <span class="ent">▸</span> Query Tool</strong>.</p></li>
<li class="noindent"><p class="list">In the Query Tool, run the code in <a href="ch14.xhtml#ch14list1">Listing 14-1</a>.</p></li>
</ol>
<p class="programs">CREATE DATABASE gis_analysis;</p>
<p class="listing" id="ch14list1"><em>Listing 14-1: Creating a <span class="literal">gis_analysis</span> database</em></p>
<p class="indent">PostgreSQL will create the <span class="literal">gis_analysis</span> database, which is no different than others you’ve made. To enable PostGIS extensions on it, follow these steps:</p>
<ol>
<li class="noindent"><p class="list">Close the Query Tool tab.</p></li>
<li class="noindent"><p class="list">In the object browser, right-click <strong>Databases</strong> and select <strong>Refresh</strong>.</p></li>
<li class="noindent"><p class="list">Click the new <span class="literal">gis_analysis</span> database in the list to highlight it.</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_243"/>Open a new Query Tool tab by selecting <strong>Tools <span class="ent">▸</span> Query Tool</strong>. The <span class="literal">gis_analysis</span> database should be listed at the top of the editing pane.</p></li>
<li class="noindent"><p class="list">In the Query Tool, run the code in <a href="ch14.xhtml#ch14list2">Listing 14-2</a>.</p></li>
</ol>
<p class="programs">CREATE EXTENSION postgis;</p>
<p class="listing" id="ch14list2"><em>Listing 14-2: Loading the PostGIS extension</em></p>
<p class="indent">You’ll see the message <span class="literal">CREATE EXTENSION</span>. Your database has now been updated to include spatial data types and dozens of spatial analysis functions. Run <span class="literal"><strong>SELECT postgis_full_version();</strong></span> to display the version number of PostGIS along with its installed components. The version won’t match the PostgreSQL version installed, but that’s okay.</p>
<h3 class="h3" id="lev236">The Building Blocks of Spatial Data</h3>
<p class="noindent">Before you learn to query spatial data, let’s look at how it’s described in GIS and related data formats (although if you want to dive straight into queries, you can skip to <a href="ch14.xhtml#lev248">“Analyzing Farmers’ Markets Data”</a> on <a href="ch14.xhtml#page_250">page 250</a> and return here later).</p>
<p class="indent">A point on a grid is the smallest building block of spatial data. The grid might be marked with x- and y-axes, or longitude and latitude if we’re using a map. A grid could be flat, with two dimensions, or it could describe a three-dimensional space such as a cube. In some data formats, such as the JavaScript-based <em>GeoJSON</em>, a point might have a location on the grid as well as attributes providing additional information. For example, a grocery store could be described by a point containing its longitude and latitude as well as attributes showing the store’s name and hours of operation.</p>
<h3 class="h3" id="lev237">Two-Dimensional Geometries</h3>
<p class="noindent">To create more complex spatial data, you connect multiple points using lines. The International Organization for Standardization (ISO) and the Open Geospatial Consortium (OGC) have created a <em>simple feature</em> standard for building and accessing two- and three-dimensional shapes, sometimes referred to as <em>geometries</em>. PostGIS supports the standard.</p>
<p class="indent">The most commonly used simple features you’ll encounter when querying or creating spatial data with PostGIS include the following:</p>
<p class="hang"><strong>Point</strong> A single location in a two- or three-dimensional plane. On maps, a Point is usually represented by a dot marking a longitude and latitude.</p>
<p class="hang"><strong>LineString</strong> Two or more points connected by a straight line. With LineStrings, you can represent features such as a road, hiking trail, or stream.</p>
<p class="hang"><strong>Polygon</strong> A two-dimensional shape, like a triangle or a square, that has three or more straight sides, each constructed from a LineString. In <span epub:type="pagebreak" id="page_244"/>geographic analysis, Polygons represent objects such as nations, states, buildings, and bodies of water. A Polygon also can have one or more interior Polygons that act as holes inside the larger Polygon.</p>
<p class="hang"><strong>MultiPoint</strong> A set of Points. For example, you can represent multiple locations of a retailer with a single MultiPoint object that contains each store’s latitude and longitude.</p>
<p class="hang"><strong>MultiLineString</strong> A set of LineStrings. You can represent, for example, an object such as a road with several noncontinuous segments.</p>
<p class="hang"><strong>MultiPolygon</strong> A set of Polygons. For example, you can represent a parcel of land that is divided into two parts by a road: you can group them in one MultiPolygon object rather than using separate polygons.</p>
<p class="indentt"><a href="ch14.xhtml#ch14fig1">Figure 14-1</a> shows an example of each feature.</p>
<div class="image"><a id="ch14fig1"/><img alt="image" src="../images/f0244-01.jpg"/></div>
<p class="figcap"><em>Figure 14-1: Visual examples of geometries</em></p>
<p class="indent">Using PostGIS functions, you can create your own spatial data by constructing these objects using points or other geometries. Or, you can use PostGIS functions to perform calculations on existing spatial data. Generally, to create a spatial object, the functions require input of a <em>well-known text (WKT)</em> string, which is text that represents a geometry, plus an optional <em>Spatial Reference System Identifier (SRID)</em> that specifies the grid on which to place the objects. I’ll explain the SRID shortly, but first, let’s look at examples of WKT strings and then build some geometries using them.</p>
<h4 class="h4" id="lev238"><em>Well-Known Text Formats</em></h4>
<p class="noindent">The OGC standard’s WKT format includes the geometry type and its coordinates inside one or more sets of parentheses. The number of coordinates and <span epub:type="pagebreak" id="page_245"/>parentheses varies depending on the geometry you want to create. <a href="ch14.xhtml#ch14tab1">Table 14-1</a> shows examples of the more frequently used geometry types and their WKT formats. Here, I show longitude/latitude pairs for the coordinates, but you might encounter grid systems that use other measures.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>WKT accepts coordinates in the order of longitude, latitude, which is backward from Google Maps and some other software. Tom MacWright, formerly of the Mapbox software company, notes at</em> <a href="https://macwright.org/lonlat/">https://macwright.org/lonlat/</a> <em>that neither order is “right” and catalogs the “frustrating inconsistency” in which mapping-related code handles the order of coordinates.</em></p>
</div>
<p class="tabcap" id="ch14tab1"><strong>Table 14-1:</strong> Well-Known Text Formats for Geometries</p>
<table class="topbot-d">
<thead>
<tr>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Geometry</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Format</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Notes</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table-a" style="vertical-align: top;"><p class="taba">Point</p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">POINT (-74.9 42.7)</span></p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba">A coordinate pair marking a point at −74.9 longitude and 42.7 latitude.</p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba">LineString</p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">LINESTRING (-74.9 42.7, -75.1 42.7)</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">A straight line with endpoints marked by two coordinate pairs.</p></td>
</tr>
<tr>
<td class="table-a" style="vertical-align: top;"><p class="taba">Polygon</p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">POLYGON ((-74.9 42.7, -75.1 42.7,<br/>-75.1 42.6, -74.9 42.7))</span></p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba">A triangle outlined by three different pairs of coordinates. Although listed twice, the first and last pair are the same coordinates, closing the shape.</p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba">MultiPoint</p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">MULTIPOINT (-74.9 42.7, -75.1 42.7)</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">Two Points, one for each pair of coordinates.</p></td>
</tr>
<tr>
<td class="table-a" style="vertical-align: top;"><p class="taba">MultiLineString</p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">MULTILINESTRING ((-76.27 43.1, -76.06 43.08), (-76.2 43.3, -76.2 43.4, -76.4 43.1))</span></p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba">Two LineStrings. The first has two points; the second has three.</p></td>
</tr>
<tr>
<td class="table-ca" style="vertical-align: top;"><p class="taba">MultiPolygon</p></td>
<td class="table-ca" style="vertical-align: top;"><p class="taba"><span class="literal">MULTIPOLYGON (((-74.92 42.7, -75.06 42.71, -75.07 42.64, -74.92 42.7), (-75.0 42.66, -75.0 42.64, -74.98 42.64, -74.98 42.66, -75.0 42.66)))</span></p></td>
<td class="table-ca" style="vertical-align: top;"><p class="taba">Two Polygons. The first is a triangle, and the second is a rectangle.</p></td>
</tr>
</tbody>
</table>
<p class="indent">Although these examples create simple shapes, in practice, complex geometries could comprise thousands of coordinates.</p>
<h4 class="h4" id="lev239"><em>A Note on Coordinate Systems</em></h4>
<p class="noindent">Representing the Earth’s spherical surface on a two-dimensional map is not easy. Imagine peeling the outer layer of the Earth from the globe and trying to spread it on a table while keeping all pieces of the continents and oceans connected. Inevitably, some areas of the map would stretch. This is what occurs when cartographers create a map <em>projection</em> with its own <em>projected coordinate system</em> that flattens the Earth’s round surface to a two-dimensional plane.</p>
<p class="indent">Some projections represent the entire world; others are specific to regions or purposes. For example, the <em>Mercator projection</em> is commonly used for navigation in apps, such as Google Maps. The math behind its transformation distorts land areas close to the North and South Poles, making <span epub:type="pagebreak" id="page_246"/>them appear much larger than reality. The <em>Albers projection</em> is the one you would most likely see displayed on TV screens in the United States as votes are tallied on election night. It’s also used by the U.S. Census Bureau.</p>
<p class="indent">Projections are derived from <em>geographic coordinate systems</em>, which define the grid of latitude, longitude, and height of any point on the globe along with factors including the Earth’s shape. Whenever you obtain geographic data, it’s critical to know the coordinate systems it references to check whether your calculations are accurate. Often, the coordinate system or projection is named in user documentation.</p>
<h4 class="h4" id="lev240"><em>Spatial Reference System Identifier</em></h4>
<p class="noindent">When using PostGIS (and many GIS applications), you need to specify the coordinate system you’re using via its SRID. When you enabled the PostGIS extension at the beginning of this chapter, the process created the table <span class="literal">spatial_ref_sys</span>, which contains SRIDs as its primary key. The table also contains the column <span class="literal">srtext</span>, which includes a WKT representation of the spatial reference system as well as other metadata.</p>
<p class="indent">In this chapter, we’ll frequently use SRID <span class="literal">4326</span>, the ID for the geographic coordinate system WGS 84. It’s the most recent World Geodetic System (WGS) standard used by GPS, and you’ll encounter it often if you acquire spatial data. You can see the WKT representation for WGS 84 by running the code in <a href="ch14.xhtml#ch14list3">Listing 14-3</a> that looks for its SRID, <span class="literal">4326</span>:</p>
<p class="programs">SELECT srtext<br/>FROM spatial_ref_sys<br/>WHERE srid = 4326;</p>
<p class="listing" id="ch14list3"><em>Listing 14-3: Retrieving the WKT for SRID <span class="literal">4326</span></em></p>
<p class="indent">Run the query and you should get the following result, which I’ve indented for readability:</p>
<p class="programs">GEOGCS["WGS 84",<br/>    DATUM["WGS_1984",<br/>        SPHEROID["WGS 84",6378137,298.257223563,<br/>            AUTHORITY["EPSG","7030"]],<br/>        AUTHORITY["EPSG","6326"]],<br/>    PRIMEM["Greenwich",0,<br/>        AUTHORITY["EPSG","8901"]],<br/>    UNIT["degree",0.0174532925199433,<br/>        AUTHORITY["EPSG","9122"]],<br/>    AUTHORITY["EPSG","4326"]]</p>
<p class="indent">You don’t need to use this information for any of this chapter’s exercises, but it’s helpful to know some of the variables and how they define the projection. The <span class="literal">GEOGCS</span> keyword provides the geographic coordinate system in use. Keyword <span class="literal">PRIMEM</span> specifies the location of the <em>Prime Meridian</em>, or longitude 0. To see definitions of all the variables, check the reference at <em><a href="http://docs.geotools.org/stable/javadocs/org/opengis/referencing/doc-files/WKT.html">http://docs.geotools.org/stable/javadocs/org/opengis/referencing/doc-files/WKT.html</a></em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_247"/>Conversely, if you ever need to find the SRID associated with a coordinate system, you can query the <span class="literal">srtext</span> column in <span class="literal">spatial_ref_sys</span> to find it.</p>
<h3 class="h3" id="lev241">PostGIS Data Types</h3>
<p class="noindent">Installing PostGIS adds five data types to your database. The two data types we’ll use in the exercises are <span class="literal">geography</span> and <span class="literal">geometry</span>. Both types can store spatial data, such as the points, lines, polygons, SRIDs, and so on you just learned about, but they have important distinctions:</p>
<p class="hang"><span class="codestrong">geography</span> A data type based on a sphere, using the round-earth coordinate system (longitude and latitude). All calculations occur on the globe, taking its curvature into account. That makes the math complicated and limits the number of functions available to work with the <span class="literal">geography</span> type. But because the Earth’s curvature is factored in, calculations for distance are more precise; you should use the <span class="literal">geography</span> data type when handling data that spans large areas. Also, the results from calculations on the <span class="literal">geography</span> type will be expressed in meters.</p>
<p class="hang"><span class="codestrong">geometry</span> A data type based on a plane, using the Euclidean coordinate system. Calculations occur on straight lines as opposed to along the curvature of a sphere, making calculations for geographical distance less precise than with the <span class="literal">geography</span> data type; the results of calculations are expressed in units of whichever coordinate system you’ve designated.</p>
<p class="indentt">The PostGIS documentation at <em><a href="https://postgis.net/docs/using_postgis_dbmanagement.html">https://postgis.net/docs/using_postgis_dbmanagement.html</a></em> offers guidance on when to use one or the other type. In short, if you’re working strictly with longitude/latitude data or if your data covers a large area, such as a continent or the globe, use the <span class="literal">geography</span> type, even though it limits the functions you can use. If your data covers a smaller area, the <span class="literal">geometry</span> type provides more functions and better performance. You can also change one type to the other using <span class="literal">CAST</span>.</p>
<p class="indent">With the background you have now, we can start working with spatial objects.</p>
<h3 class="h3" id="lev242">Creating Spatial Objects with PostGIS Functions</h3>
<p class="noindent">PostGIS has more than three dozen constructor functions that build spatial objects using WKT or coordinates. You can find a list at <em><a href="https://postgis.net/docs/reference.html#Geometry_Constructors">https://postgis.net/docs/reference.html#Geometry_Constructors</a></em>, but the following sections explain several that you’ll use in the exercises. Most PostGIS functions begin with the letters ST, which is an ISO naming standard that means <em>spatial type</em>.</p>
<h4 class="h4" id="lev243"><em>Creating a Geometry Type from Well-Known Text</em></h4>
<p class="noindent">The <span class="literal">ST_GeomFromText(</span><span class="codeitalic">WKT</span><span class="literal">,</span> <span class="codeitalic">SRID</span><span class="literal">)</span> function creates a <span class="literal">geometry</span> data type from an input of a WKT string and an optional SRID. <a href="ch14.xhtml#ch14list4">Listing 14-4</a> shows simple <span class="literal">SELECT</span> <span epub:type="pagebreak" id="page_248"/>statements that generate <span class="literal">geometry</span> data types for each of the simple features described in <a href="ch14.xhtml#ch14tab1">Table 14-1</a>. Running these <span class="literal">SELECT</span> statements is optional, but it’s important to know how to construct each simple feature.</p>
<p class="programs">SELECT ST_GeomFromText(<span class="ent">➊</span>'POINT(-74.9233606 42.699992)', <span class="ent">➋</span>4326);<br/>SELECT ST_GeomFromText('LINESTRING(-74.9 42.7, -75.1 42.7)', 4326); <br/>SELECT ST_GeomFromText('POLYGON((-74.9 42.7, -75.1 42.7,<br/>                                 -75.1 42.6, -74.9 42.7))', 4326);<br/>SELECT ST_GeomFromText('MULTIPOINT (-74.9 42.7, -75.1 42.7)', 4326);<br/>SELECT ST_GeomFromText('MULTILINESTRING((-76.27 43.1, -76.06 43.08),<br/>                                        (-76.2 43.3, -76.2 43.4,<br/>                                         -76.4 43.1))', 4326);<br/>SELECT ST_GeomFromText('MULTIPOLYGON<span class="ent">➌</span>((<br/>                                       (-74.92 42.7, -75.06 42.71,<br/>                                        -75.07 42.64, -74.92 42.7)<span class="ent">➍</span>,<br/>                                       (-75.0 42.66, -75.0 42.64,<br/>                                        -74.98 42.64, -74.98 42.66,<br/>                                        -75.0 42.66)))', 4326);</p>
<p class="listing" id="ch14list4"><em>Listing 14-4: Using <span class="literal">ST_GeomFromText()</span> to create spatial objects</em></p>
<p class="indent">For each example, we give coordinates as the first input and the SRID <span class="literal">4326</span> as the second. In the first example, we create a point by inserting the WKT <span class="literal">POINT</span> string <span class="ent">➊</span> as the first argument to <span class="literal">ST_GeomFromText()</span> with the SRID <span class="ent">➋</span> as the optional second argument. We use the same format in the rest of the examples. Note that we don’t have to indent the coordinates. I only do so here to make the coordinate pairs more readable.</p>
<p class="indent">Be sure to keep track of the number of parentheses that segregate objects, particularly in complex structures, such as the MultiPolygon. For example, we need to use two opening parentheses <span class="ent">➌</span> and enclose each polygon’s coordinates within another set of parentheses <span class="ent">➍</span>.</p>
<p class="indent">Executing each statement should return the <span class="literal">geometry</span> data type encoded in a string of characters that looks something like this truncated example:</p>
<p class="programs">0101000020E61000008EDA0E5718BB52C017BB7D5699594540 ...</p>
<p class="indent">This result shows how the data is stored in a table. Typically, you won’t be reading that string of code. Instead, you’ll use geometry (or geography) columns as inputs to functions.</p>
<h4 class="h4" id="lev244"><em>Creating a Geography Type from Well-Known Text</em></h4>
<p class="noindent">To create a <span class="literal">geography</span> data type, you can use <span class="literal">ST_GeogFromText(</span><span class="codeitalic">WKT</span><span class="literal">)</span> to convert a WKT or <span class="literal">ST_GeogFromText(</span><span class="codeitalic">EWKT</span><span class="literal">)</span> to convert a PostGIS-specific variation called <span epub:type="pagebreak" id="page_249"/><em>extended WKT</em> that includes the SRID. <a href="ch14.xhtml#ch14list5">Listing 14-5</a> shows how to pass in the SRID as part of the extended WKT string to create a MultiPoint <span class="literal">geography</span> object with three points:</p>
<p class="programs">SELECT<br/>ST_GeogFromText('SRID=4326;MULTIPOINT(-74.9 42.7, -75.1 42.7, -74.924 42.6)')</p>
<p class="listing" id="ch14list5"><em>Listing 14-5: Using <span class="literal">ST_GeogFromText()</span> to create spatial objects</em></p>
<p class="indent">Along with the all-purpose <span class="literal">ST_GeomFromText()</span> and <span class="literal">ST_GeogFromText()</span> functions, PostGIS includes several that are specific to creating certain spatial objects. I’ll cover those briefly next.</p>
<h4 class="h4" id="lev245"><em>Point Functions</em></h4>
<p class="noindent">The <span class="literal">ST_PointFromText()</span> and <span class="literal">ST_MakePoint()</span> functions will turn a WKT <span class="literal">POINT</span> into a <span class="literal">geometry</span> data type. Points mark coordinates, such as longitude and latitude, which you would use to identify locations or use as building blocks of other objects, such as LineStrings.</p>
<p class="indent"><a href="ch14.xhtml#ch14list6">Listing 14-6</a> shows how these functions work:</p>
<p class="programs">SELECT <span class="ent">➊</span>ST_PointFromText('POINT(-74.9233606 42.699992)', 4326);<br/><br/>SELECT <span class="ent">➋</span>ST_MakePoint(-74.9233606, 42.699992);<br/>SELECT <span class="ent">➌</span>ST_SetSRID(ST_MakePoint(-74.9233606, 42.699992), 4326);</p>
<p class="listing" id="ch14list6"><em>Listing 14-6: Functions specific to making Points</em></p>
<p class="indent">The <span class="literal">ST_PointFromText(</span><span class="codeitalic">WKT,</span> <span class="codeitalic">SRID</span><span class="literal">)</span> <span class="ent">➊</span> function creates a point <span class="literal">geometry</span> type from a WKT <span class="literal">POINT</span> and an optional SRID as the second input. The PostGIS docs note that the function includes validation of coordinates that makes it slower than the <span class="literal">ST_GeomFromText()</span> function.</p>
<p class="indent">The <span class="literal">ST_MakePoint(</span><span class="codeitalic">x,</span> <span class="codeitalic">y,</span> <span class="codeitalic">z,</span> <span class="codeitalic">m</span><span class="literal">)</span> <span class="ent">➋</span> function creates a point <span class="literal">geometry</span> type on a two-, three-, and four-dimensional grid. The first two parameters, <span class="codeitalic">x</span> and <span class="codeitalic">y</span> in the example, represent longitude and latitude coordinates. You can use the optional <span class="codeitalic">z</span> to represent altitude and <span class="codeitalic">m</span> to represent a fourth-dimensional measure, such as time. That would allow you to mark a location at a certain time, for example. The <span class="literal">ST_MakePoint()</span> function is faster than <span class="literal">ST_GeomFromText()</span> and <span class="literal">ST_PointFromText()</span>, but if you want to specify an SRID, you’ll need to designate one by wrapping it inside the <span class="literal">ST_SetSRID()</span> <span class="ent">➌</span> function.</p>
<h4 class="h4" id="lev246"><em>LineString Functions</em></h4>
<p class="noindent">Now let’s examine some functions we use specifically for creating LineString <span class="literal">geometry</span> data types. <a href="ch14.xhtml#ch14list7">Listing 14-7</a> shows how they work:</p>
<p class="programs">SELECT <span class="ent">➊</span>ST_LineFromText('LINESTRING(-105.90 35.67,-105.91 35.67)', 4326);<br/>SELECT <span class="ent">➋</span>ST_MakeLine(ST_MakePoint(-74.9, 42.7), ST_MakePoint(-74.1, 42.4));</p>
<p class="listing" id="ch14list7"><em>Listing 14-7: Functions specific to making LineStrings</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_250"/>The <span class="literal">ST_LineFromText(</span><span class="codeitalic">WKT</span><span class="literal">,</span> <span class="codeitalic">SRID</span><span class="literal">)</span> <span class="ent">➊</span> function creates a LineString from a WKT <span class="literal">LINESTRING</span> and an optional SRID as its second input. Like <span class="literal">ST_PointFromText()</span> earlier, this function includes validation of coordinates that makes it slower than <span class="literal">ST_GeomFromText()</span>.</p>
<p class="indent">The <span class="literal">ST_MakeLine(</span><span class="codeitalic">geom,</span> <span class="codeitalic">geom</span><span class="literal">)</span> <span class="ent">➋</span> function creates a LineString from inputs that must be of the <span class="literal">geometry</span> data type. In <a href="ch14.xhtml#ch14list7">Listing 14-7</a>, the example uses two <span class="literal">ST_MakePoint()</span> functions as inputs to create the start and endpoint of the line. You can also pass in an <span class="literal">ARRAY</span> object with multiple points, perhaps generated by a subquery, to generate a more complex line.</p>
<h4 class="h4" id="lev247"><em>Polygon Functions</em></h4>
<p class="noindent">Let’s look at three Polygon functions: <span class="literal">ST_PolygonFromText()</span>, <span class="literal">ST_MakePolygon()</span>, and <span class="literal">ST_MPolyFromText()</span>. All create <span class="literal">geometry</span> data types. <a href="ch14.xhtml#ch14list8">Listing 14-8</a> shows how you can create Polygons with each:</p>
<p class="programs">SELECT <span class="ent">➊</span>ST_PolygonFromText('POLYGON((-74.9 42.7, -75.1 42.7,<br/>                                      -75.1 42.6, -74.9 42.7))', 4326);<br/><br/>SELECT <span class="ent">➋</span>ST_MakePolygon(<br/>             ST_GeomFromText('LINESTRING(-74.92 42.7, -75.06 42.71,<br/>                                         -75.07 42.64, -74.92 42.7)', 4326));<br/><br/>SELECT <span class="ent">➌</span>ST_MPolyFromText('MULTIPOLYGON((<br/>                                         (-74.92 42.7, -75.06 42.71,<br/>                                          -75.07 42.64, -74.92 42.7),<br/>                                         (-75.0 42.66, -75.0 42.64,<br/>                                          -74.98 42.64, -74.98 42.66,<br/>                                          -75.0 42.66)<br/>                                        ))', 4326);</p>
<p class="listing" id="ch14list8"><em>Listing 14-8: Functions specific to making Polygons</em></p>
<p class="indent">The <span class="literal">ST_PolygonFromText(</span><span class="codeitalic">WKT,</span> <span class="codeitalic">SRID</span><span class="literal">)</span> <span class="ent">➊</span> function creates a Polygon from a WKT <span class="literal">POLYGON</span> and an optional SRID. As with the similarly named functions for creating points and lines, it includes a validation step that makes it slower than <span class="literal">ST_GeomFromText()</span>.</p>
<p class="indent">The <span class="literal">ST_MakePolygon(</span><span class="codeitalic">linestring</span><span class="literal">)</span> <span class="ent">➋</span> function creates a Polygon from a LineString that must open and close with the same coordinates, ensuring the object is closed. This example uses <span class="literal">ST_GeomFromText()</span> to create the LineString geometry using a WKT <span class="literal">LINESTRING</span>.</p>
<p class="indent">The <span class="literal">ST_MPolyFromText(</span><span class="codeitalic">WKT,</span> <span class="codeitalic">SRID</span><span class="literal">)</span> <span class="ent">➌</span> function creates a MultiPolygon from a WKT and an optional SRID.</p>
<p class="indent">Now you have the building blocks to analyze spatial data. Next, we’ll use them to explore a set of data.</p>
<h3 class="h3" id="lev248">Analyzing Farmers’ Markets Data</h3>
<p class="noindent">The National Farmers’ Market Directory from the U.S. Department of Agriculture catalogs the location and offerings of more than <span epub:type="pagebreak" id="page_251"/>8,600 “markets that feature two or more farm vendors selling agricultural products directly to customers at a common, recurrent physical location,” according to <em><a href="https://www.ams.usda.gov/local-food-directories/farmersmarkets/">https://www.ams.usda.gov/local-food-directories/farmersmarkets/</a></em>. Attending these markets makes for an enjoyable weekend activity, so it would help to find those within a reasonable traveling distance. We can use SQL spatial queries to find the closest markets.</p>
<p class="indent">The <em>farmers_markets.csv</em> file contains a portion of the USDA data on each market, and it’s available along with the book’s resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>. Save the file to your computer and run the code in <a href="ch14.xhtml#ch14list9">Listing 14-9</a> to create and load a <span class="literal">farmers_markets</span> table. Make sure you’re connected to the <span class="literal">gis_analysis</span> database you made earlier in this chapter, and change the <span class="literal">COPY</span> statement file path to match your file’s location.</p>
<p class="programs">CREATE TABLE farmers_markets (<br/>    fmid bigint PRIMARY KEY, <br/>    market_name varchar(100) NOT NULL, <br/>    street varchar(180), <br/>    city varchar(60), <br/>    county varchar(25), <br/>    st varchar(20) NOT NULL, <br/>    zip varchar(10), <br/>    longitude numeric(10,7), <br/>    latitude numeric(10,7), <br/>    organic varchar(1) NOT NULL<br/>);<br/><br/>COPY farmers_markets<br/>FROM '<em>C:\YourDirectory\</em>farmers_markets.csv'<br/>WITH (FORMAT CSV, HEADER);</p>
<p class="listing" id="ch14list9"><em>Listing 14-9: Creating and loading the <span class="literal">farmers_markets</span> table</em></p>
<p class="indent">The table contains routine address data plus the <span class="literal">longitude</span> and <span class="literal">latitude</span> for most markets. Twenty-nine of the markets were missing those values when I downloaded the file from the USDA. An <span class="literal">organic</span> column indicates whether the market offers organic products; a hyphen (<span class="literal">-</span>) in that column indicates an unknown value. After you import the data, count the rows using <span class="literal">SELECT count(*) FROM farmers_markets;</span>. If everything imported correctly, you should have 8,681 rows.</p>
<h4 class="h4" id="lev249"><em>Creating and Filling a Geography Column</em></h4>
<p class="noindent">To perform spatial queries on the markets’ longitude and latitude, we need to convert those coordinates into a single column of a spatial data type. Because we’re working with locations spanning the entire United States and an accurate measurement of a large spherical distance is important, we’ll use the <span class="literal">geography</span> type. After creating the column, we can update it using Points derived from the coordinates, and then apply <span epub:type="pagebreak" id="page_252"/>an index to speed up queries. <a href="ch14.xhtml#ch14list10">Listing 14-10</a> contains the statements for doing these tasks:</p>
<p class="programs"><span class="ent">➊</span> ALTER TABLE farmers_markets ADD COLUMN geog_point geography(POINT,4326);<br/><br/>  UPDATE farmers_markets<br/>  SET geog_point =<br/>      <span class="ent">➋</span>ST_SetSRID(<br/>                <span class="ent">➌</span>ST_MakePoint(longitude,latitude),4326<br/>                )<span class="ent">➍</span>::geography;<br/><br/><span class="ent">➎</span> CREATE INDEX market_pts_idx ON farmers_markets USING GIST (geog_point);<br/><br/>  SELECT longitude,<br/>         latitude,<br/>         geog_point,<br/>       <span class="ent">➏</span> ST_AsText(geog_point)<br/>  FROM farmers_markets<br/>  WHERE longitude IS NOT NULL<br/>  LIMIT 5;</p>
<p class="listing" id="ch14list10"><em>Listing 14-10: Creating and indexing a <span class="literal">geography</span> column</em></p>
<p class="indent">The <span class="literal">ALTER TABLE</span> statement <span class="ent">➊</span> you learned in <a href="ch09.xhtml#ch09">Chapter 9</a> with the <span class="literal">ADD COLUMN</span> option creates a column of the <span class="literal">geography</span> type called <span class="literal">geog_point</span> that will hold points and reference the WSG 84 coordinate system, which we denote using SRID <span class="literal">4326</span>.</p>
<p class="indent">Next, we run a standard <span class="literal">UPDATE</span> statement to fill the <span class="literal">geog_point</span> column. Nested inside a <span class="literal">ST_SetSRID()</span> <span class="ent">➋</span> function, the <span class="literal">ST_MakePoint()</span> <span class="ent">➌</span> function takes as input the <span class="literal">longitude</span> and <span class="literal">latitude</span> columns from the table. The output, which is the <span class="literal">geometry</span> type by default, must be cast to <span class="literal">geography</span> to match the <span class="literal">geog_point</span> column type. To do this, we use the PostgreSQL-specific double-colon syntax (<span class="literal">::</span>) <span class="ent">➍</span> for casting data types.</p>
<h4 class="h4" id="lev250"><em>Adding a GiST Index</em></h4>
<p class="noindent">Before you start analysis, it’s wise to add an index to the new column to speed up calculations. In <a href="ch07.xhtml#ch07">Chapter 7</a>, you learned about PostgreSQL’s default index, the B-Tree. A B-Tree index is useful for data that you can order and search using equality and range operators, but it’s less useful for spatial objects. The reason is that you cannot easily sort GIS data along one axis. For example, the application has no way to determine which of these coordinate pairs is greatest: (0,0), (0,1), or (1,0).</p>
<p class="indent">Instead, for spatial data, the makers of PostGIS recommend using the Generalized Search Tree (GiST) index. PostgreSQL core team member Bruce Momjian describes GiST as “a general indexing framework designed to allow indexing of complex data types,” including geometries.</p>
<p class="indent">The <span class="literal">CREATE INDEX</span> statement <span class="ent">➎</span> in <a href="ch14.xhtml#ch14list10">Listing 14-10</a> adds a GiST index to <span class="literal">geog_point</span>. We can then use the <span class="literal">SELECT</span> statement to view the geography <span epub:type="pagebreak" id="page_253"/>data to show the newly encoded <span class="literal">geog_points</span> column. To view the WKT version of <span class="literal">geog_point</span>, we wrap it in a <span class="literal">ST_AsText()</span> function <span class="ent">➏</span>. The results should look similar to this, with <span class="literal">geog_point</span> truncated for brevity:</p>
<div class="image"><img alt="image" src="../images/prog_page_253.jpg"/></div>
<p class="indent">Now we’re ready to perform calculations on the points.</p>
<h4 class="h4" id="lev251"><em>Finding Geographies Within a Given Distance</em></h4>
<p class="noindent">While in Iowa in 2014 to report a story on farming, I visited the massive Downtown Farmers’ Market in Des Moines. With hundreds of vendors, the market spans several city blocks in the Iowa capital. Farming is big business in Iowa, and even though the downtown market is huge, it’s not the only one in the area. Let’s use PostGIS to find more farmers’ markets within a short distance from the downtown Des Moines market.</p>
<p class="indent">The PostGIS function <span class="literal">ST_DWithin()</span> returns a Boolean value of <span class="literal">true</span> if one spatial object is within a specified distance of another object. If you’re working with the <span class="literal">geography</span> data type, as we are here, you need to use meters as the distance unit. If you’re using the <span class="literal">geometry</span> type, use the distance unit specified by the SRID.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>PostGIS distance measurements are on a straight line for geometry data, whereas for geography data, they’re on a sphere. Be careful not to confuse either with driving distance along roadways, which is usually farther from point to point. To perform calculations related to driving distances, check out the extension pgRouting at</em> <a href="http://pgrouting.org/">http://pgrouting.org/</a>.</p>
</div>
<p class="indent"><a href="ch14.xhtml#ch14list11">Listing 14-11</a> uses the <span class="literal">ST_DWithin()</span> function to filter <span class="literal">farmers_markets</span> to show markets within 10 kilometers of the Downtown Farmers’ Market in Des Moines:</p>
<p class="programs">SELECT market_name,<br/>       city,<br/>       st<br/>FROM farmers_markets<br/>WHERE ST_DWithin(<span class="ent">➊</span>geog_point,<br/>                 <span class="ent">➋</span>ST_GeogFromText('POINT(-93.6204386 41.5853202)'),<br/>                 <span class="ent">➌</span>10000)<br/>ORDER BY market_name;</p>
<p class="listing" id="ch14list11"><em>Listing 14-11: Using <span class="literal">ST_DWithin()</span> to locate farmers’ markets within 10 kilometers of a point</em></p>
<p class="indent">The first input for <span class="literal">ST_DWithin()</span> is <span class="literal">geog_point</span> <span class="ent">➊</span>, which holds the location of each row’s market in the <span class="literal">geography</span> data type. The second input is the <span epub:type="pagebreak" id="page_254"/><span class="literal">ST_GeogFromText()</span> function <span class="ent">➋</span> that returns a point geography from WKT. The coordinates <span class="literal">-93.6204386</span> and <span class="literal">41.5853202</span> represent the longitude and latitude of the Downtown Farmers’ Market in Des Moines. The final input is <span class="literal">10000</span> <span class="ent">➌</span>, which is the number of meters in 10 kilometers. The database calculates the distance between each market in the table and the downtown market. If a market is within 10 kilometers, it is included in the results.</p>
<p class="indent">We’re using points here, but this function works with any geography or geometry type. If you’re working with objects such as polygons, you can use the related <span class="literal">ST_DFullyWithin()</span> function to find objects that are completely within a specified distance.</p>
<p class="indent">Run the query; it should return nine rows:</p>
<p class="programs">market_name                                city               st<br/>---------------------------------------    ---------------    ----<br/>Beaverdale Farmers Market                  Des Moines         Iowa<br/>Capitol Hill Farmers Market                Des Moines         Iowa<br/>Downtown Farmers' Market - Des Moines      Des Moines         Iowa<br/>Drake Neighborhood Farmers Market          Des Moines         Iowa<br/>Eastside Farmers Market                    Des Moines         Iowa<br/>Highland Park Farmers Market               Des Moines         Iowa<br/>Historic Valley Junction Farmers Market    West Des Moines    Iowa<br/>LSI Global Greens Farmers' Market          Des Moines         Iowa<br/>Valley Junction Farmers Market             West Des Moines    Iowa</p>
<p class="indent">One of these nine markets is the Downtown Farmers’ Market in Des Moines, which makes sense because its location is at the point used for comparison. The rest are other markets in Des Moines or in nearby West Des Moines. This operation should be familiar because it’s a standard feature on many online maps and product apps that let you locate stores or points of interest near you.</p>
<p class="indent">Although this list of nearby markets is helpful, it would be even more helpful to know the exact distance of markets from downtown. We’ll use another function to report that.</p>
<h4 class="h4" id="lev252"><em>Finding the Distance Between Geographies</em></h4>
<p class="noindent">The <span class="literal">ST_Distance()</span> function returns the minimum distance between two spatial objects. It also returns meters for geographies and SRID units for geometries. For example, <a href="ch14.xhtml#ch14list12">Listing 14-12</a> calculates the distance in miles from Yankee Stadium in New York City’s Bronx borough to Citi Field in Queens, home of the New York Mets:</p>
<p class="programs">SELECT ST_Distance(<br/>                   ST_GeogFromText('POINT(-73.9283685 40.8296466)'),<br/>                   ST_GeogFromText('POINT(-73.8480153 40.7570917)')<br/>                   ) / 1609.344 AS mets_to_yanks;</p>
<p class="listing" id="ch14list12"><em>Listing 14-12: Using <span class="literal">ST_Distance()</span> to calculate the miles between Yankee Stadium and Citi Field (Mets)</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_255"/>In this example, to see the result in miles, we divide the result of the <span class="literal">ST_Distance()</span> function by 1609.344 (the number of meters in a mile) to convert the unit of distance from meters to miles. The result is about 6.5 miles:</p>
<p class="programs">mets_to_yanks<br/>----------------<br/>6.54386182787521</p>
<p class="indent">Let’s apply this technique for finding distance between points to the farmers’ market data using the code in <a href="ch14.xhtml#ch14list13">Listing 14-13</a>. We’ll display all farmers’ markets within 10 kilometers of the Downtown Farmers’ Market in Des Moines and show the distance in miles:</p>
<p class="programs">  SELECT market_name,<br/>         city,<br/>        <span class="ent">➊</span>round(<br/>              (ST_Distance(geog_point,<br/>                           ST_GeogFromText('POINT(-93.6204386 41.5853202)')<br/>                           ) / 1609.344)<span class="ent">➋</span>::numeric(8,5), 2<br/>              ) AS miles_from_dt<br/>  FROM farmers_markets<br/><span class="ent">➌</span> WHERE ST_DWithin(geog_point,<br/>                   ST_GeogFromText('POINT(-93.6204386 41.5853202)'),<br/>                   10000)<br/>  ORDER BY miles_from_dt ASC;</p>
<p class="listing" id="ch14list13"><em>Listing 14-13: Using <span class="literal">ST_Distance()</span> for each row in <span class="literal">farmers_markets</span></em></p>
<p class="indent">The query is similar to <a href="ch14.xhtml#ch14list11">Listing 14-11</a>, which used <span class="literal">ST_DWithin()</span> to find markets 10 kilometers or closer to downtown, but adds the <span class="literal">ST_Distance()</span> function as a column to calculate and display the distance from downtown. I’ve wrapped the function inside <span class="literal">round()</span> <span class="ent">➊</span> to trim the output.</p>
<p class="indent">We provide <span class="literal">ST_Distance()</span> with the same two inputs we gave <span class="literal">ST_DWithin()</span> in <a href="ch14.xhtml#ch14list11">Listing 14-11</a>: <span class="literal">geog_point</span> and the <span class="literal">ST_GeogFromText()</span> function. The <span class="literal">ST_Distance()</span> function then calculates the distance between the points specified by both inputs, returning the result in meters. To convert to miles, we divide by <span class="literal">1609.344</span> <span class="ent">➋</span>, which is the approximate number of meters in a mile. Then, to provide the <span class="literal">round()</span> function with the correct input data type, we cast the column result to type <span class="literal">numeric</span>.</p>
<p class="indent">The <span class="literal">WHERE</span> clause <span class="ent">➌</span> uses the same <span class="literal">ST_DWithin()</span> function and inputs as in <a href="ch14.xhtml#ch14list11">Listing 14-11</a>. You should see the following results, ordered by distance in ascending order:</p>
<div class="image"><img alt="image" src="../images/prog_page_255.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_256"/>Again, this is the type of list you see every day on your phone or computer when you’re searching online for a nearby store or address. You might also find it helpful for many other analysis scenarios, such as finding all the schools within a certain distance of a known source of pollution or all the houses within five miles of an airport.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Another type of distance measurement supported by PostGIS,</em> K-Nearest Neighbor, <em>provides the ability to quickly find the closest point or shape to one you specify. For a lengthy overview of how it works, see</em> <a href="http://workshops.boundlessgeo.com/postgis-intro/knn.html">http://workshops.boundlessgeo.com/postgis-intro/knn.html</a>.</p>
</div>
<p class="indent">So far, you’ve learned how to build spatial objects from WKT. Next, I’ll show you a common data format used in GIS called the <em>shapefile</em> and how to bring it into PostGIS for analysis.</p>
<h3 class="h3" id="lev253">Working with Census Shapefiles</h3>
<p class="noindent">A <em>shapefile</em> is a GIS data format developed by Esri, a U.S. company known for its ArcGIS mapping visualization and analysis platform. In addition to serving as the standard file format for GIS platforms—such as ArcGIS and the open source QGIS—governments, corporations, nonprofits, and technical organizations use shapefiles to display, analyze, and distribute data that includes a variety of geographic features, such as buildings, roads, and territorial boundaries.</p>
<p class="indent">Shapefiles contain the information describing the shape of a feature (such as a county, a road, or a lake) as well as a database containing attributes about them. Those attributes might include their name and other descriptors. A single shapefile can contain only one type of shape, such as polygons or points, and when you load a shapefile into a GIS platform that supports visualization, you can view the shapes and query their attributes. PostgreSQL, with the PostGIS extension, doesn’t visualize the shapefile data, but it does allow you to run complex queries on the spatial data in the shapefile, which we’ll do in <a href="ch14.xhtml#lev259">“Exploring the Census 2010 Counties Shapefile”</a> on <a href="ch14.xhtml#page_259">page 259</a> and <a href="ch14.xhtml#lev262">“Performing Spatial Joins”</a> on <a href="ch14.xhtml#page_262">page 262</a>.</p>
<p class="indent">First, let’s examine the structure and contents of shapefiles.</p>
<h4 class="h4" id="lev254"><em>Contents of a Shapefile</em></h4>
<p class="noindent">A shapefile refers to a collection of files with different extensions, and each serves a different purpose. Usually, when you download a shapefile from a source, it comes in a compressed archive, such as <em>.zip</em>. You’ll need to unzip it to access the individual files.</p>
<p class="indent"><span epub:type="pagebreak" id="page_257"/>Per ArcGIS documentation, these are the most common extensions you’ll encounter:</p>
<p class="hang"><strong>.shp</strong> Main file that stores the feature geometry.</p>
<p class="hang"><strong>.shx</strong> Index file that stores the index of the feature geometry.</p>
<p class="hang"><strong>.dbf</strong> Database table (in dBASE format) that stores the attribute information of features.</p>
<p class="hang"><strong>.xml</strong> XML-format file that stores metadata about the shapefile.</p>
<p class="hang"><strong>.prj</strong> Projection file that stores the coordinate system information. You can open this file with a text editor to view the geographic coordinate system and projection.</p>
<p class="indentt">According to the documentation, files with the first three extensions include necessary data required for working with a shapefile. The other file types are optional. You can load a shapefile into PostGIS to access its spatial objects and the attributes for each. Let’s do that next and explore some additional analysis functions.</p>
<h4 class="h4" id="lev255"><em>Loading Shapefiles via the GUI Tool</em></h4>
<p class="noindent">There are two ways to load shapefiles into your database. The PostGIS suite includes a Shapefile Import/Export Manager with a simple <em>graphical user interface (GUI)</em>, which users may prefer. Alternately, you can use the command line application <span class="literal">shp2pgsql</span>, which is described in <a href="ch16.xhtml#lev301">“Loading Shapefiles with <span class="literal">shp2pgsql</span>”</a> on <a href="ch16.xhtml#page_311">page 311</a>.</p>
<p class="indent">Let’s start with a look at how to work with the GUI tool.</p>
<h5 class="h5" id="lev256">Windows Shapefile Importer/Exporter</h5>
<p class="noindent">On Windows, if you followed the installation steps in the book’s Introduction, you should find the Shapefile Import/Export Manager by selecting <strong>Start <span class="ent">▸</span> PostGIS Bundle</strong> <strong>x.y for PostgreSQL x64</strong> <strong>x.y <span class="ent">▸</span> PostGIS 2.0 Shapefile and DBF Loader Exporter</strong>.</p>
<p class="indent">Whatever you see in place of <em>x.y</em> should match the version of the software you downloaded. You can skip ahead to <a href="ch14.xhtml#lev258">“Connecting to the Database and Loading a Shapefile”</a> on <a href="ch14.xhtml#page_258">page 258</a>.</p>
<h5 class="h5" id="lev257">macOS and Linux Shapefile Importer/Exporter</h5>
<p class="noindent">On macOS, the <em>postgres.app</em> installation outlined in the book’s Introduction doesn’t include the GUI tool, and as of this writing the only macOS version of the tool available (from the geospatial firm Boundless) doesn’t work with macOS High Sierra. I’ll update the status at the book’s resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em> if that changes. In the meantime, follow the instructions found in <a href="ch16.xhtml#lev301">“Loading Shapefiles with <span class="literal">shp2pgsql</span>”</a> on <a href="ch16.xhtml#page_311">page 311</a>. Then move on to <a href="ch14.xhtml#lev259">“Exploring the Census 2010 Counties Shapefile”</a> on <a href="ch14.xhtml#page_259">page 259</a>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_258"/>For Linux users, pgShapeLoader is available as the application <em>shp2pgsql-gui</em>. Visit <em><a href="http://postgis.net/install/">http://postgis.net/install/</a></em> and follow the instructions for your Linux distribution.</p>
<p class="indent">Now, you can connect to the database and load a shapefile.</p>
<h5 class="h5" id="lev258">Connecting to the Database and Loading a Shapefile</h5>
<p class="noindent">Let’s connect the Shapefile Import/Export Manager to your database and then load a shapefile. I’ve included several shapefiles with the resources for this chapter at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>. We’ll start with TIGER/Line Shapefiles from the U.S. Census that contain the boundaries for each county or county equivalent, such as parish or borough, as of the 2010 Decennial Census. You can learn more about this series of shapefiles at <em><a href="https://www.census.gov/geo/maps-data/data/tiger-line.html">https://www.census.gov/geo/maps-data/data/tiger-line.html</a></em>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Many organizations provide data in shapefile format. Start with your national or local government agencies or check the Wikipedia entry “List of GIS data sources.”</em></p>
</div>
<p class="indent">Save <em>tl_2010_us_county10.zip</em> to your computer and unzip it; the archive should contain five files with the extensions I listed earlier on <a href="ch14.xhtml#page_257">page 257</a>. Then open the Shapefile and DBF Loader Exporter app.</p>
<p class="indent">First, you need to establish a connection between the app and your <span class="literal">gis_analysis</span> database. To do that, follow these steps:</p>
<ol>
<li class="noindent"><p class="list">Click <strong>View connection details</strong>.</p></li>
<li class="noindent"><p class="list">In the dialog that opens, enter <span class="literal">postgres</span> for the <strong>Username</strong>, and enter a password if you added one for the server during initial setup.</p></li>
<li class="noindent"><p class="list">Ensure that <strong>Server Host</strong> has <span class="literal">localhost</span> and <span class="literal">5432</span> by default. Leave those as is unless you’re on a different server or port.</p></li>
<li class="noindent"><p class="list">Enter <span class="literal">gis_analysis</span> for the <strong>Database</strong> name. <a href="ch14.xhtml#ch14fig2">Figure 14-2</a> shows a screenshot of what the connection should look like.</p></li>
<li class="noindent"><p class="list">Click <strong>OK</strong>. You should see the message <span class="literal">Connection Succeeded</span> in the log window.</p></li>
</ol>
<div class="image"><a id="ch14fig2"/><img alt="image" src="../images/f0258-01.jpg"/></div>
<p class="figcap"><em>Figure 14-2: Establishing the PostGIS connection in the shapefile loader</em></p>
<p class="indent">Now that you’ve successfully established the PostGIS connection, you can load your shapefile:</p>
<ol>
<li class="noindent"><p class="list">Under <strong>Options</strong>, change <strong>DBF file character encoding</strong> to <span class="literal">Latin1</span>—we do this because the shapefile attributes include county names with characters that require this encoding. Keep the default checked boxes, including the one to create an index on the spatial column. Click <strong>OK</strong>.</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_259"/>Click <strong>Add File</strong> and select <em>tl_2010_us_county10.shp</em> from the location you saved it. Click <strong>Open</strong>. The file should appear in the Shapefile list in the loader, as shown in <a href="ch14.xhtml#ch14fig3">Figure 14-3</a>.</p>
<div class="image"><a id="ch14fig3"/><img alt="image" src="../images/f0259-01.jpg"/></div>
<p class="figcap"><em>Figure 14-3: Specifying upload details in the shapefile loader</em></p></li>
<li class="noindent"><p class="list">In the <strong>Table</strong> column, double-click to select the table name. Replace it with <span class="literal">us_counties_2010_shp</span>.</p></li>
<li class="noindent"><p class="list">In the <strong>SRID</strong> column, double-click and enter <span class="literal"><strong>4269</strong></span>. That’s the ID for the North American Datum 1983 coordinate system, which is often used by U.S. federal agencies including the Census Bureau.</p></li>
<li class="noindent"><p class="list">Click <strong>Import</strong>.</p></li>
</ol>
<p class="indent">In the log window, you should see a message that ends with the following message:</p>
<p class="programs">Shapefile type: Polygon<br/>PostGIS type: MULTIPOLYGON[2]<br/>Shapefile import completed.</p>
<p class="indent">Switch to pgAdmin, and in the object browser, expand the <span class="literal">gis_analysis</span> node and continue expanding by selecting <strong>Schemas <span class="ent">▸</span> public <span class="ent">▸</span> Tables</strong>. Refresh your tables by right-clicking <strong>Tables</strong> and selecting <strong>Refresh</strong> from the pop-up menu. You should see <span class="literal">us_counties_2010_shp</span> listed. Congrats! You’ve loaded your shapefile into a table. As part of the import, the shapefile loader also indexed the <span class="literal">geom</span> column.</p>
<h4 class="h4" id="lev259"><em>Exploring the Census 2010 Counties Shapefile</em></h4>
<p class="noindent">The <span class="literal">us_counties_2010_shp</span> table contains columns including each county’s name as well as the <em>Federal Information Processing Standards (FIPS)</em> codes uniquely assigned to each state and county. The <span class="literal">geom</span> column contains the spatial data on each county’s boundary. To start, let’s check what kind of <span epub:type="pagebreak" id="page_260"/>spatial object <span class="literal">geom</span> contains using the <span class="literal">ST_AsText()</span> function. Use the code in <a href="ch14.xhtml#ch14list14">Listing 14-14</a> to show the WKT representation of the first <span class="literal">geom</span> value in the table.</p>
<p class="programs">SELECT ST_AsText(geom)<br/>FROM us_counties_2010_shp<br/>LIMIT 1;</p>
<p class="listing" id="ch14list14"><em>Listing 14-14: Checking the <span class="literal">geom</span> column’s WKT representation</em></p>
<p class="indent">The result is a MultiPolygon with hundreds of coordinate pairs that outline the boundary of the county. Here’s a portion of the output:</p>
<p class="programs">MULTIPOLYGON(((-162.637688 54.801121,-162.641178 54.795317,-162.644046<br/>54.789099,-162.653751 54.780339,-162.666629 54.770215,-162.677799 54.762716,-<br/>162.692356 54.758771,-162.70676 54.754987,-162.722965 54.753155,-162.740178<br/>54.753102,-162.76206 54.757968,-162.783454 54.765285,-162.797004 54.772181,<br/>-162.802591 54.775817,-162.807411 54.779871,-162.811898 54.786852, <em>--snip--</em> )))</p>
<p class="indent">Each coordinate pair marks a point on the boundary of the county. Now, you’re ready to analyze the data.</p>
<h5 class="h5" id="lev260">Finding the Largest Counties in Square Miles</h5>
<p class="noindent">The census data leads us to a natural question: which county has the largest area? To calculate the county area, <a href="ch14.xhtml#ch14list15">Listing 14-15</a> uses the <span class="literal">ST_Area()</span> function, which returns the area of a Polygon or MultiPolygon object. If you’re working with a <span class="literal">geography</span> data type, <span class="literal">ST_Area()</span> returns the result in square meters. With a <span class="literal">geometry</span> data type, the function returns the area in SRID units. Typically, the units are not useful for practical analysis, but you can cast the <span class="literal">geometry</span> data to <span class="literal">geography</span> to obtain square meters. That’s what we’ll do here. This is a more intensive calculation than others we’ve done so far, so if you’re using an older computer, expect extra time for the query to complete.</p>
<p class="programs">SELECT name10,<br/>       statefp10 AS st,<br/>       round(<br/>             ( ST_Area(<span class="ent">➊</span>geom::geography) / <span class="ent">➋</span>2589988.110336 )::numeric, 2<br/>            )  AS <span class="ent">➌</span>square_miles<br/>FROM us_counties_2010_shp<br/>ORDER BY square_miles <span class="ent">➍</span>DESC<br/>LIMIT 5;</p>
<p class="listing" id="ch14list15"><em>Listing 14-15: Finding the largest counties by area using <span class="literal">ST_Area()</span></em></p>
<p class="indent">The <span class="literal">geom</span> column is data type <span class="literal">geometry</span>, so to find the area in square meters, we cast the <span class="literal">geom</span> column as a <span class="literal">geography</span> data type using the double-colon syntax <span class="ent">➊</span>. Then, to get square miles, we divide the area by 2589988.110336, which is the number of square meters in a square mile <span class="ent">➋</span>. To make the result easier to read, I’ve wrapped it in a <span class="literal">round()</span> <span epub:type="pagebreak" id="page_261"/>function and named the resulting column <span class="literal">square_miles</span> <span class="ent">➌</span>. Finally, we list the results in descending order from the largest area to the smallest <span class="ent">➍</span> and use <span class="literal">LIMIT 5</span> to show only the first five results, which should look like this:</p>
<p class="programs">name10              st    square_miles<br/>----------------    --    ------------<br/>Yukon-Koyukuk       02       147805.08<br/>North Slope         02        94796.21<br/>Bethel              02        45504.36<br/>Northwest Arctic    02        40748.95<br/>Valdez-Cordova      02        40340.08</p>
<p class="indent">The five counties with the largest areas are all in Alaska, denoted by the state FIPS code <span class="literal">02</span>. Yukon-Koyukuk, located in the heart of Alaska, is more than 147,800 square miles. (Keep that information in mind for the “Try It Yourself” exercise at the end of the chapter.)</p>
<h5 class="h5" id="lev261">Finding a County by Longitude and Latitude</h5>
<p class="noindent">If you’ve ever wondered how website ads seem to know where you live (“You won’t believe what this Boston man did with his old shoes!”), it’s thanks to <em>geolocation services</em> that use various means, such as your phone’s GPS, to find your longitude and latitude. Once your coordinates are known, they can be used in a spatial query to find which geography contains that point.</p>
<p class="indent">You can do the same using your census shapefile and the <span class="literal">ST_Within()</span> function, which returns <span class="literal">true</span> if one geometry is inside another. <a href="ch14.xhtml#ch14list16">Listing 14-16</a> shows an example using the longitude and latitude of downtown Hollywood:</p>
<p class="programs">SELECT name10,<br/>       statefp10<br/>FROM us_counties_2010_shp<br/>WHERE ST_Within('SRID=4269;POINT(-118.3419063 34.0977076)'::geometry, geom);</p>
<p class="listing" id="ch14list16"><em>Listing 14-16: Using <span class="literal">ST_Within()</span> to find the county belonging to a pair of coordinates</em></p>
<p class="indent">The <span class="literal">ST_Within()</span> function inside the <span class="literal">WHERE</span> clause requires two <span class="literal">geometry</span> inputs and checks whether the first is inside the second. For the function to work properly, both <span class="literal">geometry</span> inputs must have the same SRID. In this example, the first input is an extended WKT representation of a Point that includes the SRID <span class="literal">4269</span> (same as the census data), which is then cast as a <span class="literal">geometry</span> type. The <span class="literal">ST_Within()</span> function doesn’t accept a separate SRID input, so to set it for the supplied WKT, you must prefix it to the string like this: <span class="literal">'SRID=4269;POINT(-118.3419063 34.0977076)'</span>. The second input is the <span class="literal">geom</span> column from the table. Run the query; you should see the following result:</p>
<p class="programs">name10         statefp10<br/>-----------    ---------<br/>Los Angeles    06</p>
<p class="indent">The query shows that the Point you supplied is within Los Angeles county in California (state FIPS <span class="literal">06</span>). This information is very handy, <span epub:type="pagebreak" id="page_262"/>because by joining additional data to this table you can tell a person about demographics or points of interest near them. Try supplying other longitude and latitude pairs to see which U.S. county they fall in. If you provide coordinates outside the United States, the query should return no results because the shapefile only contains U.S. areas.</p>
<h3 class="h3" id="lev262">Performing Spatial Joins</h3>
<p class="noindent">In <a href="ch06.xhtml#ch06">Chapter 6</a>, you learned about SQL joins, which involved linking related tables via columns where values match or where an expression is true. You can perform joins using spatial data columns too, which opens up interesting opportunities for analysis. For example, you could join a table of coffee shops (which includes their longitude and latitude) to the counties table to find out how many shops exist in each county based on their location. Or, you can use a spatial join to append data from one table to another for analysis, again based on location. In this section, we’ll explore spatial joins with a detailed look at roads and waterways using census data.</p>
<h4 class="h4" id="lev263"><em>Exploring Roads and Waterways Data</em></h4>
<p class="noindent">Much of the year, the Santa Fe River, which cuts through the New Mexico state capital, is a dry riverbed better described as an <em>intermittent stream</em>. According to the Santa Fe city website, the river is susceptible to flash flooding and was named the nation’s most endangered river in 2007. If you were an urban planner, it would help to know where the river crosses roadways so you could plan for emergency response when it floods.</p>
<p class="indent">You can determine these locations using another set of U.S. Census TIGER/Line shapefiles, which has details on roads and waterways in Santa Fe County. These shapefiles are also included with the book’s resources. Download and unzip <em>tl_2016_35049_linearwater.zip</em> and <em>tl_2016_35049_roads.zip</em>, and then launch the Shapefile and DBF Loader Exporter. Following the same steps in <a href="ch14.xhtml#lev255">“Loading Shapefiles via the GUI Tool”</a> on <a href="ch14.xhtml#page_257">page 257</a>, import both shapefiles to <span class="literal">gis_analysis</span>. Name the water table <span class="literal">santafe_</span><span class="literal">linearwater_2016</span> and the roads table <span class="literal">santafe_roads_2016</span>.</p>
<p class="indent">Next, refresh your database and run a quick <span class="literal">SELECT * FROM</span> query on both tables to view the data. You should have 12,926 rows in the roads table and 1,198 in the linear water table.</p>
<p class="indent">As with the counties shapefile you imported via the loader GUI, both tables have an indexed <span class="literal">geom</span> column of type <span class="literal">geometry</span>. It’s helpful to check the type of spatial object in the column so you know the type of spatial feature you’re querying. You can do that using the <span class="literal">ST_AsText()</span> function you learned in <a href="ch14.xhtml#ch14list14">Listing 14-14</a> or using <span class="literal">ST_GeometryType()</span>, as shown in <a href="ch14.xhtml#ch14list17">Listing 14-17</a>:</p>
<p class="programs">SELECT ST_GeometryType(geom)<br/>FROM santafe_linearwater_2016<br/>LIMIT 1;<br/><br/><span epub:type="pagebreak" id="page_263"/>SELECT ST_GeometryType(geom)<br/>FROM santafe_roads_2016<br/>LIMIT 1;</p>
<p class="listing" id="ch14list17"><em>Listing 14-17: Using <span class="literal">ST_GeometryType()</span> to determine geometry</em></p>
<p class="indent">Both queries should return one row with the same value: <span class="literal">ST_MultiLineString</span>. That value indicates that waterways and roads are stored as MultiLineString objects, which are a series of points connected by straight lines.</p>
<h4 class="h4" id="lev264"><em>Joining the Census Roads and Water Tables</em></h4>
<p class="noindent">To find all the roads in Santa Fe that cross the Santa Fe River, we’ll join the tables using the <span class="literal">JOIN ... ON</span> syntax you learned in <a href="ch06.xhtml#ch06">Chapter 6</a>. Rather than looking for values that match in columns in both tables as usual, we’ll write a query that tells us where objects overlap. We’ll do this using the <span class="literal">ST_Intersects()</span> function, which returns a Boolean <span class="literal">true</span> if two spatial objects contact each other. Inputs can be either <span class="literal">geometry</span> or <span class="literal">geography</span> types. <a href="ch14.xhtml#ch14list18">Listing 14-18</a> joins the tables:</p>
<p class="programs"><span class="ent">➊</span> SELECT water.fullname AS waterway,<br/>         roads.rttyp,<br/>         roads.fullname AS road<br/><span class="ent">➋</span> FROM santafe_linearwater_2016 water JOIN santafe_roads_2016 roads<br/>     <span class="ent">➌</span> ON ST_Intersects(water.geom, roads.geom)<br/>  WHERE water.fullname = <span class="ent">➍</span>'Santa Fe Riv'<br/>  ORDER BY roads.fullname;</p>
<p class="listing" id="ch14list18"><em>Listing 14-18: Spatial join with <span class="literal">ST_Intersects()</span> to find roads crossing the Santa Fe River</em></p>
<p class="indent">The <span class="literal">SELECT</span> column list <span class="ent">➊</span> includes the <span class="literal">fullname</span> column from the <span class="literal">santafe_linearwater_2016</span> table, which gets <span class="literal">water</span> as its alias in the <span class="literal">FROM</span> <span class="ent">➋</span> clause. The column list includes the <span class="literal">rttyp</span> code, which represents the route type, and <span class="literal">fullname</span> columns from the <span class="literal">santafe_roads_2016</span> table, aliased as <span class="literal">roads</span>.</p>
<p class="indent">In the <span class="literal">ON</span> portion <span class="ent">➌</span> of the <span class="literal">JOIN</span> clause, we use the <span class="literal">ST_Intersects()</span> function with the <span class="literal">geom</span> columns from both tables as inputs. This is an example of using the <span class="literal">ON</span> clause with an expression that evaluates to a Boolean result, as noted in <a href="ch06.xhtml#lev81">“Linking Tables Using <span class="literal">JOIN</span>”</a> on <a href="ch06.xhtml#page_74">page 74</a>. Then we use <span class="literal">fullname</span> to filter the results to show only those that have the full string <span class="literal">'Santa Fe Riv'</span> <span class="ent">➍</span>, which is how the Santa Fe River is listed in the water table. The query should return 54 rows; here are the first five:</p>
<p class="programs">waterway        rttyp    road<br/>------------    -----    ----------------<br/>Santa Fe Riv    M        Baca Ranch Ln<br/>Santa Fe Riv    M        Cam Alire<br/>Santa Fe Riv    M        Cam Carlos Rael<br/>Santa Fe Riv    M        Cam Dos Antonios<br/>Santa Fe Riv    M        Cerro Gordo Rd<br/><em>--snip--</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_264"/>Each road in the results intersects with a portion of the Santa Fe River. The route type code for each of the first results is <span class="literal">M</span>, which indicates that the road name shown is its <em>common</em> name as opposed to a county or state recognized name, for example. Other road names in the complete results carry route types of <span class="literal">C</span>, <span class="literal">S</span>, or <span class="literal">U</span> (for unknown). The full route type code list is available at <em><a href="https://www.census.gov/geo/reference/rttyp.html">https://www.census.gov/geo/reference/rttyp.html</a></em>.</p>
<h4 class="h4" id="lev265"><em>Finding the Location Where Objects Intersect</em></h4>
<p class="noindent">We successfully identified all the roads that intersect the Santa Fe River. This is a good start, but it would help our survey of flood-danger areas more to know precisely where each intersection occurs. We can modify the query to include the <span class="literal">ST_Intersection()</span> function, which returns the location of the place where objects cross. I’ve added it as a column in <a href="ch14.xhtml#ch14list19">Listing 14-19</a>:</p>
<p class="programs">SELECT water.fullname AS waterway,<br/>       roads.rttyp,<br/>       roads.fullname AS road,<br/>      <span class="ent">➊</span>ST_AsText(ST_Intersection(<span class="ent">➋</span>water.geom, roads.geom))<br/>FROM santafe_linearwater_2016 water JOIN santafe_roads_2016 roads<br/>    ON ST_Intersects(water.geom, roads.geom)<br/>WHERE water.fullname = 'Santa Fe Riv'<br/>ORDER BY roads.fullname;</p>
<p class="listing" id="ch14list19"><em>Listing 14-19: Using <span class="literal">ST_Intersection()</span> to show where roads cross the river</em></p>
<p class="indent">The function returns a geometry object, so to get its WKT representation, we must wrap it in <span class="literal">ST_AsText()</span> <span class="ent">➊</span>. The <span class="literal">ST_Intersection()</span> function takes two inputs: the <span class="literal">geom</span> columns <span class="ent">➋</span> from both the <span class="literal">water</span> and <span class="literal">roads</span> tables. Run the query, and the results should now include the exact coordinate location, or locations, where the river crosses the roads:</p>
<div class="image"><img alt="image" src="../images/prog_page_264.jpg"/></div>
<p class="indent">You can probably think of more ideas for analyzing spatial data. For example, if you obtained a shapefile showing buildings, you could find those close to the river and in danger of flooding during heavy rains. Governments and private organizations regularly use these techniques as part of their planning process.</p>
<h4 class="h4" id="lev266"><span epub:type="pagebreak" id="page_265"/>Wrapping Up</h4>
<p class="noindent">Mapping features is a powerful analysis tool, and the techniques you learned in this chapter provide you with a strong start toward exploring more with PostGIS. You might also want to look at the open source mapping application QGIS (<em><a href="http://www.qgis.org/">http://www.qgis.org/</a></em>), which provides tools for visualizing geographic data and working in depth with shapefiles. QGIS also works quite well with PostGIS, letting you add data from your tables directly onto a map.</p>
<p class="indent">You’ve now added working with geographic data to your analysis skills. In the remaining chapters, I’ll give you additional tools and tips for working with PostgreSQL and related tools to continue to increase your skills.</p>
<div class="sidebar" id="ch14sb1">
<p class="sidebart"><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Use the spatial data you’ve imported in this chapter to try additional analysis:</p>
<ol>
<li class="noindent"><p class="list">Earlier, you found which U.S. county has the largest area. Now, aggregate the county data to find the area of each state in square miles. (Use the <span class="literal">statefp10</span> column in the <span class="literal">us_counties_2010_shp</span> table.) How many states are bigger than the Yukon-Koyukuk area?</p></li>
<li class="noindent"><p class="list">Using <span class="literal">ST_Distance()</span>, determine how many miles separate these two farmers’ markets: the Oakleaf Greenmarket (9700 Argyle Forest Blvd, Jacksonville, Florida) and Columbia Farmers Market (1701 West Ash Street, Columbia, Missouri). You’ll need to first find the coordinates for both in the <span class="literal">farmers_markets</span> table. (Hint: You can also write this query using the Common Table Expression syntax you learned in <a href="ch12.xhtml#ch12">Chapter 12</a>.)</p></li>
<li class="noindent"><p class="list">More than 500 rows in the <span class="literal">farmers_markets</span> table are missing a value in the <span class="literal">county</span> column, which is an example of dirty government data. Using the <span class="literal">us_counties_2010_shp</span> table and the <span class="literal">ST_Intersects()</span> function, perform a spatial join to find the missing county names based on the longitude and latitude of each market. Because <span class="literal">geog_point</span> in <span class="literal">farmers_marke</span><span class="literal">ts</span> is of the <span class="literal">geography</span> type and its SRID is <span class="literal">4326</span>, you’ll need to cast <span class="literal">geom</span> in the census table to the <span class="literal">geography</span> type and change its SRID using <span class="literal">ST_SetSRID()</span>.<span epub:type="pagebreak" id="page_266"/></p></li>
</ol>
</div>
</body>
</html>