<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_129"/><strong><span class="big">9</span></strong><br/><strong>INSPECTING AND MODIFYING DATA</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">If you asked me to propose a toast to a newly minted class of data analysts, I’d probably raise my glass and say, “May your data always be free of errors and may it always arrive perfectly structured!” Life would be ideal if these sentiments were feasible. In reality, you’ll sometimes receive data in such a sorry state that it’s hard to analyze without modifying it in some way. This is called <em>dirty data</em>, which is a general label for data with errors, missing values, or poor organization that makes standard queries ineffective. When data is converted from one file type to another or when a column receives the wrong data type, information can be lost. Typos and spelling inconsistencies can also result in dirty data. Whatever the cause may be, dirty data is the bane of the data analyst.</p>
<p class="indent">In this chapter, you’ll use SQL to clean up dirty data as well as perform other useful maintenance tasks. You’ll learn how to examine data to assess its quality and how to modify data and tables to make analysis easier. But the techniques you’ll learn will be useful for more than just cleaning data. <span epub:type="pagebreak" id="page_130"/>The ability to make changes to data and tables gives you options for updating or adding new information to your database as it becomes available, elevating your database from a static collection to a living record.</p>
<p class="indent">Let’s begin by importing our data.</p>
<h3 class="h3" id="lev135">Importing Data on Meat, Poultry, and Egg Producers</h3>
<p class="noindent">For this example, we’ll use a directory of U.S. meat, poultry, and egg producers. The Food Safety and Inspection Service (FSIS), an agency within the U.S. Department of Agriculture, compiles and updates this database every month. The FSIS is responsible for inspecting animals and food at more than 6,000 meat processing plants, slaughterhouses, farms, and the like. If inspectors find a problem, such as bacterial contamination or mislabeled food, the agency can issue a recall. Anyone interested in agriculture business, food supply chain, or outbreaks of foodborne illnesses will find the directory useful. Read more about the agency on its site at <em><a href="https://www.fsis.usda.gov/">https://www.fsis.usda.gov/</a></em>.</p>
<p class="indent">The file we’ll use comes from the directory’s page on <em><a href="https://www.data.gov/">https://www.data.gov/</a></em>, a website run by the U.S. federal government that catalogs thousands of data sets from various federal agencies (<em><a href="https://catalog.data.gov/dataset/meat-poultry-and-egg-inspection-directory-by-establishment-name/">https://catalog.data.gov/dataset/meat-poultry-and-egg-inspection-directory-by-establishment-name/</a></em>). We’ll examine the original data as it was available for download, with the exception of the ZIP Codes column (I’ll explain why later). You’ll find the data in the file <em>MPI_Directory_by_Establishment_Name.csv</em> along with other resources for this book at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>.</p>
<p class="indent">To import the file into PostgreSQL, use the code in <a href="ch09.xhtml#ch09list1">Listing 9-1</a> to create a table called <span class="literal">meat_poultry_egg_inspect</span> and use <span class="literal">COPY</span> to add the CSV file to the table. As in previous examples, use pgAdmin to connect to your <span class="literal">analysis</span> database, and then open the Query Tool to run the code. Remember to change the path in the <span class="literal">COPY</span> statement to reflect the location of your CSV file.</p>
<p class="programs">  CREATE TABLE meat_poultry_egg_inspect (<br/>    <span class="ent">➊</span> est_number varchar(50) CONSTRAINT est_number_key PRIMARY KEY,<br/>      company varchar(100),<br/>      street varchar(100),<br/>      city varchar(30),<br/>      st varchar(2),<br/>      zip varchar(5),<br/>      phone varchar(14),<br/>      grant_date date,<br/>    <span class="ent">➋</span> activities text,<br/>      dbas text<br/>  );<br/><br/><span class="ent">➌</span> COPY meat_poultry_egg_inspect<br/>  FROM '<em>C:\YourDirectory\</em>MPI_Directory_by_Establishment_Name.csv'<br/>  WITH (FORMAT CSV, HEADER, DELIMITER ',');<br/><br/>  <span class="ent">➍</span> CREATE INDEX company_idx ON meat_poultry_egg_inspect (company);</p>
<p class="listing" id="ch09list1"><em>Listing 9-1: Importing the FSIS Meat, Poultry, and Egg Inspection Directory</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_131"/>The <span class="literal">meat_poultry_egg_inspect</span> table has 10 columns. We add a natural primary key constraint to the <span class="literal">est_number</span> column <span class="ent">➊</span>, which contains a unique value for each row that identifies the establishment. Most of the remaining columns relate to the company’s name and location. You’ll use the <span class="literal">activities</span> column <span class="ent">➋</span>, which describes activities at the company, in the “Try It Yourself” exercise at the end of this chapter. We set the <span class="literal">activities</span> and <span class="literal">dbas</span> columns to <span class="literal">text</span>, a data type that in PostgreSQL affords us up to 1GB of characters, because some of the strings in the columns are thousands of characters long. We import the CSV file <span class="ent">➌</span> and then create an index on the <span class="literal">company</span> column <span class="ent">➍</span> to speed up searches for particular companies.</p>
<p class="indent">For practice, let’s use the <span class="literal">count()</span> aggregate function introduced in <a href="ch08.xhtml#ch08">Chapter 8</a> to check how many rows are in the <span class="literal">meat_poultry_egg_inspect</span> table:</p>
<p class="programs">SELECT count(*) FROM meat_poultry_egg_inspect;</p>
<p class="indent">The result should show 6,287 rows. Now let’s find out what the data contains and determine whether we can glean useful information from it as is, or if we need to modify it in some way.</p>
<h3 class="h3" id="lev136">Interviewing the Data Set</h3>
<p class="noindent">Interviewing data is my favorite part of analysis. We interview a data set to discover its details: what it holds, what questions it can answer, and how suitable it is for our purposes, the same way a job interview reveals whether a candidate has the skills required for the position.</p>
<p class="indent">The aggregate queries you learned in <a href="ch08.xhtml#ch08">Chapter 8</a> are a useful interviewing tool because they often expose the limitations of a data set or raise questions you may want to ask before drawing conclusions in your analysis and assuming the validity of your findings.</p>
<p class="indent">For example, the <span class="literal">meat_poultry_egg_inspect</span> table’s rows describe food producers. At first glance, we might assume that each company in each row operates at a distinct address. But it’s never safe to assume in data analysis, so let’s check using the code in <a href="ch09.xhtml#ch09list2">Listing 9-2</a>:</p>
<p class="programs">SELECT company,<br/>       street,<br/>       city,<br/>       st,<br/>       count(*) AS address_count<br/>FROM meat_poultry_egg_inspect<br/>GROUP BY company, street, city, st<br/>HAVING count(*) &gt; 1<br/>ORDER BY company, street, city, st;</p>
<p class="listing" id="ch09list2"><em>Listing 9-2: Finding multiple companies at the same address</em></p>
<p class="indent">Here, we group companies by unique combinations of the <span class="literal">company</span>, <span class="literal">street</span>, <span class="literal">city</span>, and <span class="literal">st</span> columns. Then we use <span class="literal">count(*)</span>, which returns the <span epub:type="pagebreak" id="page_132"/>number of rows for each combination of those columns and gives it the alias <span class="literal">address_count</span>. Using the <span class="literal">HAVING</span> clause introduced in <a href="ch08.xhtml#ch08">Chapter 8</a>, we filter the results to show only cases where more than one row has the same combination of values. This should return all duplicate addresses for a company.</p>
<p class="indent">The query returns 23 rows, which means there are close to two dozen cases where the same company is listed multiple times at the same address:</p>
<div class="image"><img alt="image" src="../images/prog_page_132.jpg"/></div>
<p class="indent">This is not necessarily a problem. There may be valid reasons for a company to appear multiple times at the same address. For example, two types of processing plants could exist with the same name. On the other hand, we may have found data entry errors. Either way, it’s sound practice to eliminate concerns about the validity of a data set before relying on it, and the result should prompt us to investigate individual cases before we draw conclusions. However, this data set has other issues that we need to look at before we can get meaningful information from it. Let’s work through a few examples.</p>
<h4 class="h4" id="lev137"><em>Checking for Missing Values</em></h4>
<p class="noindent">Let’s start checking for missing values by asking a basic question: how many of the meat, poultry, and egg processing companies are in each state? Finding out whether we have values from all states and whether any rows are missing a state code will serve as another useful check on the data. We’ll use the aggregate function <span class="literal">count()</span> along with <span class="literal">GROUP BY</span> to determine this, as shown in <a href="ch09.xhtml#ch09list3">Listing 9-3</a>:</p>
<p class="programs">SELECT st,<br/>       count(*) AS st_count<br/>FROM meat_poultry_egg_inspect<br/>GROUP BY st<br/>ORDER BY st;</p>
<p class="listing" id="ch09list3"><em>Listing 9-3: Grouping and counting states</em></p>
<p class="indent">The query is a simple count similar to the examples in <a href="ch08.xhtml#ch08">Chapter 8</a>. When you run the query, it tallies the number of times each state postal code (<span class="literal">st</span>) appears in the table. Your result should include 57 rows, grouped by the state postal code in the column <span class="literal">st</span>. Why more than the 50 U.S. states? Because the data includes Puerto Rico and other unincorporated U.S. territories, such as <span epub:type="pagebreak" id="page_133"/>Guam and American Samoa. Alaska (<span class="literal">AK</span>) is at the top of the results with a count of <span class="literal">17</span> establishments:</p>
<p class="programs">st    st_count<br/>--    --------<br/>AK          17<br/>AL          93<br/>AR          87<br/>AS           1<br/><em>--snip--</em><br/>WA         139<br/>WI         184<br/>WV          23<br/>WY           1<br/>             3</p>
<p class="indent">However, the row at the bottom of the list has a count of <span class="literal">3</span> and a <span class="literal">NULL</span> value in the <span class="literal">st_count</span> column. To find out what this means, let’s query the rows where the <span class="literal">st</span> column has <span class="literal">NULL</span> values.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Depending on the database implementation, <span class="literal">NULL</span> values will either appear first or last in a sorted column. In PostgreSQL, they appear last by default. The ANSI SQL standard doesn’t specify one or the other, but it lets you add <span class="literal">NULLS FIRST</span> or <span class="literal">NULLS LAST</span> to an <span class="literal">ORDER BY</span> clause to specify a preference. For example, to make <span class="literal">NULL</span> values appear first in the preceding query, the clause would read <span class="literal">ORDER BY st NULLS FIRST</span>.</em></p>
</div>
<p class="indent">In <a href="ch09.xhtml#ch09list4">Listing 9-4</a>, we use the technique covered in “Using <span class="literal">NULL</span> to Find Rows with Missing Values” on <a href="ch06.xhtml#page_83">page 83</a>, adding a <span class="literal">WHERE</span> clause with the <span class="literal">st</span> column and the <span class="literal">IS NULL</span> keywords to find which rows are missing a state code:</p>
<p class="programs">SELECT est_number,<br/>       company,<br/>       city,<br/>       st,<br/>       zip<br/>FROM meat_poultry_egg_inspect<br/>WHERE st IS NULL;</p>
<p class="listing" id="ch09list4"><em>Listing 9-4: Using <span class="literal">IS NULL</span> to find missing values in the <span class="literal">st</span> column</em></p>
<p class="indent">This query returns three rows that don’t have a value in the <span class="literal">st</span> column:</p>
<div class="image"><img alt="image" src="../images/prog_page_133.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_134"/>If we want an accurate count of establishments per state, these missing values would lead to an incorrect result. To find the source of this dirty data, it’s worth making a quick visual check of the original file downloaded from <em><a href="https://www.data.gov/">https://www.data.gov/</a></em>. Unless you’re working with files in the gigabyte range, you can usually open a CSV file in a text editor and search for the row. If you’re working with larger files, you might be able to examine the source data using utilities such as <span class="literal">grep</span> (on Linux and macOS) or <span class="literal">findstr</span> (on Windows). In this case, a visual check confirms that, indeed, there was no state listed in those rows in the CSV file, so the error is organic to the data, not one introduced during import.</p>
<p class="indent">In our interview of the data so far, we’ve discovered that we’ll need to add missing values to the <span class="literal">st</span> column to clean up this table. Let’s look at what other issues exist in our data set and make a list of cleanup tasks.</p>
<h4 class="h4" id="lev138"><em>Checking for Inconsistent Data Values</em></h4>
<p class="noindent">Inconsistent data is another factor that can hamper our analysis. We can check for inconsistently entered data within a column by using <span class="literal">GROUP BY</span> with <span class="literal">count()</span>. When you scan the unduplicated values in the results, you might be able to spot variations in the spelling of names or other attributes.</p>
<p class="indent">For example, many of the 6,200 companies in our table are multiple locations owned by a few multinational food corporations, such as Cargill or Tyson Foods. To find out how many locations each company owns, we would try to count the values in the <span class="literal">company</span> column. Let’s see what happens when we do, using the query in <a href="ch09.xhtml#ch09list5">Listing 9-5</a>:</p>
<p class="programs">SELECT company,<br/>       count(*) AS company_count<br/>FROM meat_poultry_egg_inspect<br/>GROUP BY company<br/>ORDER BY company ASC;</p>
<p class="listing" id="ch09list5"><em>Listing 9-5: Using <span class="literal">GROUP BY</span> and <span class="literal">count()</span> to find inconsistent company names</em></p>
<p class="indent">Scrolling through the results reveals a number of cases in which a company’s name is spelled several different ways. For example, notice the entries for the Armour-Eckrich brand:</p>
<p class="programs">company                        company_count<br/>---------------------------    -------------<br/><em>--snip--</em><br/>Armour - Eckrich Meats, LLC                1<br/>Armour-Eckrich Meats LLC                   3<br/>Armour-Eckrich Meats, Inc.                 1<br/>Armour-Eckrich Meats, LLC                  2<br/><em>--snip--</em></p>
<p class="indent">At least four different spellings are shown for seven establishments that are likely owned by the same company. If we later perform any aggregation by company, it would help to standardize the names so all of the items counted or summed are grouped properly. Let’s add that to our list of items to fix.</p>
<h4 class="h4" id="lev139"><span epub:type="pagebreak" id="page_135"/><em>Checking for Malformed Values Using length()</em></h4>
<p class="noindent">It’s a good idea to check for unexpected values in a column that should be consistently formatted. For example, each entry in the <span class="literal">zip</span> column in the <span class="literal">meat_poultry_egg_inspect</span> table should be formatted in the style of U.S. ZIP Codes with five digits. However, that’s not what is in our data set.</p>
<p class="indent">Solely for the purpose of this example, I replicated an error I’ve committed before. When I converted the original Excel file to a CSV file, I stored the ZIP Code in the “General” number format in the spreadsheet instead of as a text value. By doing so, any ZIP Code that begins with a zero, such as 07502 for Paterson, NJ, lost the leading zero because an integer can’t start with a zero. As a result, 07502 appears in the table as <span class="literal">7502</span>. You can make this error in a variety of ways, including by copying and pasting data into Excel columns set to “General.” After being burned a few times, I learned to take extra caution with numbers that should be formatted as text.</p>
<p class="indent">My deliberate error appears when we run the code in <a href="ch09.xhtml#ch09list6">Listing 9-6</a>. The example introduces <span class="literal">length()</span>, a <em>string function</em> that counts the number of characters in a string. We combine <span class="literal">length()</span> with <span class="literal">count()</span> and <span class="literal">GROUP BY</span> to determine how many rows have five characters in the <span class="literal">zip</span> field and how many have a value other than five. To make it easy to scan the results, we use <span class="literal">length()</span> in the <span class="literal">ORDER BY</span> clause.</p>
<p class="programs">SELECT length(zip),<br/>       count(*) AS length_count<br/>FROM meat_poultry_egg_inspect<br/>GROUP BY length(zip)<br/>ORDER BY length(zip) ASC;</p>
<p class="listing" id="ch09list6"><em>Listing 9-6: Using <span class="literal">length()</span> and <span class="literal">count()</span> to test the <span class="literal">zip</span> column</em></p>
<p class="indent">The results confirm the formatting error. As you can see, <span class="literal">496</span> of the ZIP Codes are four characters long, and <span class="literal">86</span> are three characters long, which means these numbers originally had two leading zeros that my conversion erroneously eliminated:</p>
<p class="programs">length    length_count<br/>------    ------------<br/>     3              86<br/>     4             496<br/>     5            5705</p>
<p class="indent">Using the <span class="literal">WHERE</span> clause, we can check the details of the results to see which states these shortened ZIP Codes correspond to, as shown in <a href="ch09.xhtml#ch09list7">Listing 9-7</a>:</p>
<p class="programs">  SELECT st,<br/>         count(*) AS st_count<br/>  FROM meat_poultry_egg_inspect<br/><span class="ent">➊</span> WHERE length(zip) &lt; 5<br/><span epub:type="pagebreak" id="page_136"/>  GROUP BY st<br/>  ORDER BY st ASC;</p>
<p class="listing" id="ch09list7"><em>Listing 9-7: Filtering with <span class="literal">length()</span> to find short <span class="literal">zip</span> values</em></p>
<p class="indent">The <span class="literal">length()</span> function inside the <span class="literal">WHERE</span> clause <span class="ent">➊</span> returns a count of rows where the ZIP Code is less than five characters for each state code. The result is what we would expect. The states are largely in the Northeast region of the United States where ZIP Codes often start with a zero:</p>
<p class="programs">st    st_count<br/>--    --------<br/>CT          55<br/>MA         101<br/>ME          24<br/>NH          18<br/>NJ         244<br/>PR          84<br/>RI          27<br/>VI           2<br/>VT          27</p>
<p class="indent">Obviously, we don’t want this error to persist, so we’ll add it to our list of items to correct. So far, we need to correct the following issues in our data set:</p>
<ul>
<li class="noindent">Missing values for three rows in the <span class="literal">st</span> column</li>
<li class="noindent">Inconsistent spelling of at least one company’s name</li>
<li class="noindent">Inaccurate ZIP Codes due to file conversion</li>
</ul>
<p class="indent">Next, we’ll look at how to use SQL to fix these issues by modifying your data.</p>
<h3 class="h3" id="lev140">Modifying Tables, Columns, and Data</h3>
<p class="noindent">Almost nothing in a database, from tables to columns and the data types and values they contain, is set in concrete after it’s created. As your needs change, you can add columns to a table, change data types on existing columns, and edit values. Fortunately, you can use SQL to modify, delete, or add to existing data and structures. Given the issues we discovered in the <span class="literal">meat_poultry_egg</span><span class="literal">_inspect</span> table, being able to modify our database will come in handy.</p>
<p class="indent">To make changes to our database, we’ll use two SQL commands: the first command, <span class="literal">ALTER TABLE</span>, is part of the ANSI SQL standard and provides options to <span class="literal">ADD COLUMN</span>, <span class="literal">ALTER COLUMN</span>, and <span class="literal">DROP COLUMN</span>, among others. Typically, PostgreSQL and other databases include implementation-specific extensions to <span class="literal">ALTER</span> <span class="literal">TABLE</span> that provide an array of options for managing database objects (see <em><a href="https://www.postgresql.org/docs/current/static/sql-altertable.html">https://www.postgresql.org/docs/current/static/sql-altertable.html</a></em>). For our exercises, we’ll stick with the core options.</p>
<p class="indent">The second command, <span class="literal">UPDATE</span>, also included in the SQL standard, allows you to change values in a table’s columns. You can supply criteria using the <span class="literal">WHERE</span> clause to choose which rows to update.</p>
<p class="indent"><span epub:type="pagebreak" id="page_137"/>Let’s explore the basic syntax and options for both commands, and then use them to fix the issues in our data set.</p>
<div class="sidebar">
<p class="sidebart"><strong>WHEN TO TOSS YOUR DATA</strong></p>
<p class="spara">If your interview of the data reveals too many missing values or values that defy common sense—such as numbers ranging in the billions when you expected thousands—it’s time to reevaluate its use. The data may not be reliable enough to serve as the foundation of your analysis.</p>
<p class="spara1">If you suspect as much, the first step is to revisit the original data file. Make sure you imported it correctly and that values in all the source columns are located in the same columns in the table. You might need to open the original spreadsheet or CSV file and do a visual comparison. The second step is to call the agency or company that produced the data to confirm what you see and seek an explanation. You might also ask for advice from others who have used the same data.</p>
<p class="spara1">More than once I’ve had to toss a data set after determining that it was poorly assembled or simply incomplete. Sometimes, the amount of work required to make a data set usable undermines its usefulness. These situations require you to make a tough judgment call. But it’s better to start over or find an alternative than to use bad data that can lead to faulty conclusions.</p>
</div>
<h4 class="h4" id="lev141"><em>Modifying Tables with ALTER TABLE</em></h4>
<p class="noindent">We can use the <span class="literal">ALTER TABLE</span> statement to modify the structure of tables. The following examples show the syntax for common operations that are part of standard ANSI SQL. The code for adding a column to a table looks like this:</p>
<p class="programs">ALTER TABLE <em>table</em> ADD COLUMN <em>column data_type</em>;</p>
<p class="indent">Similarly, we can remove a column with the following syntax:</p>
<p class="programs">ALTER TABLE <em>table</em> DROP COLUMN <em>column</em>;</p>
<p class="indent">To change the data type of a column, we would use this code:</p>
<p class="programs">ALTER TABLE <em>table</em> ALTER COLUMN <em>column</em> SET DATA TYPE <em>data_type</em>;</p>
<p class="indent">Adding a <span class="literal">NOT NULL</span> constraint to a column will look like the following:</p>
<p class="programs">ALTER TABLE <em>table</em> ALTER COLUMN <em>column</em> SET NOT NULL;</p>
<p class="indent">Note that in PostgreSQL and some other systems, adding a constraint to the table causes all rows to be checked to see whether they comply with the constraint. If the table has millions of rows, this could take a while.</p>
<p class="indent"><span epub:type="pagebreak" id="page_138"/>Removing the <span class="literal">NOT NULL</span> constraint looks like this:</p>
<p class="programs">ALTER TABLE <em>table</em> ALTER COLUMN <em>column</em> DROP NOT NULL;</p>
<p class="indent">When you execute an <span class="literal">ALTER TABLE</span> statement with the placeholders filled in, you should see a message that reads <span class="literal">ALTER TABLE</span> in the pgAdmin output screen. If an operation violates a constraint or if you attempt to change a column’s data type and the existing values in the column won’t conform to the new data type, PostgreSQL returns an error. But PostgreSQL won’t give you any warning about deleting data when you drop a column, so use extra caution before dropping a column.</p>
<h4 class="h4" id="lev142"><em>Modifying Values with UPDATE</em></h4>
<p class="noindent">The <span class="literal">UPDATE</span> statement modifies the data in a column in all rows or in a subset of rows that meet a condition. Its basic syntax, which would update the data in every row in a column, follows this form:</p>
<p class="programs">UPDATE <em>table</em><br/>SET <em>column</em> = <em>value</em>;</p>
<p class="indent">We first pass <span class="literal">UPDATE</span> the name of the table to update, and then pass the <span class="literal">SET</span> clause the column that contains the values to change. The new <span class="codeitalic">value</span> to place in the column can be a string, number, the name of another column, or even a query or expression that generates a value. We can update values in multiple columns at a time by adding additional columns and source values, and separating each column and value statement with a comma:</p>
<p class="programs">UPDATE <em>table</em><br/>SET <em>column_a</em> = <em>value</em>,<br/>    <em>column_b</em> = <em>value</em>;</p>
<p class="indent">To restrict the update to particular rows, we add a <span class="literal">WHERE</span> clause with some criteria that must be met before the update can happen:</p>
<p class="programs">UPDATE <em>table</em><br/>SET <em>column</em> = <em>value</em><br/>WHERE <em>criteria</em>;</p>
<p class="indent">We can also update one table with values from another table. Standard ANSI SQL requires that we use a <em>subquery</em>, a query inside a query, to specify which values and rows to update:</p>
<p class="programs">UPDATE <em>table</em><br/>SET <em>column</em> = (SELECT <em>column</em><br/>              FROM <em>table_b</em><br/>              WHERE <em>table.column</em> = <em>table_b.column</em>)<br/>WHERE EXISTS (SELECT <em>column</em><br/>              FROM <em>table_b</em><br/>              WHERE <em>table.column</em> = <em>table_b.column</em>);</p>
<p class="indent"><span epub:type="pagebreak" id="page_139"/>The value portion of the <span class="literal">SET</span> clause is a subquery, which is a <span class="literal">SELECT</span> statement inside parentheses that generates the values for the update. Similarly, the <span class="literal">WHERE EXISTS</span> clause uses a <span class="literal">SELECT</span> statement to generate values that serve as the filter for the update. If we didn’t use this clause, we might inadvertently set some values to <span class="literal">NULL</span> without planning to. (If this syntax looks somewhat complicated, that’s okay. I’ll cover subqueries in detail in <a href="ch12.xhtml#ch12">Chapter 12</a>.)</p>
<p class="indent">Some database managers offer additional syntax for updating across tables. PostgreSQL supports the ANSI standard but also a simpler syntax using a <span class="literal">FROM</span> clause for updating values across tables:</p>
<p class="programs">UPDATE <em>table</em><br/>SET <em>column</em> = <em>table_b.column</em><br/>FROM <em>table_b</em><br/>WHERE <em>table.column = table_b.column</em>;</p>
<p class="indent">When you execute an <span class="literal">UPDATE</span> statement, PostgreSQL returns a message stating <span class="literal">UPDATE</span> along with the number of rows affected.</p>
<h4 class="h4" id="lev143"><em>Creating Backup Tables</em></h4>
<p class="noindent">Before modifying a table, it’s a good idea to make a copy for reference and backup in case you accidentally destroy some data. <a href="ch09.xhtml#ch09list8">Listing 9-8</a> shows how to use a variation of the familiar <span class="literal">CREATE TABLE</span> statement to make a new table based on the existing data and structure of the table we want to duplicate:</p>
<p class="programs">CREATE TABLE meat_poultry_egg_inspect_backup AS<br/>SELECT * FROM meat_poultry_egg_inspect;</p>
<p class="listing" id="ch09list8"><em>Listing 9-8: Backing up a table</em></p>
<p class="indent">After running the <span class="literal">CREATE TABLE</span> statement, the result should be a pristine copy of your table with the new specified name. You can confirm this by counting the number of records in both tables with one query:</p>
<p class="programs">SELECT<br/>    (SELECT count(*) FROM meat_poultry_egg_inspect) AS original,<br/>    (SELECT count(*) FROM meat_poultry_egg_inspect_backup) AS backup;</p>
<p class="indent">The results should return a count of 6,287 from both tables, like this:</p>
<p class="programs">original    backup<br/>--------    ------<br/>    6287      6287</p>
<p class="indent">If the counts match, you can be sure your backup table is an exact copy of the structure and contents of the original table. As an added measure and for easy reference, we’ll use <span class="literal">ALTER TABLE</span> to make copies of column data within the table we’re updating.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_140"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Indexes are not copied when creating a table backup using the <span class="literal">CREATE TABLE</span> statement. If you decide to run queries on the backup, be sure to create a separate index on that table.</em></p>
</div>
<h4 class="h4" id="lev144"><em>Restoring Missing Column Values</em></h4>
<p class="noindent">Earlier in this chapter, the query in <a href="ch09.xhtml#ch09list4">Listing 9-4</a> revealed that three rows in the <span class="literal">meat_poultry_egg_inspect</span> table don’t have a value in the <span class="literal">st</span> column:</p>
<div class="image"><img alt="image" src="../images/prog_page_140.jpg"/></div>
<p class="indent">To get a complete count of establishments in each state, we need to fill those missing values using an <span class="literal">UPDATE</span> statement.</p>
<h5 class="h5" id="lev145">Creating a Column Copy</h5>
<p class="noindent">Even though we’ve backed up this table, let’s take extra caution and make a copy of the <span class="literal">st</span> column within the table so we still have the original data if we make some dire error somewhere! Let’s create the copy and fill it with the existing <span class="literal">st</span> column values using the SQL statements in <a href="ch09.xhtml#ch09list9">Listing 9-9</a>:</p>
<p class="programs"><span class="ent">➊</span> ALTER TABLE meat_poultry_egg_inspect ADD COLUMN st_copy varchar(2);<br/><br/>  UPDATE meat_poultry_egg_inspect<br/><span class="ent">➋</span> SET st_copy = st;</p>
<p class="listing" id="ch09list9"><em>Listing 9-9: Creating and filling the <span class="literal">st_copy</span> column with <span class="literal">ALTER TABLE</span> and <span class="literal">UPDATE</span></em></p>
<p class="indent">The <span class="literal">ALTER TABLE</span> statement <span class="ent">➊</span> adds a column called <span class="literal">st_copy</span> using the same <span class="literal">varchar</span> data type as the original <span class="literal">st</span> column. Next, the <span class="literal">UPDATE</span> statement’s <span class="literal">SET</span> clause <span class="ent">➋</span> fills our newly created <span class="literal">st_copy</span> column with the values in column <span class="literal">st</span>. Because we don’t specify any criteria using a <span class="literal">WHERE</span> clause, values in every row are updated, and PostgreSQL returns the message <span class="literal">UPDATE 6287</span>. Again, it’s worth noting that on a very large table, this operation could take some time and also substantially increase the table’s size. Making a column copy in addition to a table backup isn’t entirely necessary, but if you’re the patient, cautious type, it can be worthwhile.</p>
<p class="indent">We can confirm the values were copied properly with a simple <span class="literal">SELECT</span> query on both columns, as in <a href="ch09.xhtml#ch09list10">Listing 9-10</a>:</p>
<p class="programs">SELECT st,<br/>       st_copy<br/>FROM meat_poultry_egg_inspect<br/>ORDER BY st;</p>
<p class="listing" id="ch09list10"><em>Listing 9-10: Checking values in the <span class="literal">st</span> and <span class="literal">st_copy</span> columns</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_141"/>The <span class="literal">SELECT</span> query returns 6,287 rows showing both columns holding values except the three rows with missing values:</p>
<p class="programs">st    st_copy<br/>--    -------<br/>AK    AK<br/>AK    AK<br/>AK    AK<br/>AK    AK<br/><em>--snip--</em></p>
<p class="indent">Now, with our original data safely stored in the <span class="literal">st_copy</span> column, we can update the three rows with missing state codes. This is now our in-table backup, so if something goes drastically wrong while we’re updating the missing data in the original column, we can easily copy the original data back in. I’ll show you how after we apply the first updates.</p>
<h5 class="h5" id="lev146">Updating Rows Where Values Are Missing</h5>
<p class="noindent">To update those rows missing values, we first find the values we need with a quick online search: Atlas Inspection is located in Minnesota; Hall-Namie Packing is in Alabama; and Jones Dairy is in Wisconsin. Add those states to the appropriate rows using the code in <a href="ch09.xhtml#ch09list11">Listing 9-11</a>:</p>
<p class="programs">  UPDATE meat_poultry_egg_inspect<br/>  SET st = 'MN'<br/><span class="ent">➊</span> WHERE est_number = 'V18677A';<br/><br/>  UPDATE meat_poultry_egg_inspect<br/>  SET st = 'AL'<br/>  WHERE est_number = 'M45319+P45319';<br/><br/>  UPDATE meat_poultry_egg_inspect<br/>  SET st = 'WI'<br/>  WHERE est_number = 'M263A+P263A+V263A';</p>
<p class="listing" id="ch09list11"><em>Listing 9-11: Updating the <span class="literal">st</span> column for three establishments</em></p>
<p class="indent">Because we want each <span class="literal">UPDATE</span> statement to affect a single row, we include a <span class="literal">WHERE</span> clause <span class="ent">➊</span> for each that identifies the company’s unique <span class="literal">est_number</span>, which is the table’s primary key. When we run each query, PostgreSQL responds with the message <span class="literal">UPDATE 1</span>, showing that only one row was updated for each query.</p>
<p class="indent">If we rerun the code in <a href="ch09.xhtml#ch09list4">Listing 9-4</a> to find rows where <span class="literal">st</span> is <span class="literal">NULL</span>, the query should return nothing. Success! Our count of establishments by state is now complete.</p>
<h5 class="h5" id="lev147"><span epub:type="pagebreak" id="page_142"/>Restoring Original Values</h5>
<p class="noindent">What happens if we botch an update by providing the wrong values or updating the wrong rows? Because we’ve backed up the entire table and the <span class="literal">st</span> column within the table, we can easily copy the data back from either location. <a href="ch09.xhtml#ch09list12">Listing 9-12</a> shows the two options.</p>
<p class="programs"><span class="ent">➊</span> UPDATE meat_poultry_egg_inspect<br/>  SET st = st_copy;<br/><br/><span class="ent">➋</span> UPDATE meat_poultry_egg_inspect original<br/>  SET st = backup.st<br/>  FROM meat_poultry_egg_inspect_backup backup<br/>  WHERE original.est_number = backup.est_number;</p>
<p class="listing" id="ch09list12"><em>Listing 9-12: Restoring original <span class="literal">st</span> column values</em></p>
<p class="indent">To restore the values from the backup column in <span class="literal">meat_poultry_egg_inspect</span> you created in <a href="ch09.xhtml#ch09list9">Listing 9-9</a>, run an <span class="literal">UPDATE</span> query <span class="ent">➊</span> that sets <span class="literal">st</span> to the values in <span class="literal">st_copy</span>. Both columns should again have the identical original values. Alternatively, you can create an <span class="literal">UPDATE</span> <span class="ent">➋</span> that sets <span class="literal">st</span> to values in the <span class="literal">st</span> column from the <span class="literal">meat_poultry_egg_inspect_backup</span> table you made in <a href="ch09.xhtml#ch09list8">Listing 9-8</a>.</p>
<h4 class="h4" id="lev148"><em>Updating Values for Consistency</em></h4>
<p class="noindent">In <a href="ch09.xhtml#ch09list5">Listing 9-5</a> we discovered several cases where a single company’s name was entered inconsistently. If we want to aggregate data by company name, such inconsistencies will hinder us from doing so.</p>
<p class="indent">Here are the spelling variations of Armour-Eckrich Meats in <a href="ch09.xhtml#ch09list5">Listing 9-5</a>:</p>
<p class="programs"><em>--snip--</em><br/>Armour - Eckrich Meats, LLC<br/>Armour-Eckrich Meats LLC<br/>Armour-Eckrich Meats, Inc.<br/>Armour-Eckrich Meats, LLC<br/><em>--snip--</em></p>
<p class="indent">We can standardize the spelling of this company’s name by using an <span class="literal">UPDATE</span> statement. To protect our data, we’ll create a new column for the standardized spellings, copy the names in <span class="literal">company</span> into the new column, and work in the new column to avoid tampering with the original data. <a href="ch09.xhtml#ch09list13">Listing 9-13</a> has the code for both actions:</p>
<p class="programs">ALTER TABLE meat_poultry_egg_inspect ADD COLUMN company_standard varchar(100);<br/><br/>UPDATE meat_poultry_egg_inspect<br/>SET company_standard = company;</p>
<p class="listing" id="ch09list13"><em>Listing 9-13: Creating and filling the <span class="literal">company_standard</span> column</em></p>
<p class="indent">Now, let’s say we want any name in <span class="literal">company</span> that contains the string <span class="literal">Armour</span> to appear in <span class="literal">company_standard</span> as <span class="literal">Armour-Eckrich Meats</span>. (This assumes we’ve <span epub:type="pagebreak" id="page_143"/>checked all entries containing Armour and want to standardize them.) We can update all the rows matching the string <span class="literal">Armour</span> by using a <span class="literal">WHERE</span> clause. Run the two statements in <a href="ch09.xhtml#ch09list14">Listing 9-14</a>:</p>
<p class="programs">  UPDATE meat_poultry_egg_inspect<br/>  SET company_standard = 'Armour-Eckrich Meats'<br/><span class="ent">➊</span> WHERE company LIKE 'Armour%';<br/><br/>  SELECT company, company_standard<br/>  FROM meat_poultry_egg_inspect<br/>  WHERE company LIKE 'Armour%';</p>
<p class="listing" id="ch09list14"><em>Listing 9-14: Using an <span class="literal">UPDATE</span> statement to modify field values that match a string</em></p>
<p class="indent">The important piece of this query is the <span class="literal">WHERE</span> clause that uses the <span class="literal">LIKE</span> keyword <span class="ent">➊</span> that was introduced with filtering in <a href="ch02.xhtml#ch02">Chapter 2</a>. Including the wildcard syntax <span class="literal">%</span> at the end of the string <span class="literal">Armour</span> updates all rows that start with those characters regardless of what comes after them. The clause lets us target all the varied spellings used for the company’s name. The <span class="literal">SELECT</span> statement in <a href="ch09.xhtml#ch09list14">Listing 9-14</a> returns the results of the updated <span class="literal">company_standard</span> column next to the original <span class="literal">company</span> column:</p>
<p class="programs">company                        company_standard<br/>---------------------------    --------------------<br/>Armour-Eckrich Meats LLC       Armour-Eckrich Meats<br/>Armour - Eckrich Meats, LLC    Armour-Eckrich Meats<br/>Armour-Eckrich Meats LLC       Armour-Eckrich Meats<br/>Armour-Eckrich Meats LLC       Armour-Eckrich Meats<br/>Armour-Eckrich Meats, Inc.     Armour-Eckrich Meats<br/>Armour-Eckrich Meats, LLC      Armour-Eckrich Meats<br/>Armour-Eckrich Meats, LLC      Armour-Eckrich Meats</p>
<p class="indent">The values for Armour-Eckrich in <span class="literal">company_standard</span> are now standardized with consistent spelling. If we want to standardize other company names in the table, we would create an <span class="literal">UPDATE</span> statement for each case. We would also keep the original <span class="literal">company</span> column for reference.</p>
<h4 class="h4" id="lev149"><em>Repairing ZIP Codes Using Concatenation</em></h4>
<p class="noindent">Our final fix repairs values in the <span class="literal">zip</span> column that lost leading zeros as the result of my deliberate data faux pas. For companies in Puerto Rico and the U.S. Virgin Islands, we need to restore two leading zeros to the values in <span class="literal">zip</span> because (aside from an IRS processing facility in Holtsville, NY) they’re the only locations in the United States where ZIP Codes start with two zeros. Then, for the other states, located mostly in New England, we’ll restore a single leading zero.</p>
<p class="indent">We’ll use <span class="literal">UPDATE</span> again but this time in conjunction with the double-pipe <em>string operator</em> (<span class="literal">||</span>), which performs <em>concatenation</em>. Concatenation combines two or more string or non-string values into one. For example, inserting <span class="literal">||</span> between the strings <span class="literal">abc</span> and <span class="literal">123</span> results in <span class="literal">abc123</span>. The double-pipe operator <span epub:type="pagebreak" id="page_144"/>is a SQL standard for concatenation supported by PostgreSQL. You can use it in many contexts, such as <span class="literal">UPDATE</span> queries and <span class="literal">SELECT</span>, to provide custom output from existing as well as new data.</p>
<p class="indent">First, <a href="ch09.xhtml#ch09list15">Listing 9-15</a> makes a backup copy of the <span class="literal">zip</span> column in the same way we made a backup of the <span class="literal">st</span> column earlier:</p>
<p class="programs">ALTER TABLE meat_poultry_egg_inspect ADD COLUMN zip_copy varchar(5);<br/><br/>UPDATE meat_poultry_egg_inspect<br/>SET zip_copy = zip;</p>
<p class="listing" id="ch09list15"><em>Listing 9-15: Creating and filling the <span class="literal">zip_copy</span> column</em></p>
<p class="indent">Next, we use the code in <a href="ch09.xhtml#ch09list16">Listing 9-16</a> to perform the first update:</p>
<p class="programs">  UPDATE meat_poultry_egg_inspect<br/><span class="ent">➊</span> SET zip = '00' || zip<br/><span class="ent">➋</span> WHERE st IN('PR','VI') AND length(zip) = 3;</p>
<p class="listing" id="ch09list16"><em>Listing 9-16: Modifying codes in the <span class="literal">zip</span> column missing two leading zeros</em></p>
<p class="indent">We use <span class="literal">SET</span> to set the <span class="literal">zip</span> column <span class="ent">➊</span> to a value that is the result of the concatenation of the string <span class="literal">00</span> and the existing content of the <span class="literal">zip</span> column. We limit the <span class="literal">UPDATE</span> to only those rows where the <span class="literal">st</span> column has the state codes <span class="literal">PR</span> and <span class="literal">VI</span> <span class="ent">➋</span> using the <span class="literal">IN</span> comparison operator from <a href="ch02.xhtml#ch02">Chapter 2</a> and add a test for rows where the length of <span class="literal">zip</span> is <span class="literal">3</span>. This entire statement will then only update the <span class="literal">zip</span> values for Puerto Rico and the Virgin Islands. Run the query; PostgreSQL should return the message <span class="literal">UPDATE 86</span>, which is the number of rows we expect to change based on our earlier count in <a href="ch09.xhtml#ch09list6">Listing 9-6</a>.</p>
<p class="indent">Let’s repair the remaining ZIP Codes using a similar query in <a href="ch09.xhtml#ch09list17">Listing 9-17</a>:</p>
<p class="programs">UPDATE meat_poultry_egg_inspect<br/>SET zip = '0' || zip<br/>WHERE st IN('CT','MA','ME','NH','NJ','RI','VT') AND length(zip) = 4;</p>
<p class="listing" id="ch09list17"><em>Listing 9-17: Modifying codes in the <span class="literal">zip</span> column missing one leading zero</em></p>
<p class="indent">PostgreSQL should return the message <span class="literal">UPDATE 496</span>. Now, let’s check our progress. Earlier in the chapter, when we aggregated rows in the <span class="literal">zip</span> column by length, we found <span class="literal">86</span> rows with three characters and <span class="literal">496</span> with four:</p>
<p class="programs">length    count<br/>------    -----<br/>     3       86<br/>     4      496<br/>     5     5705</p>
<p class="indent"><span epub:type="pagebreak" id="page_145"/>Using the same query in <a href="ch09.xhtml#ch09list6">Listing 9-6</a> now returns a more desirable result: all the rows have a five-digit ZIP Code.</p>
<p class="programs">length    count<br/>------    -----<br/>     5     6287</p>
<p class="indent">In this example we used concatenation, but you can employ additional SQL string functions to modify data with <span class="literal">UPDATE</span> by changing words from uppercase to lowercase, trimming unwanted spaces, replacing characters in a string, and more. I’ll discuss additional string functions in <a href="ch13.xhtml#ch13">Chapter 13</a> when we consider advanced techniques for working with text.</p>
<h4 class="h4" id="lev150"><em>Updating Values Across Tables</em></h4>
<p class="noindent">In <a href="ch09.xhtml#lev142">“Modifying Values with <span class="literal">UPDATE</span>”</a> on <a href="ch09.xhtml#page_138">page 138</a>, I showed the standard ANSI SQL and PostgreSQL-specific syntax for updating values in one table based on values in another. This syntax is particularly valuable in a relational database where primary keys and foreign keys establish table relationships. It’s also useful when data in one table may be necessary context for updating values in another.</p>
<p class="indent">For example, let’s say we’re setting an inspection date for each of the companies in our table. We want to do this by U.S. regions, such as Northeast, Pacific, and so on, but those regional designations don’t exist in our table. However, they <em>do</em> exist in a data set we can add to our database that also contains matching <span class="literal">st</span> state codes. This means we can use that other data as part of our <span class="literal">UPDATE</span> statement to provide the necessary information. Let’s begin with the New England region to see how this works.</p>
<p class="indent">Enter the code in <a href="ch09.xhtml#ch09list18">Listing 9-18</a>, which contains the SQL statements to create a <span class="literal">state_regions</span> table and fill the table with data:</p>
<p class="programs">CREATE TABLE state_regions (<br/>    st varchar(2) CONSTRAINT st_key PRIMARY KEY,<br/>    region varchar(20) NOT NULL<br/>);<br/><br/>COPY state_regions<br/>FROM '<em>C:\YourDirectory\</em>state_regions.csv'<br/>WITH (FORMAT CSV, HEADER, DELIMITER ',');</p>
<p class="listing" id="ch09list18"><em>Listing 9-18: Creating and filling a <span class="literal">state_regions</span> table</em></p>
<p class="indent">We’ll create two columns in a <span class="literal">state_regions</span> table: one containing the two-character state code <span class="literal">st</span> and the other containing the <span class="literal">region</span> name. We set the primary key constraint to the <span class="literal">st</span> column, which holds a unique <span class="literal">st_key</span> value to identify each state. In the data you’re importing, each state is present and assigned to a U.S. Census region, and territories outside the United States are labeled as outlying areas. We’ll update the table one region at a time.</p>
<p class="indent"><span epub:type="pagebreak" id="page_146"/>Next, let’s return to the <span class="literal">meat_poultry_egg_inspect</span> table, add a column for inspection dates, and then fill in that column with the New England states. <a href="ch09.xhtml#ch09list19">Listing 9-19</a> shows the code:</p>
<p class="programs">  ALTER TABLE meat_poultry_egg_inspect ADD COLUMN inspection_date date;<br/><br/><span class="ent">➊</span> UPDATE meat_poultry_egg_inspect inspect<br/><span class="ent">➋</span> SET inspection_date = '2019-12-01'<br/><span class="ent">➌</span> WHERE EXISTS (SELECT state_regions.region<br/>                FROM state_regions<br/>                WHERE inspect.st = state_regions.st<br/>                      AND state_regions.region = 'New England');</p>
<p class="listing" id="ch09list19"><em>Listing 9-19: Adding and updating an <span class="literal">inspection_date</span> column</em></p>
<p class="indent">The <span class="literal">ALTER TABLE</span> statement creates the <span class="literal">inspection_date</span> column in the <span class="literal">meat_poultry_egg_inspect</span> table. In the <span class="literal">UPDATE</span> statement, we start by naming the table using an alias of <span class="literal">inspect</span> to make the code easier to read <span class="ent">➊</span>. Next, the <span class="literal">SET</span> clause assigns a date value of <span class="literal">2019-12-01</span> to the new <span class="literal">inspection</span><span class="literal">_date</span> column <span class="ent">➋</span>. Finally, the <span class="literal">WHERE EXISTS</span> clause includes a subquery that connects the <span class="literal">meat</span><span class="literal">_poultry_egg_inspect</span> table to the <span class="literal">state_regions</span> table we created in <a href="ch09.xhtml#ch09list18">Listing 9-18</a> and specifies which rows to update <span class="ent">➌</span>. The subquery (in parentheses, beginning with <span class="literal">SELECT</span>) looks for rows in the <span class="literal">state_regions</span> table where the <span class="literal">region</span> column matches the string <span class="literal">New England</span>. At the same time, it joins the <span class="literal">meat</span><span class="literal">_</span><span class="literal">poultry</span><span class="literal">_egg_inspect</span> table with the <span class="literal">state_regions</span> table using the <span class="literal">st</span> column from both tables. In effect, the query is telling the database to find all the <span class="literal">st</span> codes that correspond to the New England region and use those codes to filter the update.</p>
<p class="indent">When you run the code, you should receive a message of <span class="literal">UPDATE 252</span>, which is the number of companies in New England. You can use the code in <a href="ch09.xhtml#ch09list20">Listing 9-20</a> to see the effect of the change:</p>
<p class="programs">SELECT st, inspection_date<br/>FROM meat_poultry_egg_inspect<br/>GROUP BY st, inspection_date<br/>ORDER BY st;</p>
<p class="listing" id="ch09list20"><em>Listing 9-20: Viewing updated <span class="literal">inspection_date</span> values</em></p>
<p class="indent">The results should show the updated inspection dates for all New England companies. The top of the output shows Connecticut has received a date, for example, but states outside New England remain <span class="literal">NULL</span> because we haven’t updated them yet:</p>
<p class="programs">st    inspection_date<br/>--    ---------------<br/><em>--snip--</em><br/>CA<br/>CO<br/>CT    2019-12-01<br/>DC<br/><em>--snip--</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_147"/>To fill in dates for additional regions, substitute a different region for <span class="literal">New England</span> in <a href="ch09.xhtml#ch09list19">Listing 9-19</a> and rerun the query.</p>
<h3 class="h3" id="lev151">Deleting Unnecessary Data</h3>
<p class="noindent">The most irrevocable way to modify data is to remove it entirely. SQL includes options to remove rows and columns from a table along with options to delete an entire table or database. We want to perform these operations with caution, removing only data or tables we don’t need. Without a backup, the data is gone for good.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>It’s easy to exclude unwanted data in queries using a <span class="literal">WHERE</span> clause, so decide whether you truly need to delete the data or can just filter it out. Cases where deleting may be the best solution include data with errors or data imported incorrectly.</em></p>
</div>
<p class="indent">In this section, we’ll use a variety of SQL statements to delete unnecessary data. For removing rows from a table, we’ll use the <span class="literal">DELETE FROM</span> statement. To remove a column from a table, we’ll use <span class="literal">ALTER TABLE</span>. And to remove a whole table from the database, we’ll use the <span class="literal">DROP TABLE</span> statement.</p>
<p class="indent">Writing and executing these statements is fairly simple, but doing so comes with a caveat. If deleting rows, a column, or a table would cause a violation of a constraint, such as the foreign key constraint covered in <a href="ch07.xhtml#ch07">Chapter 7</a>, you need to deal with that constraint first. That might involve removing the constraint, deleting data in another table, or deleting another table. Each case is unique and will require a different way to work around the constraint.</p>
<h4 class="h4" id="lev152"><em>Deleting Rows from a Table</em></h4>
<p class="noindent">Using a <span class="literal">DELETE FROM</span> statement, we can remove all rows from a table, or we can use a <span class="literal">WHERE</span> clause to delete only the portion that matches an expression we supply. To delete all rows from a table, use the following syntax:</p>
<p class="programs">DELETE FROM <em>table_name</em>;</p>
<p class="indent">If your table has a large number of rows, it might be faster to erase the table and create a fresh version using the original <span class="literal">CREATE TABLE</span> statement. To erase the table, use the <span class="literal">DROP TABLE</span> command discussed in <a href="ch09.xhtml#lev154">“Deleting a Table from a Database”</a> on <a href="ch09.xhtml#page_148">page 148</a>.</p>
<p class="indent">To remove only selected rows, add a <span class="literal">WHERE</span> clause along with the matching value or pattern to specify which ones you want to delete:</p>
<p class="programs">DELETE FROM <em>table_name</em> WHERE <span class="codeitalic">expression</span>;</p>
<p class="indent"><span epub:type="pagebreak" id="page_148"/>For example, if we want our table of meat, poultry, and egg processors to include only establishments in the 50 U.S. states, we can remove the companies in Puerto Rico and the Virgin Islands from the table using the code in <a href="ch09.xhtml#ch09list21">Listing 9-21</a>:</p>
<p class="programs">DELETE FROM meat_poultry_egg_inspect<br/>WHERE st IN('PR','VI');</p>
<p class="listing" id="ch09list21"><em>Listing 9-21: Deleting rows matching an expression</em></p>
<p class="indent">Run the code; PostgreSQL should return the message <span class="literal">DELETE 86</span>. This means the 86 rows where the <span class="literal">st</span> column held either <span class="literal">PR</span> or <span class="literal">VI</span> have been removed from the table.</p>
<h4 class="h4" id="lev153"><em>Deleting a Column from a Table</em></h4>
<p class="noindent">While working on the <span class="literal">zip</span> column in the <span class="literal">meat_poultry_egg_inspect</span> table earlier in this chapter, we created a backup column called <span class="literal">zip_copy</span>. Now that we’ve finished working on fixing the issues in <span class="literal">zip</span>, we no longer need <span class="literal">zip_copy</span>. We can remove the backup column, including all the data within the column, from the table by using the <span class="literal">DROP</span> keyword in the <span class="literal">ALTER TABLE</span> statement.</p>
<p class="indent">The syntax for removing a column is similar to other <span class="literal">ALTER TABLE</span> statements:</p>
<p class="programs">ALTER TABLE <em>table_name</em> DROP COLUMN <em>column_name</em>;</p>
<p class="indent">The code in <a href="ch09.xhtml#ch09list22">Listing 9-22</a> removes the <span class="literal">zip_copy</span> column:</p>
<p class="programs">ALTER TABLE meat_poultry_egg_inspect DROP COLUMN zip_copy;</p>
<p class="listing" id="ch09list22"><em>Listing 9-22: Removing a column from a table using <span class="literal">DROP</span></em></p>
<p class="indent">PostgreSQL returns the message <span class="literal">ALTER TABLE</span>, and the <span class="literal">zip_copy</span> column should be deleted.</p>
<h4 class="h4" id="lev154"><em>Deleting a Table from a Database</em></h4>
<p class="noindent">The <span class="literal">DROP TABLE</span> statement is a standard ANSI SQL feature that deletes a table from the database. This statement might come in handy if, for example, you have a collection of backups, or <em>working tables</em>, that have outlived their usefulness. It’s also useful in other situations, such as when you need to change the structure of a table significantly; in that case, rather than using too many <span class="literal">ALTER TABLE</span> statements, you can just remove the table and create another one by running a new <span class="literal">CREATE TABLE</span> statement.</p>
<p class="indent">The syntax for the <span class="literal">DROP TABLE</span> command is simple:</p>
<p class="programs">DROP TABLE <em>table_name</em>;</p>
<p class="indent"><span epub:type="pagebreak" id="page_149"/>For example, <a href="ch09.xhtml#ch09list23">Listing 9-23</a> deletes the backup version of the <span class="literal">meat_</span><span class="literal">poultr</span><span class="literal">y_</span><span class="literal">e</span><span class="literal">gg_inspect</span> table:</p>
<p class="programs">DROP TABLE meat_poultry_egg_inspect_backup;</p>
<p class="listing" id="ch09list23"><em>Listing 9-23: Removing a table from a database using <span class="literal">DROP</span></em></p>
<p class="indent">Run the query; PostgreSQL should respond with the message <span class="literal">DROP TABLE</span> to indicate the table has been removed.</p>
<h3 class="h3" id="lev155">Using Transaction Blocks to Save or Revert Changes</h3>
<p class="noindent">The alterations you made on data using the techniques in this chapter so far are final. That is, after you run a <span class="literal">DELETE</span> or <span class="literal">UPDATE</span> query (or any other query that alters your data or database structure), the only way to undo the change is to restore from a backup. However, you can check your changes before finalizing them and cancel the change if it’s not what you intended. You do this by wrapping the SQL statement within a <em>transaction block</em>, which is a group of statements you define using the following keywords at the beginning and end of the query:</p>
<p class="hang"><span class="literal"><strong>START TRANSACTION</strong></span> signals the start of the transaction block. In PostgreSQL, you can also use the non-ANSI SQL <span class="literal"><strong>BEGIN</strong></span> keyword.</p>
<p class="hang"><span class="literal"><strong>COMMIT</strong></span> signals the end of the block and saves all changes.</p>
<p class="hang"><span class="literal"><strong>ROLLBACK</strong></span> signals the end of the block and reverts all changes.</p>
<p class="indentt">Usually, database programmers employ a transaction block to define the start and end of a sequence of operations that perform one unit of work in a database. An example is when you purchase tickets to a Broadway show. A successful transaction might involve two steps: charging your credit card and reserving your seats so someone else can’t buy them. A database programmer would either want both steps in the transaction to happen (say, when your card charge goes through) or neither of them to happen (if your card is declined or you cancel at checkout). Defining both steps as one transaction keeps them as a unit; if one step fails, the other is canceled too. You can learn more details about transactions and PostgreSQL at <em><a href="https://www.postgresql.org/docs/current/static/tutorial-transactions.html">https://www.postgresql.org/docs/current/static/tutorial-transactions.html</a></em>.</p>
<p class="indent">We can apply this transaction block technique to review changes a query makes and then decide whether to keep or discard them. Using the <span class="literal">meat_poultry_egg_inspect</span> table, let’s say we’re cleaning dirty data related to the company AGRO Merchants Oakland LLC. The table has three rows listing the company, but one row has an extra comma in the name:</p>
<p class="programs">company<br/>---------------------------<br/>AGRO Merchants Oakland LLC<br/>AGRO Merchants Oakland LLC<br/>AGRO Merchants Oakland, LLC</p>
<p class="indent"><span epub:type="pagebreak" id="page_150"/>We want the name to be consistent, so we’ll remove the comma from the third row using an <span class="literal">UPDATE</span> query, as we did earlier. But this time we’ll check the result of our update before we make it final (and we’ll purposely make a mistake we want to discard). <a href="ch09.xhtml#ch09list24">Listing 9-24</a> shows how to do this using a transaction block:</p>
<p class="programs"><span class="ent">➊</span> START TRANSACTION;<br/><br/>  UPDATE meat_poultry_egg_inspect<br/><span class="ent">➋</span> SET company = 'AGRO Merchantss Oakland LLC'<br/>  WHERE company = 'AGRO Merchants Oakland, LLC';<br/><br/><span class="ent">➌</span> SELECT company<br/>  FROM meat_poultry_egg_inspect<br/>  WHERE company LIKE 'AGRO%'<br/>  ORDER BY company;<br/><br/><span class="ent">➍</span> ROLLBACK;</p>
<p class="listing" id="ch09list24"><em>Listing 9-24: Demonstrating a transaction block</em></p>
<p class="indent">We’ll run each statement separately, beginning with <span class="literal">START TRANSACTION;</span> <span class="ent">➊</span>. The database responds with the message <span class="literal">START TRANSACTION</span>, letting you know that any succeeding changes you make to data will not be made permanent unless you issue a <span class="literal">COMMIT</span> command. Next, we run the <span class="literal">UPDATE</span> statement, which changes the company name in the row where it has an extra comma. I intentionally added an extra s in the name used in the <span class="literal">SET</span> clause <span class="ent">➋</span> to introduce a mistake.</p>
<p class="indent">When we view the names of companies starting with the letters <span class="literal">AGRO</span> using the <span class="literal">SELECT</span> statement <span class="ent">➌</span>, we see that, oops, one company name is misspelled now:</p>
<p class="programs">company<br/>---------------------------<br/>AGRO Merchants Oakland LLC<br/>AGRO Merchants Oakland LLC<br/>AGRO Merchantss Oakland LLC</p>
<p class="indent">Instead of rerunning the <span class="literal">UPDATE</span> statement to fix the typo, we can simply discard the change by running the <span class="literal">ROLLBACK;</span> <span class="ent">➍</span> command. When we rerun the <span class="literal">SELECT</span> statement to view the company names, we’re back to where we started:</p>
<p class="programs">company<br/>---------------------------<br/>AGRO Merchants Oakland LLC<br/>AGRO Merchants Oakland LLC<br/>AGRO Merchants Oakland, LLC</p>
<p class="indent"><span epub:type="pagebreak" id="page_151"/>From here, you could correct your <span class="literal">UPDATE</span> statement by removing the extra <span class="literal">s</span> and rerun it, beginning with the <span class="literal">START TRANSACTION</span> statement again. If you’re happy with the changes, run <span class="literal">COMMIT;</span> to make them permanent.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>When you start a transaction, any changes you make to the data aren’t visible to other database users until you execute <span class="literal">COMMIT</span>.</em></p>
</div>
<p class="indent">Transaction blocks are often used in more complex database systems. Here you’ve used them to try a query and either accept or reject the changes, saving you time and headaches. Next, let’s look at another way to save time when updating lots of data.</p>
<h3 class="h3" id="lev156">Improving Performance When Updating Large Tables</h3>
<p class="noindent">Because of how PostgreSQL works internally, adding a column to a table and filling it with values can quickly inflate the table’s size. The reason is that the database creates a new version of the existing row each time a value is updated, but it doesn’t delete the old row version. (You’ll learn how to clean up these old rows when I discuss database maintenance in <a href="ch17.xhtml#lev303">“Recovering Unused Space with <span class="literal">VACUUM</span>”</a> on <a href="ch17.xhtml#page_314">page 314</a>.) For small data sets, the increase is negligible, but for tables with hundreds of thousands or millions of rows, the time required to update rows and the resulting extra disk usage can be substantial.</p>
<p class="indent">Instead of adding a column and filling it with values, we can save disk space by copying the entire table and adding a populated column during the operation. Then, we rename the tables so the copy replaces the original, and the original becomes a backup.</p>
<p class="indent"><a href="ch09.xhtml#ch09list25">Listing 9-25</a> shows how to copy <span class="literal">meat_poultry_egg_inspect</span> into a new table while adding a populated column. To do this, first drop the <span class="literal">meat_poultry_egg_inspect_backup</span> table we made earlier. Then run the <span class="literal">CREATE TABLE</span> statement.</p>
<p class="programs">  CREATE TABLE meat_poultry_egg_inspect_backup AS<br/><span class="ent">➊</span> SELECT *,<br/>       <span class="ent">➋</span> '2018-02-07'::date AS reviewed_date<br/>  FROM meat_poultry_egg_inspect;</p>
<p class="listing" id="ch09list25"><em>Listing 9-25: Backing up a table while adding and filling a new column</em></p>
<p class="indent">The query is a modified version of the backup script in <a href="ch09.xhtml#ch09list8">Listing 9-8</a>. Here, in addition to selecting all the columns using the asterisk wildcard <span class="ent">➊</span>, we also add a column called <span class="literal">reviewed_date</span> by providing a value cast as a <span class="literal">date</span> data type <span class="ent">➋</span> and the <span class="literal">AS</span> keyword. That syntax adds and fills <span class="literal">reviewed_date</span>, which we might use to track the last time we checked the status of each plant.</p>
<p class="indent">Then we use <a href="ch09.xhtml#ch09list26">Listing 9-26</a> to swap the table names:</p>
<p class="programs"><span class="ent">➊</span> ALTER TABLE meat_poultry_egg_inspect RENAME TO meat_poultry_egg_inspect_temp;<br/><span class="ent">➋</span> ALTER TABLE meat_poultry_egg_inspect_backup<br/>    RENAME TO meat_poultry_egg_inspect;<br/><span epub:type="pagebreak" id="page_152"/><span class="ent">➌</span> ALTER TABLE meat_poultry_egg_inspect_temp<br/>    RENAME TO meat_poultry_egg_inspect_backup;</p>
<p class="listing" id="ch09list26"><em>Listing 9-26: Swapping table names using <span class="literal">ALTER TABLE</span></em></p>
<p class="indent">Here we use <span class="literal">ALTER TABLE</span> with a <span class="literal">RENAME TO</span> clause to change a table name. Then we use the first statement to change the original table name to one that ends with <span class="literal">_temp</span> <span class="ent">➊</span>. The second statement renames the copy we made with <a href="ch09.xhtml#ch09list24">Listing 9-24</a> to the original name of the table <span class="ent">➋</span>. Finally, we rename the table that ends with <span class="literal">_temp</span> to the ending <span class="literal">_backup</span> <span class="ent">➌</span>. The original table is now called <span class="literal">meat_poultry_egg_inspect_backup</span>, and the copy with the added column is called <span class="literal">meat_poultry_egg_inspect</span>.</p>
<p class="indent">By using this process, we avoid updating rows and having the database inflate the size of the table. When we eventually drop the <span class="literal">_backup</span> table, the remaining data table is smaller and does not require cleanup.</p>
<h3 class="h3" id="lev157">Wrapping Up</h3>
<p class="noindent">Gleaning useful information from data sometimes requires modifying the data to remove inconsistencies, fix errors, and make it more suitable for supporting an accurate analysis. In this chapter you learned some useful tools to help you assess dirty data and clean it up. In a perfect world, all data sets would arrive with everything clean and complete. But such a perfect world doesn’t exist, so the ability to alter, update, and delete data is indispensable.</p>
<p class="indent">Let me restate the important tasks of working safely. Be sure to back up your tables before you start making changes. Make copies of your columns, too, for an extra level of protection. When I discuss database maintenance for PostgreSQL later in the book, you’ll learn how to back up entire databases. These few steps of precaution will save you a world of pain.</p>
<p class="indent">In the next chapter, we’ll return to math to explore some of SQL’s advanced statistical functions and techniques for analysis.</p>
<div class="sidebar" id="ch09sb1">
<p class="sidebart"><strong>TRY IT YOURSELF</strong></p>
<p class="spara">In this exercise, you’ll turn the <span class="literal">meat_poultry_egg_inspect</span> table into useful information. You need to answer two questions: how many of the plants in the table process meat, and how many process poultry?</p>
<p class="spara1">The answers to these two questions lie in the <span class="literal">activities</span> column. Unfortunately, the column contains an assortment of text with inconsistent input. Here’s an example of the kind of text you’ll find in the <span class="literal">activities</span> column:</p>
<p class="programs">Poultry Processing, Poultry Slaughter<br/>Meat Processing, Poultry Processing<br/>Poultry Processing, Poultry Slaughter</p>
<p class="spara1"><span epub:type="pagebreak" id="page_153"/>The mishmash of text makes it impossible to perform a typical count that would allow you to group processing plants by activity. However, you can make some modifications to fix this data. Your tasks are as follows:</p>
<ol>
<li class="noindent"><p class="list">Create two new columns called <span class="literal">meat_processing</span> and <span class="literal">poultry_processing</span> in your table. Each can be of the type <span class="literal">boolean</span>.</p></li>
<li class="noindent"><p class="list">Using <span class="literal">UPDATE</span>, set <span class="literal">meat_processing = TRUE</span> on any row where the <span class="literal">activities</span> column contains the text <em>Meat Processing</em>. Do the same update on the <span class="literal">poultry</span><span class="literal">_processing</span> column, but this time look for the text <em>Poultry Processing</em> in <span class="literal">activities</span>.</p></li>
<li class="noindent"><p class="list">Use the data from the new, updated columns to count how many plants perform each type of activity. For a bonus challenge, count how many plants perform both activities.<span epub:type="pagebreak" id="page_154"/></p></li>
</ol>
</div>
</body>
</html>