<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_313"/><strong><span class="big">17</span></strong><br/><strong>MAINTAINING YOUR DATABASE</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">To wrap up our exploration of SQL, we’ll look at key database maintenance tasks and options for customizing PostgreSQL. In this chapter, you’ll learn how to track and conserve space in your databases, how to change system settings, and how to back up and restore databases. How often you’ll need to perform these tasks depends on your current role and interests. But if you want to be a <em>database administrator</em> or a <em>backend developer</em>, the topics covered here are vital to both jobs.</p>
<p class="indent">It’s worth noting that database maintenance and performance tuning are often the subjects of entire books, and this chapter mainly serves as an introduction to a handful of essentials. If you want to learn more, a good place to begin is with the resources in the Appendix.</p>
<p class="indent">Let’s start with the PostgreSQL <span class="literal">VACUUM</span> feature, which lets you shrink the size of tables by removing unused rows.</p>
<h3 class="h3" id="lev303"><span epub:type="pagebreak" id="page_314"/>Recovering Unused Space with VACUUM</h3>
<p class="noindent">To prevent database files from growing out of control, you can use the PostgreSQL <span class="literal">VACUUM</span> command. In <a href="ch09.xhtml#lev156">“Improving Performance When Updating Large Tables”</a> on <a href="ch09.xhtml#page_151">page 151</a>, you learned that the size of PostgreSQL tables can grow as a result of routine operations. For example, when you update a value in a row, the database creates a new version of that row that includes the updated value, but it doesn’t delete the old version of the row. (PostgreSQL documentation refers to these leftover rows that you can’t see as “dead” rows.)</p>
<p class="indent">Similarly, when you delete a row, even though the row is no longer visible, it lives on as a dead row in the table. The database uses dead rows to provide certain features in environments where multiple transactions are occurring and old versions of rows might be needed by transactions other than the current one.</p>
<p class="indent">Running <span class="literal">VACUUM</span> designates the space occupied by dead rows as available for the database to use again. But <span class="literal">VACUUM</span> doesn’t return the space to your system’s disk. Instead, it just flags that space as available for the database to use for its next operation. To return unused space to your disk, you must use the <span class="literal">VACUUM FULL</span> option, which creates a new version of the table that doesn’t include the freed-up dead row space.</p>
<p class="indent">Although you can run <span class="literal">VACUUM</span> on demand, by default PostgreSQL runs the <em>autovacuum</em> background process that monitors the database and runs <span class="literal">VACUUM</span> as needed. Later in this chapter I’ll show you how to monitor autovacuum as well as run the <span class="literal">VACUUM</span> command manually.</p>
<p class="indent">But first, let’s look at how a table grows as a result of updates and how you can track this growth.</p>
<h4 class="h4" id="lev304"><em>Tracking Table Size</em></h4>
<p class="noindent">We’ll create a small test table and monitor its growth in size as we fill it with data and perform an update. The code for this exercise, as with all resources for the book, is available at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>.</p>
<h5 class="h5">Creating a Table and Checking Its Size</h5>
<p class="noindent"><a href="ch17.xhtml#ch17list1">Listing 17-1</a> creates a <span class="literal">vacuum_test</span> table with a single column to hold an integer. Run the code, and then we’ll measure the table’s size.</p>
<p class="programs">CREATE TABLE vacuum_test (<br/>    integer_column integer<br/>);</p>
<p class="listing" id="ch17list1"><em>Listing 17-1: Creating a table to test vacuuming</em></p>
<p class="indent">Before we fill the table with test data, let’s check how much space it occupies on disk to establish a reference point. We can do so in two ways: check the table properties via the pgAdmin interface, or run queries using <span epub:type="pagebreak" id="page_315"/>PostgreSQL administrative functions. In pgAdmin, click once on a table to highlight it, and then click the <strong>Statistics</strong> tab. Table size is one of about two dozen indicators in the list.</p>
<p class="indent">I’ll focus on running queries here because knowing them is helpful if for some reason pgAdmin isn’t available or you’re using another GUI. For example, <a href="ch17.xhtml#ch17list2">Listing 17-2</a> shows how to check the <span class="literal">vacuum_test</span> table size using PostgreSQL functions:</p>
<p class="programs">SELECT <span class="ent">➊</span>pg_size_pretty(<br/>           <span class="ent">➋</span>pg_total_relation_size('vacuum_test')<br/>       );</p>
<p class="listing" id="ch17list2"><em>Listing 17-2: Determining the size of <span class="literal">vacuum_test</span></em></p>
<p class="indent">The outermost function, <span class="literal">pg_size_pretty()</span> <span class="ent">➊</span>, converts bytes to a more easily understandable format in kilobytes, megabytes, or gigabytes. Wrapped inside <span class="literal">pg_size_pretty()</span> is the <span class="literal">pg_total_relation_size()</span> function <span class="ent">➋</span>, which reports how many bytes a table, its indexes, and offline compressed data takes up on disk. Because the table is empty at this point, running the code in pgAdmin should return a value of <span class="literal">0 bytes</span>, like this:</p>
<p class="programs">pg_size_pretty<br/>--------------<br/>0 bytes</p>
<p class="indent">You can get the same information using the command line. Launch <span class="literal">psql</span> as you learned in <a href="ch16.xhtml#ch16">Chapter 16</a>. Then, at the prompt, enter the command <span class="literal"><strong>\dt+ vacuum_test</strong></span>, which should display the following information including table size:</p>
<div class="image"><img alt="image" src="../images/prog_page_315.jpg"/></div>
<p class="indent">Again, the current size of the <span class="literal">vacuum_test</span> table should display <span class="literal">0 bytes</span>.</p>
<h5 class="h5" id="lev305">Checking Table Size After Adding New Data</h5>
<p class="noindentb">Let’s add some data to the table and then check its size again. We’ll use the <span class="literal">generate_series()</span> function introduced in <a href="ch11.xhtml#ch11">Chapter 11</a> to fill the table’s <span class="literal">integer_column</span> with 500,000 rows. Run the code in <a href="ch17.xhtml#ch17list3">Listing 17-3</a> to do this:</p>
<p class="programs">INSERT INTO vacuum_test<br/>SELECT * FROM generate_series(1,500000);</p>
<p class="listing" id="ch17list3"><em>Listing 17-3: Inserting 500,000 rows into <span class="literal">vacuum_test</span></em></p>
<p class="indent"><span epub:type="pagebreak" id="page_316"/>This standard <span class="literal">INSERT INTO</span> statement adds the results of <span class="literal">generate_series()</span>, which is a series of values from 1 to 500,000, as rows to the table. After the query completes, rerun the query in <a href="ch17.xhtml#ch17list2">Listing 17-2</a> to check the table size. You should see the following output:</p>
<p class="programs">pg_size_pretty<br/>--------------<br/>17 MB</p>
<p class="indent">The query reports that the <span class="literal">vacuum_test</span> table, now with a single column of 500,000 integers, uses 17MB of disk space.</p>
<h5 class="h5" id="lev306">Checking Table Size After Updates</h5>
<p class="noindent">Now, let’s update the data to see how that affects the table size. We’ll use the code in <a href="ch17.xhtml#ch17list4">Listing 17-4</a> to update every row in the <span class="literal">vacuum_test</span> table by adding <span class="literal">1</span> to the <span class="literal">integer_column</span> values, replacing the existing value with a number that’s one greater.</p>
<p class="programs">UPDATE vacuum_test<br/>SET integer_column = integer_column + 1;</p>
<p class="listing" id="ch17list4"><em>Listing 17-4: Updating all rows in <span class="literal">vacuum_test</span></em></p>
<p class="indent">Run the code, and then test the table size again.</p>
<p class="programs">pg_size_pretty<br/>--------------<br/>35 MB</p>
<p class="indent">The table size has doubled from 17MB to 35MB! The increase seems excessive, because the <span class="literal">UPDATE</span> simply replaced existing numbers with values of a similar size. But as you might have guessed, the reason for this increase in table size is that for every updated value, PostgreSQL creates a new row, and the old row (a “dead” row) remains in the table. So even though you only see 500,000 rows, the table has double that number of rows.</p>
<p class="indent">Consequently, if you’re working with a database that is frequently updated, it will grow even if you’re not adding rows. This can surprise database owners who don’t monitor disk space because the drive eventually fills up and leads to server errors. You can use <span class="literal">VACUUM</span> to avoid this scenario. We’ll look at how using <span class="literal">VACUUM</span> and <span class="literal">VACUUM FULL</span> affects the table’s size on disk. But first, let’s review the process that runs <span class="literal">VACUUM</span> automatically as well as how to check on statistics related to table vacuums.</p>
<h4 class="h4" id="lev307"><em>Monitoring the autovacuum Process</em></h4>
<p class="noindent">PostgreSQL’s autovacuum process monitors the database and launches <span class="literal">VACUUM</span> automatically when it detects a large number of dead rows in a table. Although autovacuum is enabled by default, you can turn it on or off and configure it using the settings I’ll cover in <a href="ch17.xhtml#lev310">“Changing Server Settings”</a> on <span epub:type="pagebreak" id="page_317"/><a href="ch17.xhtml#page_318">page 318</a>. Because autovacuum runs in the background, you won’t see any immediately visible indication that it’s working, but you can check its activity by running a query.</p>
<p class="indent">PostgreSQL has its own <em>statistics collector</em> that tracks database activity and usage. You can look at the statistics by querying one of several views the system provides. (See a complete list of views for monitoring the state of the system at <em><a href="https://www.postgresql.org/docs/current/static/monitoring-stats.html">https://www.postgresql.org/docs/current/static/monitoring-stats.html</a></em>). To check the activity of autovacuum, query a view called <span class="literal">pg_stat_all_tables</span> using the code in <a href="ch17.xhtml#ch17list5">Listing 17-5</a>:</p>
<p class="programs">SELECT <span class="ent">➊</span>relname,<br/>       <span class="ent">➋</span>last_vacuum,<br/>       <span class="ent">➌</span>last_autovacuum,<br/>       <span class="ent">➍</span>vacuum_count,<br/>       <span class="ent">➎</span>autovacuum_count<br/>FROM pg_stat_all_tables<br/>WHERE relname = 'vacuum_test';</p>
<p class="listing" id="ch17list5"><em>Listing 17-5: Viewing autovacuum statistics for <span class="literal">vacuum_test</span></em></p>
<p class="indent">The <span class="literal">pg_stat_all_tables</span> view shows <span class="literal">relname</span> <span class="ent">➊</span>, which is the name of the table, plus statistics related to index scans, rows inserted and deleted, and other data. For this query, we’re interested in <span class="literal">last_vacuum</span> <span class="ent">➋</span> and <span class="literal">last_autovacuum</span> <span class="ent">➌</span>, which contain the last time the table was vacuumed manually and automatically, respectively. We also ask for <span class="literal">vacuum_count</span> <span class="ent">➍</span> and <span class="literal">autovacuum_count</span> <span class="ent">➎</span>, which show the number of times the vacuum was run manually and automatically.</p>
<p class="indent">By default, autovacuum checks tables every minute. So, if a minute has passed since you last updated <span class="literal">vacuum_test</span>, you should see details of vacuum activity when you run the query in <a href="ch17.xhtml#ch17list5">Listing 17-5</a>. Here’s what my system shows (note that I’ve removed seconds from the time to save space here):</p>
<div class="image"><img alt="image" src="../images/prog_page_317.jpg"/></div>
<p class="indent">The table shows the date and time of the last autovacuum, and the <span class="literal">autovacuum</span><span class="literal">_count</span> column shows one occurrence. This result indicates that autovacuum executed a <span class="literal">VACUUM</span> command on the table once. However, because we’ve not vacuumed manually, the <span class="literal">last_vacuum</span> column is empty and the <span class="literal">vacuum_count</span> is <span class="literal">0</span>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The autovacuum process also runs the <span class="literal">ANALYZE</span> command, which gathers data on the contents of tables. PostgreSQL stores this information and uses it to execute queries efficiently in the future. You can run <span class="literal">ANALYZE</span> manually if needed.</em></p>
</div>
<p class="indent">Recall that <span class="literal">VACUUM</span> designates dead rows as available for the database to reuse but doesn’t reduce the size of the table on disk. You can confirm this by rerunning the code in <a href="ch17.xhtml#ch17list2">Listing 17-2</a>, which shows the table remains at 35MB even after the automatic vacuum.</p>
<h4 class="h4" id="lev308"><span epub:type="pagebreak" id="page_318"/><em>Running VACUUM Manually</em></h4>
<p class="noindent">Depending on the server you’re using, you can turn off autovacuum. (I’ll show you how to view that setting in <a href="ch17.xhtml#lev311">“Locating and Editing <em>postgresql.conf</em>”</a> on <a href="ch17.xhtml#page_319">page 319</a>.) If autovacuum is off or if you simply want to run <span class="literal">VACUUM</span> manually, you can do so using a single line of code, as shown in <a href="ch17.xhtml#ch17list6">Listing 17-6</a>:</p>
<p class="programs">VACUUM vacuum_test;</p>
<p class="listing" id="ch17list6"><em>Listing 17-6: Running <span class="literal">VACUUM</span> manually</em></p>
<p class="indent">After you run this command, it should return the message <span class="literal">VACUUM</span> from the server. Now when you fetch statistics again using the query in <a href="ch17.xhtml#ch17list5">Listing 17-5</a>, you should see that the <span class="literal">last_vacuum</span> column reflects the date and time of the manual vacuum you just ran and the number in the <span class="literal">vacuum_count</span> column should increase by one.</p>
<p class="indent">In this example, we executed <span class="literal">VACUUM</span> on our test table. But you can also run <span class="literal">VACUUM</span> on the entire database by omitting the table name. In addition, you can add the <span class="literal">VERBOSE</span> keyword to provide more detailed information, such as the number of rows found in a table and the number of rows removed, among other information.</p>
<h4 class="h4" id="lev309"><em>Reducing Table Size with VACUUM FULL</em></h4>
<p class="noindent">Next, we’ll run <span class="literal">VACUUM</span> with the <span class="literal">FULL</span> option. Unlike the default <span class="literal">VACUUM</span>, which only marks the space held by dead rows as available for future use, the <span class="literal">FULL</span> option returns space back to disk. As mentioned, <span class="literal">VACUUM FULL</span> creates a new version of a table, discarding dead rows in the process. Although this frees space on your system’s disk, there are a couple of caveats to keep in mind. First, <span class="literal">VACUUM FULL</span> takes more time to complete than <span class="literal">VACUUM</span>. Second, it must have exclusive access to the table while rewriting it, which means that no one can update data during the operation. The regular <span class="literal">VACUUM</span> command can run while updates and other operations are happening.</p>
<p class="indent">To see how <span class="literal">VACUUM FULL</span> works, run the command in <a href="ch17.xhtml#ch17list7">Listing 17-7</a>:</p>
<p class="programs">VACUUM FULL vacuum_test;</p>
<p class="listing" id="ch17list7"><em><a href="ch17.xhtml#ch17list7">Listing 17-7</a>: Using <span class="literal">VACUUM FULL</span> to reclaim disk space</em></p>
<p class="indent">After the command executes, test the table size again. It should be back down to 17MB, which is the size it was when we first inserted data.</p>
<p class="indent">It’s never prudent or safe to run out of disk space, so minding the size of your database files as well as your overall system space is a worthwhile routine to establish. Using <span class="literal">VACUUM</span> to prevent database files from growing bigger than they have to is a good start.</p>
<h3 class="h3" id="lev310">Changing Server Settings</h3>
<p class="noindent">It’s possible to alter dozens of settings for your PostgreSQL server by editing values in <em>postgresql.conf</em>, one of several configuration text files that control <span epub:type="pagebreak" id="page_319"/>server settings. Other files include <em>pg_hba.conf</em>, which controls connections to the server, and <em>pg_ident.conf</em>, which database administrators can use to map usernames on a network to usernames in PostgreSQL. See the PostgreSQL documentation on these files for details.</p>
<p class="indent">For our purposes, we’ll use the <em>postgresql.conf</em> file because it contains settings we’re most interested in. Most of the values in the file are set to defaults you won’t ever need to adjust, but it’s worth exploring in case you want to change them to suit your needs. Let’s start with the basics.</p>
<h4 class="h4" id="lev311"><em>Locating and Editing postgresql.conf</em></h4>
<p class="noindentb">Before you can edit <em>postgresql.conf</em>, you’ll need to find its location, which varies depending on your operating system and install method. You can run the command in <a href="ch17.xhtml#ch17list8">Listing 17-8</a> to locate the file:</p>
<p class="programs">SHOW config_file;</p>
<p class="listing" id="ch17list8"><em>Listing 17-8: Showing the location of</em> postgresql.conf</p>
<p class="indent">When I run the command on a Mac, it shows the path to the file as:</p>
<p class="programs">/Users/anthony/Library/Application Support/Postgres/var-10/postgresql.conf</p>
<p class="indent">To edit <em>postgresql.conf</em>, navigate to the directory displayed by <span class="literal">SHOW</span> <span class="literal">config_file;</span> in your system, and open the file using a plain text editor, not a rich text editor like Microsoft Word.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>It’s a good idea to save a copy of</em> postgresql.conf <em>for reference in case you make a change that breaks the system and you need to revert to the original version.</em></p>
</div>
<p class="indent">When you open the file, the first several lines should read as follows:</p>
<p class="programs"># -----------------------------<br/># PostgreSQL configuration file<br/># -----------------------------<br/>#<br/># This file consists of lines of the form:<br/>#<br/>#   name = value</p>
<p class="indent">The <em>postgresql.conf</em> file is organized into sections that specify settings for file locations, security, logging of information, and other processes. Many lines begin with a hash mark (<span class="literal">#</span>), which indicates the line is commented out and the setting shown is the active default.</p>
<p class="indent">For example, in the <em>postgresql.conf</em> file section “Autovacuum Parameters,” the default is for autovacuum to be turned on. The hash mark (<span class="literal">#</span>) in front of the line means that the line is commented out and the default is in effect:</p>
<p class="programs">#autovacuum = on               # Enable autovacuum subprocess? 'on'</p>
<p class="indent"><span epub:type="pagebreak" id="page_320"/>To turn off autovacuum, you remove the hash mark at the beginning of the line and change the value to <span class="literal">off</span>:</p>
<p class="programs">autovacuum = off               # Enable autovacuum subprocess? 'on'</p>
<p class="indent"><a href="ch17.xhtml#ch17list9">Listing 17-9</a> shows some other settings you might want to explore, which are excerpted from the <em>postgresql.conf</em> section “Client Connection Defaults.” Use your text editor to search the file for the following settings.</p>
<p class="programs"><span class="ent">➊</span> datestyle = 'iso, mdy'<br/><br/><span class="ent">➋</span> timezone = 'US/Eastern'<br/><br/><span class="ent">➌</span> default_text_search_config = 'pg_catalog.english'</p>
<p class="listing" id="ch17list9"><em>Listing 17-9: Sample</em> postgresql.conf <em>settings</em></p>
<p class="indent">You can use the <span class="literal">datestyle</span> setting <span class="ent">➊</span> to specify how PostgreSQL displays dates in query results. This setting takes two parameters: the output format and the ordering of month, day, and year. The default for the output format is the ISO format (<span class="codeitalic">YYYY-</span><span class="codeitalic">MM-</span><span class="codeitalic">DD</span>) we’ve used throughout this book, which I recommend you use for cross-national portability. However, you can also use the traditional SQL format (<span class="codeitalic">MM/</span><span class="codeitalic">DD/</span><span class="codeitalic">YYYY</span>), the expanded Postgres format (<span class="literal">Mon Nov 12 22:30:00 2018 EST</span>), or the German format (<span class="codeitalic">DD.</span><span class="codeitalic">MM.</span><span class="codeitalic">YYYY</span>) with dots between the date, month, and year. To specify the format using the second parameter, arrange <span class="literal">m</span>, <span class="literal">d</span>, and <span class="literal">y</span> in the order you prefer.</p>
<p class="indent">The <span class="literal">timezone</span> parameter <span class="ent">➋</span> sets the (you guessed it) server time zone. <a href="ch17.xhtml#ch17list9">Listing 17-9</a> shows the value <span class="literal">US/Eastern</span>, which reflects the time zone on my machine when I installed PostgreSQL. Yours should vary based on your location. When setting up PostgreSQL for use as the backend to a database application or on a network, administrators often set this value to <span class="literal">UTC</span> and use that as a standard on machines across multiple locations.</p>
<p class="indent">The <span class="literal">default_text_search_config</span> value <span class="ent">➌</span> sets the language used by the full text search operations. Here, mine is set to <span class="literal">english</span>. Depending on your needs, you can set this to <span class="literal">spanish</span>, <span class="literal">german</span>, <span class="literal">russian</span>, or another language of your choice.</p>
<p class="indent">These three examples represent only a handful of settings available for adjustment. Unless you end up deep in system tuning, you probably won’t have to tweak much else. Also, use caution when changing settings on a network server used by multiple people or applications; changes can have unintended consequences, so it’s worth communicating with colleagues first.</p>
<p class="indent">After you make changes to <em>postgresql.conf</em>, you must save the file and then reload settings using the <span class="literal">pg_ctl</span> PostgreSQL command to apply the new settings. Let’s look at how to do that next.</p>
<h4 class="h4" id="lev312"><span epub:type="pagebreak" id="page_321"/><em>Reloading Settings with pg_ctl</em></h4>
<p class="noindent">The command line utility <span class="literal">pg_ctl</span> allows you to perform actions on a PostgreSQL server, such as starting and stopping it, and checking its status. Here, we’ll use the utility to reload the settings files so changes we make will take effect. Running the command reloads all settings files at once.</p>
<p class="indent">You’ll need to open and configure a command line prompt the same way you did in <a href="ch16.xhtml#ch16">Chapter 16</a> when you learned how to set up and use <span class="literal">psql</span>. After you launch a command prompt, use one of the following commands to reload:</p>
<ul>
<li class="noindent"><p class="list">On Windows, use:</p>
<p class="programs">pg_ctl reload -D "C:\<em>path\to\data\directory\</em>"</p></li>
<li class="noindent"><p class="list">On macOS or Linux, use:</p>
<p class="programs">pg_ctl reload -D '<em>/path/to/data/directory/</em>'</p></li>
</ul>
<p class="indent">To find the location of your PostgreSQL data directory, run the query in <a href="ch17.xhtml#ch17list10">Listing 17-10</a>:</p>
<p class="programs">SHOW data_directory;</p>
<p class="listing" id="ch17list10"><em>Listing 17-10: Showing the location of the data directory</em></p>
<p class="indent">You place the path between double quotes on Windows and single quotes on macOS or Linux after the <span class="literal">-D</span> argument. You run this command on your system’s command prompt, not inside the <span class="literal">psql</span> application. Enter the command and press <small>ENTER</small>; it should respond with the message <span class="literal">server signaled</span>. The settings files will be reloaded and changes should take effect. Some settings, such as memory allocations, require a restart of the server. PostgreSQL will warn you if that’s the case.</p>
<h3 class="h3" id="lev313">Backing Up and Restoring Your Database</h3>
<p class="noindent">When you cleaned up the “dirty” USDA food producer data in <a href="ch09.xhtml#ch09">Chapter 9</a>, you learned how to create a backup copy of a table. However, depending on your needs, you might want to back up your entire database regularly either for safekeeping or for transferring data to a new or upgraded server. PostgreSQL offers command line tools that make backup and restore operations easy. The next few sections show examples of how to create a backup of a database or a single table, as well as how to restore them.</p>
<h4 class="h4" id="lev314"><em>Using pg_dump to Back Up a Database or Table</em></h4>
<p class="noindent">The PostgreSQL command line tool <span class="literal">pg_dump</span> creates an output file that contains all the data from your database, SQL commands for re-creating tables, and other database objects, as well as loading the data into tables. You can <span epub:type="pagebreak" id="page_322"/>also use <span class="literal">pg_dump</span> to save only selected tables in your database. By default, <span class="literal">pg_dump</span> outputs a plain text file; I’ll discuss a custom compressed format first and then discuss other options.</p>
<p class="indent">To back up the <span class="literal">analysis</span> database we’ve used for our exercises, run the command in <a href="ch17.xhtml#ch17list11">Listing 17-11</a> at your system’s command prompt (not in <span class="literal">psql</span>):</p>
<p class="programs">pg_dump -d analysis -U <em>user_name</em> -Fc &gt; analysis_backup.sql</p>
<p class="listing" id="ch17list11"><em>Listing 17-11: Backing up the <span class="literal">analysis</span> database with <span class="literal">pg_dump</span></em></p>
<p class="indent">Here, we start the command with <span class="literal">pg_dump</span>, the <span class="literal">-d</span> argument, and name of the database to back up, followed by the <span class="literal">-U</span> argument and your username. Next, we use the <span class="literal">-Fc</span> argument to specify that we want to generate this backup in a custom PostgreSQL compressed format. Then we place a greater-than symbol (<span class="literal">&gt;</span>) to redirect the output of <span class="literal">pg_dump</span> to a text file named <em>analysis_backup.sql</em>. To place the file in a directory other than the one your terminal prompt is currently open to, you can specify the complete directory path before the filename.</p>
<p class="indent">When you execute the command by pressing <small>ENTER</small>, depending on your installation, you might see a password prompt. Fill in that password, if prompted. Then, depending on the size of your database, the command could take a few minutes to complete. The operation doesn’t output any messages to the screen while it’s working, but when it’s done, it should return you to a new command prompt and you should see a file named <em>analysis_backup.sql</em> in your current directory.</p>
<p class="indent">To limit the backup to one or more tables that match a particular name, use the <span class="literal">-t</span> argument followed by the name of the table in single quotes. For example, to back up just the <span class="literal">train_rides</span> table, use the following command:</p>
<p class="programs">pg_dump -t 'train_rides' -d analysis -U <em>user_name</em> -Fc &gt; train_backup.sql</p>
<p class="indent">Now let’s look at how to restore a backup, and then we’ll explore additional <span class="literal">pg_dump</span> options.</p>
<h4 class="h4" id="lev315"><em>Restoring a Database Backup with pg_restore</em></h4>
<p class="noindent">After you’ve backed up your database using <span class="literal">pg_dump</span>, it’s very easy to restore it using the <span class="literal">pg_restore</span> utility. You might need to restore your database when migrating data to a new server or when upgrading to a new version of PostgreSQL. To restore the <span class="literal">analysis</span> database (assuming you’re on a server where <span class="literal">analysis</span> doesn’t exist), run the command in <a href="ch17.xhtml#ch17list12">Listing 17-12</a> at the command prompt:</p>
<p class="programs">pg_restore -C -d postgres -U <em>user_name</em> analysis_backup.sql</p>
<p class="listing" id="ch17list12"><em>Listing 17-12: Restoring the <span class="literal">analysis</span> database with <span class="literal">pg_restore</span></em></p>
<p class="indent">After <span class="literal">pg_restore</span>, you add the <span class="literal">-C</span> argument, which tells the utility to create the <span class="literal">analysis</span> database on the server. (It gets the database name from the backup file.) Then, as you saw previously, the <span class="literal">-d</span> argument <span epub:type="pagebreak" id="page_323"/>specifies the name of the database to connect to, followed by the <span class="literal">-U</span> argument and your username. Press <small>ENTER</small> and the restore will begin. When it’s done, you should be able to view your restored database via <span class="literal">psql</span> or in pgAdmin.</p>
<h4 class="h4" id="lev316"><em>Additional Backup and Restore Options</em></h4>
<p class="noindent">You can configure <span class="literal">pg_dump</span> with multiple options to include or exclude certain database objects, such as tables matching a name pattern, or to specify the output format.</p>
<p class="indent">Also, when we backed up the <span class="literal">analysis</span> database in “Using <span class="literal">pg_dump</span> to Back Up a Database or Table” on <a href="ch17.xhtml#page_321">page 321</a>, we specified the <span class="literal">-Fc</span> option with <span class="literal">pg_dump</span> to generate a custom PostgreSQL compressed format. The utility supports additional format options, including plain text. For details, check the full <span class="literal">pg_dump</span> documentation at <em><a href="https://www.postgresql.org/docs/current/static/app-pgdump.html">https://www.postgresql.org/docs/current/static/app-pgdump.html</a></em>. For corresponding restore options, check the <span class="literal">pg_restore</span> documentation at <em><a href="https://www.postgresql.org/docs/current/static/app-pgrestore.html">https://www.postgresql.org/docs/current/static/app-pgrestore.html</a></em>.</p>
<h3 class="h3" id="lev317">Wrapping Up</h3>
<p class="noindent">In this chapter, you learned how to track and conserve space in your databases using the <span class="literal">VACUUM</span> feature in PostgreSQL. You also learned how to change system settings as well as back up and restore databases using other command line tools. You may not need to perform these tasks every day, but the maintenance tricks you learned here can help enhance the performance of your databases. Note that this is not a comprehensive overview of the topic; see the Appendix for more resources on database maintenance.</p>
<p class="indent">In the next and final chapter of this book, I’ll share guidelines for identifying hidden trends and telling an effective story using your data.</p>
<div class="sidebar" id="ch17sb1">
<p class="sidebart"><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Using the techniques you learned in this chapter, back up and restore the <span class="literal">gis_analysis</span> database you made in <a href="ch14.xhtml#ch14">Chapter 14</a>. After you back up the full database, you’ll need to delete the original to be able to restore it. You might also try backing up and restoring individual tables.</p>
<p class="spara1">In addition, use a text editor to explore the backup file created by <span class="literal">pg_dump</span>. Examine how it organizes the statements to create objects and insert data.<span epub:type="pagebreak" id="page_324"/></p>
</div>
</body>
</html>