<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_55"/><strong><span class="big">5</span></strong><br/><strong>BASIC MATH AND STATS WITH SQL</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">If your data includes any of the number data types we explored in <a href="ch03.xhtml#ch03">Chapter 3</a>—integers, decimals, or floating points—sooner or later your analysis will include some calculations. For example, you might want to know the average of all the dollar values in a column, or add values in two columns to produce a total for each row. SQL handles calculations ranging from basic math through advanced statistics.</p>
<p class="indent">In this chapter, I’ll start with the basics and progress to math functions and beginning statistics. I’ll also discuss calculations related to percentages and percent change. For several of the exercises, we’ll use the 2010 Decennial Census data you imported in <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>
<h3 class="h3" id="lev63"><span epub:type="pagebreak" id="page_56"/>Math Operators</h3>
<p class="noindent">Let’s start with the basic math you learned in grade school (and all’s forgiven if you’ve forgotten some of it). <a href="ch05.xhtml#ch05tab1">Table 5-1</a> shows nine math operators you’ll use most often in your calculations. The first four (addition, subtraction, multiplication, and division) are part of the ANSI SQL standard that are implemented in all database systems. The others are PostgreSQL-specific operators, although if you’re using another database, it likely has functions or operators to perform those operations. For example, the modulo operator (<span class="literal">%</span>) works in Microsoft SQL Server and MySQL as well as with PostgreSQL. If you’re using another database system, check its documentation.</p>
<p class="tabcap" id="ch05tab1"><strong>Table 5-1:</strong> Basic Math Operators</p>
<table class="topbot-d">
<thead>
<tr>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Operator</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">+</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Addition</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">-</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Subtraction</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">*</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Multiplication</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">/</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Division (returns the quotient only, no remainder)</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">%</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Modulo (returns just the remainder)</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">^</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Exponentiation</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">|/</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Square root</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">||/</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Cube root</p></td>
</tr>
<tr>
<td class="table-ca" style="vertical-align: top;"><p class="taba"><span class="literal">!</span></p></td>
<td class="table-ca" style="vertical-align: top;"><p class="taba">Factorial</p></td>
</tr>
</tbody>
</table>
<p class="indent">We’ll step through each of these operators by executing simple SQL queries on plain numbers rather than operating on a table or another database object. You can either enter the statements separately into the pgAdmin query tool and execute them one at a time, or if you copied the code for this chapter from the resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>, you can highlight each line before executing it.</p>
<h4 class="h4" id="lev64"><em>Math and Data Types</em></h4>
<p class="noindent">As you work through the examples, note the data type of each result, which is listed beneath each column name in the pgAdmin results grid. The type returned for a calculation will vary depending on the operation and the data type of the input numbers.</p>
<p class="indent">In calculations with an operator between two numbers—addition, subtraction, multiplication, and division—the data type returned follows this pattern:</p>
<ul>
<li class="noindent">Two integers return an <span class="literal">integer</span>.</li>
<li class="noindent">A <span class="literal">numeric</span> on either side of the operator returns a <span class="literal">numeric</span>.</li>
<li class="noindent">Anything with a floating-point number returns a floating-point number of type <span class="literal">double precision</span>.</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_57"/>However, the exponentiation, root, and factorial functions are different. Each takes one number either before or after the operator and returns numeric and floating-point types, even when the input is an integer.</p>
<p class="indent">Sometimes the result’s data type will suit your needs; other times, you may need to use <span class="literal">CAST</span> to change the data type, as mentioned in <a href="ch03.xhtml#lev44">“Transforming Values from One Type to Another with <span class="literal">CAST</span>”</a> on <a href="ch03.xhtml#page_35">page 35</a>, such as if you need to feed the result into a function that takes a certain type. I’ll note those times as we work through the book.</p>
<h4 class="h4" id="lev65"><em>Adding, Subtracting, and Multiplying</em></h4>
<p class="noindent">Let’s start with simple integer addition, subtraction, and multiplication. <a href="ch05.xhtml#ch05list1">Listing 5-1</a> shows three examples, each with the <span class="literal">SELECT</span> keyword followed by the math formula. Since <a href="ch02.xhtml#ch02">Chapter 2</a>, we’ve used <span class="literal">SELECT</span> for its main purpose: to retrieve data from a table. But with PostgreSQL, Microsoft’s SQL Server, MySQL, and some other database management systems, it’s possible to omit the table name for math and string operations while testing, as we do here. For readability’s sake, I recommend you use a single space before and after the math operator; although using spaces isn’t strictly necessary for your code to work, it is good practice.</p>
<p class="programs"><span class="ent">➊</span> SELECT 2 + 2;<br/><span class="ent">➋</span> SELECT 9 - 1;<br/><span class="ent">➌</span> SELECT 3 * 4;</p>
<p class="listing" id="ch05list1"><em>Listing 5-1: Basic addition, subtraction, and multiplication with SQL</em></p>
<p class="indent">None of these statements are rocket science, so you shouldn’t be surprised that running <span class="literal">SELECT 2 + 2;</span> <span class="ent">➊</span> in the query tool shows a result of <span class="literal">4</span>. Similarly, the examples for subtraction <span class="ent">➋</span> and multiplication <span class="ent">➌</span> yield what you’d expect: <span class="literal">8</span> and <span class="literal">12</span>. The output displays in a column, as with any query result. But because we’re not querying a table and specifying a column, the results appear beneath a <span class="literal">?column?</span> name, signifying an unknown column:</p>
<p class="programs">?column?<br/>--------<br/>       4</p>
<p class="indent">That’s okay. We’re not affecting any data in a table, just displaying a result.</p>
<h4 class="h4" id="lev66"><em>Division and Modulo</em></h4>
<p class="noindent">Division with SQL gets a little trickier because of the difference between math with integers and math with decimals, which was mentioned earlier. Add in <em>modulo</em>, an operator that returns just the <em>remainder</em> in a division operation, and the results can be confusing. So, to make it clear, <a href="ch05.xhtml#ch05list2">Listing 5-2</a> shows four examples:</p>
<p class="programs"><span class="ent">➊</span> SELECT 11 / 6;<br/><span class="ent">➋</span> SELECT 11 % 6;<br/><span epub:type="pagebreak" id="page_58"/><span class="ent">➌</span> SELECT 11.0 / 6;<br/><span class="ent">➍</span> SELECT CAST (11 AS numeric(3,1)) / 6;</p>
<p class="listing" id="ch05list2"><em>Listing 5-2: Integer and decimal division with SQL</em></p>
<p class="indent">The first statement uses the <span class="literal">/</span> operator <span class="ent">➊</span> to divide the integer <span class="literal">11</span> by another integer, <span class="literal">6</span>. If you do that math in your head, you know the answer is <span class="literal">1</span> with a remainder of <span class="literal">5</span>. However, running this query yields <span class="literal">1</span>, which is how SQL handles division of one integer by another—by reporting only the integer <em>quotient</em>. If you want to retrieve the <em>remainder</em> as an integer, you must perform the same calculation using the modulo operator <span class="literal">%</span>, as in <span class="ent">➋</span>. That statement returns just the remainder, in this case <span class="literal">5</span>. No single operation will provide you with both the quotient and the remainder as integers.</p>
<p class="indent">Modulo is useful for more than just fetching a remainder: you can also use it as a test condition. For example, to check whether a number is even, you can test it using the <span class="literal">% 2</span> operation. If the result is <span class="literal">0</span> with no remainder, the number is even.</p>
<p class="indent">If you want to divide two numbers and have the result return as a <span class="literal">numeric</span> type, you can do so in two ways: first, if one or both of the numbers is a <span class="literal">numeric</span>, the result will by default be expressed as a <span class="literal">numeric</span>. That’s what happens when I divide <span class="literal">11.0</span> by <span class="literal">6</span> <span class="ent">➌</span>. Execute that query, and the result is <span class="literal">1.83333</span>. The number of decimal digits displayed may vary according to your PostgreSQL and system settings.</p>
<p class="indent">Second, if you’re working with data stored only as integers and need to force decimal division, you can <span class="literal">CAST</span> one of the integers to a <span class="literal">numeric</span> type <span class="ent">➍</span>. Executing this again returns <span class="literal">1.83333</span>.</p>
<h4 class="h4" id="lev67"><em>Exponents, Roots, and Factorials</em></h4>
<p class="noindent">Beyond the basics, PostgreSQL-flavored SQL also provides operators to square, cube, or otherwise raise a base number to an exponent, as well as find roots or the factorial of a number. <a href="ch05.xhtml#ch05list3">Listing 5-3</a> shows these operations in action:</p>
<p class="programs"><span class="ent">➊</span> SELECT 3 ^ 4;<br/><span class="ent">➋</span> SELECT |/ 10;<br/>  SELECT sqrt(10);<br/><span class="ent">➌</span> SELECT ||/ 10;<br/><span class="ent">➍</span> SELECT 4 !;</p>
<p class="listing" id="ch05list3"><em>Listing 5-3: Exponents, roots, and factorials with SQL</em></p>
<p class="indent">The exponentiation operator (<span class="literal">^</span>) allows you to raise a given base number to an exponent, as in <span class="ent">➊</span>, where <span class="literal">3 ^ 4</span> (colloquially, we’d call that three to the fourth power) returns <span class="literal">81</span>.</p>
<p class="indent">You can find the square root of a number in two ways: using the <span class="literal">|/</span> operator <span class="ent">➋</span> or the <span class="literal">sqrt(</span><span class="codeitalic">n</span><span class="literal">)</span> function. For a cube root, use the <span class="literal">||/</span> operator <span class="ent">➌</span>. Both are <em>prefix operators</em>, named because they come before a single value.</p>
<p class="indent"><span epub:type="pagebreak" id="page_59"/>To find the <em>factorial</em> of a number, use the <span class="literal">!</span> operator. It’s a <em>suffix operator</em>, coming after a single value. You’ll use factorials in many places in math, but perhaps the most common is to determine how many ways a number of items can be ordered. Say you have four photographs. How many ways could you order them next to each other on a wall? To find the answer, you’d calculate the factorial by starting with the number of items and multi­plying all the smaller positive integers. So, at <span class="ent">➍</span>, the factorial statement of <span class="literal">4 !</span> is equivalent to 4 × 3 × 2 × 1. That’s 24 ways to order four photos. No wonder decorating takes so long sometimes!</p>
<p class="indent">Again, these operators are specific to PostgreSQL; they’re not part of the SQL standard. If you’re using another database application, check its documentation for how it implements these operations.</p>
<h4 class="h4" id="lev68"><em>Minding the Order of Operations</em></h4>
<p class="noindent">Can you recall from your earliest math lessons what the order of operations, or <em>operator precedence</em>, is on a mathematical expression? When you string together several numbers and operators, which calculations does SQL execute first? Not surprisingly, SQL follows the established math standard. For the PostgreSQL operators discussed so far, the order is:</p>
<ol>
<li class="noindent"><p class="list">Exponents and roots</p></li>
<li class="noindent"><p class="list">Multiplication, division, modulo</p></li>
<li class="noindent"><p class="list">Addition and subtraction</p></li>
</ol>
<p class="indent">Given these rules, you’ll need to encase an operation in parentheses if you want to calculate it in a different order. For example, the following two expressions yield different results:</p>
<p class="programs">SELECT 7 + 8 * 9;<br/>SELECT (7 + 8) * 9;</p>
<p class="indent">The first expression returns <span class="literal">79</span> because the multiplication operation receives precedence and is processed before the addition. The second returns <span class="literal">135</span> because the parentheses force the addition operation to occur first.</p>
<p class="indent">Here’s a second example using exponents:</p>
<p class="programs">SELECT 3 ^ 3 - 1;<br/>SELECT 3 ^ (3 - 1);</p>
<p class="indent">Exponent operations take precedence over subtraction, so without parentheses the entire expression is evaluated left to right and the operation to find 3 to the power of 3 happens first. Then 1 is subtracted, returning <span class="literal">26</span>. In the second example, the parentheses force the subtraction to happen first, so the operation results in <span class="literal">9</span>, which is 3 to the power of 2.</p>
<p class="indent">Keep operator precedence in mind to avoid having to correct your analysis later!</p>
<h3 class="h3" id="lev69"><span epub:type="pagebreak" id="page_60"/>Doing Math Across Census Table Columns</h3>
<p class="noindent">Let’s try to use the most frequently used SQL math operators on real data by digging into the 2010 Decennial Census population table, <span class="literal">us_counties_2010</span>, that you imported in <a href="ch04.xhtml#ch04">Chapter 4</a>. Instead of using numbers in queries, we’ll use the names of the columns that contain the numbers. When we execute the query, the calculation will occur on each row of the table.</p>
<p class="indent">To refresh your memory about the data, run the script in <a href="ch05.xhtml#ch05list4">Listing 5-4</a>. It should return 3,143 rows showing the name and state of each county in the United States, and the number of people who identified with one of six race categories or a combination of two or more races.</p>
<p class="indent">The 2010 Census form received by each household—the so-called “short form”—allowed people to check either just one or multiple boxes under the question of race. (You can review the form at <em><a href="https://www.census.gov/2010census/pdf/2010_Questionnaire_Info.pdf">https://www.census.gov/2010census/pdf/2010_Questionnaire_Info.pdf</a></em>.) People who checked one box were counted in categories such as “White Alone” or “Black or African American Alone.” Respondents who selected more than one box were tabulated in the overall category of “Two or More Races,” and the census data set breaks those down in detail.</p>
<p class="programs">SELECT geo_name,<br/>       state_us_abbreviation AS "st",<br/>       p0010001 AS<span class="ent">➊</span> "Total Population",<br/>       p0010003 AS "White Alone",<br/>       p0010004 AS "Black or African American Alone",<br/>       p0010005 AS "Am Indian/Alaska Native Alone",<br/>       p0010006 AS "Asian Alone",<br/>       p0010007 AS "Native Hawaiian and Other Pacific Islander Alone",<br/>       p0010008 AS "Some Other Race Alone",<br/>       p0010009 AS "Two or More Races"<br/>FROM us_counties_2010;</p>
<p class="listing" id="ch05list4"><em>Listing 5-4: Selecting census population columns by race with aliases</em></p>
<p class="indent">In <span class="literal">us_counties_2010</span>, each race and household data column contains a census code. For example, the “Asian Alone” column is reported as <span class="literal">p0010006</span>. Although those codes might be economical and compact, they make it difficult to understand which column is which when the query returns with just that code. In <a href="ch05.xhtml#ch05list4">Listing 5-4</a>, I employ a little trick to clarify the output by using the <span class="literal">AS</span> keyword <span class="ent">➊</span> to give each column a more readable alias in the result set. We could rename all the columns upon import, but with the census it’s best to use the code to refer to the same column names in the documentation if needed.</p>
<h4 class="h4" id="lev70"><em>Adding and Subtracting Columns</em></h4>
<p class="noindent">Now, let’s try a simple calculation on two of the race columns in <a href="ch05.xhtml#ch05list5">Listing 5-5</a>, adding the number of people who identified as white alone or black alone in each county.</p>
<p class="programs"><span epub:type="pagebreak" id="page_61"/>  SELECT geo_name,<br/>         state_us_abbreviation AS "st",<br/>         p0010003 AS "White Alone",<br/>         p0010004 AS "Black Alone",<br/><span class="ent">➊</span>        p0010003 + p0010004 AS "Total White and Black"<br/>  FROM us_counties_2010;</p>
<p class="listing" id="ch05list5"><em>Listing 5-5: Adding two columns in <span class="literal">us_counties_2010</span></em></p>
<p class="indent">Providing <span class="literal">p0010003 + p0010004</span> <span class="ent">➊</span> as one of the columns in the <span class="literal">SELECT</span> statement handles the calculation. Again, I use the <span class="literal">AS</span> keyword to provide a readable alias for the column. If you don’t provide an alias, PostgreSQL uses the label <span class="literal">?column?</span>, which is far less than helpful.</p>
<p class="indent">Run the query to see the results. The first few rows should resemble this output:</p>
<div class="image"><img alt="image" src="../images/prog_page_61.jpg"/></div>
<p class="indent">A quick check with a calculator or pencil and paper confirms that the total column equals the sum of the columns you added. Excellent!</p>
<p class="indent">Now, let’s build on this to test our data and validate that we imported columns correctly. The six race “Alone” columns plus the “Two or More Races” column should add up to the same number as the total population. The code in <a href="ch05.xhtml#ch05list6">Listing 5-6</a> should show that it does:</p>
<p class="programs">  SELECT geo_name,<br/>         state_us_abbreviation AS "st",<br/>       <span class="ent">➊</span> p0010001 AS "Total",<br/>       <span class="ent">➋</span> p0010003 + p0010004 + p0010005 + p0010006 + p0010007<br/>              + p0010008 + p0010009 AS "All Races",<br/>       <span class="ent">➌</span> (p0010003 + p0010004 + p0010005 + p0010006 + p0010007<br/>              + p0010008 + p0010009) - p0010001 AS "Difference"<br/>  FROM us_counties_2010<br/><span class="ent">➍</span> ORDER BY "Difference" DESC;</p>
<p class="listing" id="ch05list6"><em>Listing 5-6: Checking census data totals</em></p>
<p class="indent">This query includes the population total <span class="ent">➊</span>, followed by a calculation adding the seven race columns as <span class="literal">All Races</span> <span class="ent">➋</span>. The population total and the races total should be identical, but rather than manually check, we also add a column that subtracts the population total column from the sum of the race columns <span class="ent">➌</span>. That column, named <span class="literal">Difference</span>, should contain a zero in each row if all the data is in the right place. To avoid having to scan all 3,143 rows, we add an <span class="literal">ORDER BY</span> clause <span class="ent">➍</span> on the named column. Any rows showing a difference should appear at the top or bottom of the query result.</p>
<p class="indent"><span epub:type="pagebreak" id="page_62"/>Run the query; the first few rows should provide this result:</p>
<p class="programs">geo_name           st     Total      All Races     Difference<br/>--------------     --     ------     ---------     ----------<br/>Autauga County     AL      54571         54571              0<br/>Baldwin County     AL     182265        182265              0<br/>Barbour County     AL      27457         27457              0</p>
<p class="indent">With the <span class="literal">Difference</span> column showing zeros, we can be confident that our import was clean. Whenever I encounter or import a new data set, I like to perform little tests like this. They help me better understand the data and head off any potential issues before I dig into analysis.</p>
<h4 class="h4" id="lev71"><em>Finding Percentages of the Whole</em></h4>
<p class="noindent">Let’s dig deeper into the census data to find meaningful differences in the population demographics of the counties. One way to do this (with any data set, in fact) is to calculate what percentage of the whole a particular variable represents. With the census data, we can learn a lot by comparing percentages from county to county and also by examining how percentages vary over time.</p>
<p class="indent">To figure out the percentage of the whole, divide the number in question by the total. For example, if you had a basket of 12 apples and used 9 in a pie, that would be 9 / 12 or .75—commonly expressed as 75 percent.</p>
<p class="indent">To try this on the census counties data, use the code in <a href="ch05.xhtml#ch05list7">Listing 5-7</a>, which calculates for each county the percentage of the population that reported their race as Asian:</p>
<p class="programs">SELECT geo_name,<br/>       state_us_abbreviation AS "st",<br/>       (CAST <span class="ent">➊</span>(p0010006 AS numeric(8,1)) / p0010001) * 100 AS "pct_asian"<br/>FROM us_counties_2010<br/>ORDER BY "pct_asian" DESC;</p>
<p class="listing" id="ch05list7"><em>Listing 5-7: Calculating the percentage of the population that is Asian by county</em></p>
<p class="indent">The key piece of this query divides <span class="literal">p0010006</span>, the column with the count of Asian alone, by <span class="literal">p0010001</span>, the column for total population <span class="ent">➊</span>.</p>
<p class="indent">If we use the data as their original integer types, we won’t get the fractional result we need: every row will display a result of 0, the quotient. Instead, we force decimal division by using <span class="literal">CAST</span> on one of the integers. The last part multiplies the result by 100 to present the result as a fraction of 100—the way most people understand percentages.</p>
<p class="indent">By sorting from highest to lowest percentage, the top of the output is as follows:</p>
<p class="programs">geo_name                       st     pct_asian<br/>--------------------------     --     -----------------------<br/>Honolulu County                HI     43.89497769109962474000<br/>Aleutians East Borough         AK     35.97580388411333970100<br/>San Francisco County           CA     33.27165361664607226500<br/><span epub:type="pagebreak" id="page_63"/>Santa Clara County             CA     32.02237037519322063600<br/>Kauai County                   HI     31.32461880132953749400<br/>Aleutians West Census Area     AK     28.87969789606185937800</p>
<h4 class="h4" id="lev72"><em>Tracking Percent Change</em></h4>
<p class="noindent">Another key indicator in data analysis is percent change: how much bigger, or smaller, is one number than another? Percent change calculations are often employed when analyzing change over time, and they’re particularly useful for comparing change among similar items.</p>
<p class="indent">Some examples include:</p>
<ul>
<li class="noindent">The year-over-year change in the number of vehicles sold by each automobile maker.</li>
<li class="noindent">The monthly change in subscriptions to each email list owned by a marketing firm.</li>
<li class="noindent">The annual increase or decrease in enrollment at schools across the nation.</li>
</ul>
<p class="indent">The formula to calculate percent change can be expressed like this:</p>
<p class="center">(<em>new number</em> – <em>old number</em>) / <em>old number</em></p>
<p class="indent">So, if you own a lemonade stand and sold 73 glasses of lemonade today and 59 glasses yesterday, you’d figure the day-to-day percent change like this:</p>
<p class="center">(73 – 59) / 59 = .237 = 23.7%</p>
<p class="indent">Let’s try this with a small collection of test data related to spending in departments of a hypothetical local government. <a href="ch05.xhtml#ch05list8">Listing 5-8</a> calculates which departments had the greatest percentage increase and loss:</p>
<p class="programs"><span class="ent">➊</span> CREATE TABLE percent_change (<br/>      department varchar(20),<br/>      spend_2014 numeric(10,2),<br/>      spend_2017 numeric(10,2)<br/>  );<br/><br/><span class="ent">➋</span> INSERT INTO percent_change<br/>  VALUES<br/>      ('Building', 250000, 289000),<br/>      ('Assessor', 178556, 179500),<br/>      ('Library', 87777, 90001),<br/>      ('Clerk', 451980, 650000),<br/>      ('Police', 250000, 223000),<br/>      ('Recreation', 199000, 195000);<br/><br/>  SELECT department,<br/>         spend_2014,<br/>         spend_2017,<br/><span epub:type="pagebreak" id="page_64"/>       <span class="ent">➌</span> round( (spend_2017 - spend_2014) /<br/>                      spend_2014 * 100, 1) AS "pct_change"<br/>  FROM percent_change;</p>
<p class="listing" id="ch05list8"><em>Listing 5-8: Calculating percent change</em></p>
<p class="indent"><a href="ch05.xhtml#ch05list8">Listing 5-8</a> creates a small table called <span class="literal">percent_change</span> <span class="ent">➊</span> and inserts six rows <span class="ent">➋</span> with data on department spending for the years 2014 and 2017. The percent change formula <span class="ent">➌</span> subtracts <span class="literal">spend_2014</span> from <span class="literal">spend_2017</span> and then divides by <span class="literal">spend_2014</span>. We multiply by 100 to express the result as a portion of 100.</p>
<p class="indent">To simplify the output, this time I’ve added the <span class="literal">round()</span> function to remove all but one decimal place. The function takes two arguments: the column or expression to be rounded, and the number of decimal places to display. Because both numbers are type <span class="literal">numeric</span>, the result will also be a <span class="literal">numeric</span>.</p>
<p class="indent">The script creates this result:</p>
<p class="programs"><br/>department     spend_2014     spend_2017     pct_change<br/>----------     ----------     ----------     ----------<br/>Building        250000.00      289000.00           15.6<br/>Assessor        178556.00      179500.00            0.5<br/>Library          87777.00       90001.00            2.5<br/>Clerk           451980.00      650000.00           43.8<br/>Police          250000.00      223000.00          -10.8<br/>Recreation      199000.00      195000.00           -2.0</p>
<p class="indent">Now, it’s just a matter of finding out why the Clerk department’s spending has outpaced others in the town.</p>
<h3 class="h3" id="lev73">Aggregate Functions for Averages and Sums</h3>
<p class="noindent">So far, we’ve performed math operations across columns in each row of a table. SQL also lets you calculate a result from values within the same column using <em>aggregate functions</em>. You can see a full list of PostgreSQL aggregates, which calculate a single result from multiple inputs, at <em><a href="https://www.postgresql.org/docs/current/static/functions-aggregate.html">https://www.postgresql.org/docs/current/static/functions-aggregate.html</a></em>. Two of the most-used aggregate functions in data analysis are <span class="literal">avg()</span> and <span class="literal">sum()</span>.</p>
<p class="indent">Returning to the <span class="literal">us_counties_2010</span> census table, it’s reasonable to want to calculate the total population of all counties plus the average population of all counties. Using <span class="literal">avg()</span> and <span class="literal">sum()</span> on column <span class="literal">p0010001</span> (the total population) makes it easy, as shown in <a href="ch05.xhtml#ch05list9">Listing 5-9</a>. Again, we use the <span class="literal">round()</span> function to remove numbers after the decimal point in the average calculation.</p>
<p class="programs">SELECT sum(p0010001) AS "County Sum",<br/>       round(avg(p0010001), 0) AS "County Average"<br/>FROM us_counties_2010;</p>
<p class="listing" id="ch05list9"><em>Listing 5-9: Using the <span class="literal">sum()</span> and <span class="literal">avg()</span> aggregate functions</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_65"/>This calculation produces the following result:</p>
<p class="programs">County Sum     County Average<br/>----------     --------------<br/> 308745538              98233</p>
<p class="indent">The population for all counties in the United States in 2010 added up to approximately 308.7 million, and the average county population was 98,233.</p>
<h3 class="h3" id="lev74">Finding the Median</h3>
<p class="noindent">The <em>median</em> value in a set of numbers is as important an indicator, if not more so, than the average. Here’s the difference between median and average, and why median matters:</p>
<p class="hang"><strong>Average</strong> The sum of all the values divided by the number of values</p>
<p class="hang"><strong>Median</strong> The “middle” value in an ordered set of values</p>
<p class="indentt">Why is median important for data analysis? Consider this example: let’s say six kids, ages 10, 11, 10, 9, 13, and 12, go on a field trip. It’s easy to add the ages and divide by six to get the group’s average age:</p>
<p class="center">(10 + 11 + 10 + 9 + 13 + 12) / 6 = 10.8</p>
<p class="indent">Because the ages are within a narrow range, the 10.8 average is a good representation of the group. But averages are less helpful when the values are bunched, or skewed, toward one end of the distribution, or if the group includes outliers.</p>
<p class="indent">For example, what if an older chaperone joins the field trip? With ages of 10, 11, 10, 9, 13, 12, and 46, the average age increases considerably:</p>
<p class="center">(10 + 11 + 10 + 9 + 13 + 12 + 46) / 7 = 15.9</p>
<p class="indent">Now the average doesn’t represent the group well because the outlier skews it, making it an unreliable indicator.</p>
<p class="indent">This is where medians shine. The median is the midpoint in an ordered list of values—the point at which half the values are more and half are less. Using the field trip, we order the attendees’ ages from lowest to highest:</p>
<p class="center">9, 10, 10, 11, 12, 13, 46</p>
<p class="indent">The middle (median) value is 11. Half the values are higher, and half are lower. Given this group, the median of 11 is a better picture of the typical age than the average of 15.9.</p>
<p class="indent">If the set of values is an even number, you average the two middle numbers to find the median. Let’s add another student (age 12) to the field trip:</p>
<p class="center">9, 10, 10, 11, 12, 12, 13, 46</p>
<p class="indent"><span epub:type="pagebreak" id="page_66"/>Now, the two middle values are 11 and 12. To find the median, we average them: 11.5.</p>
<p class="indent">Medians are reported frequently in financial news. Reports on housing prices often use medians because a few sales of McMansions in a ZIP Code that is otherwise modest can make averages useless. The same goes for sports player salaries: one or two superstars can skew a team’s average.</p>
<p class="indent">A good test is to calculate the average and the median for a group of values. If they’re close, the group is probably normally distributed (the familiar bell curve), and the average is useful. If they’re far apart, the values are not normally distributed and the median is the better representation.</p>
<h4 class="h4" id="lev75"><em>Finding the Median with Percentile Functions</em></h4>
<p class="noindent">PostgreSQL (as with most relational databases) does not have a built-in <span class="literal">median()</span> function, similar to what you’d find in Excel or other spreadsheet programs. It’s also not included in the ANSI SQL standard. But we can use a SQL <em>percentile</em> function to find the median as well as other <em>quantiles</em> or <em>cut points</em>, which are the points that divide a group of numbers into equal sizes. Percentile functions are part of standard ANSI SQL.</p>
<p class="indent">In statistics, percentiles indicate the point in an ordered set of data below which a certain percentage of the data is found. For example, a doctor might tell you that your height places you in the 60th percentile for an adult in your age group. That means 60 percent of people are your height or shorter.</p>
<p class="indent">The median is equivalent to the 50th percentile—again, half the values are below and half above. SQL’s percentile functions allow us to calculate that easily, although we have to pay attention to a difference in how the two versions of the function—<span class="literal">percentile_cont(</span><span class="codeitalic">n</span><span class="literal">)</span> and <span class="literal">percentile_disc(</span><span class="codeitalic">n</span><span class="literal">)</span>—handle calculations. Both functions are part of the ANSI SQL standard and are present in PostgreSQL, Microsoft SQL Server, and other databases.</p>
<p class="indent">The <span class="literal">percentile_cont(</span><span class="codeitalic">n</span><span class="literal">)</span> function calculates percentiles as <em>continuous</em> values. That is, the result does not have to be one of the numbers in the data set but can be a decimal value in between two of the numbers. This follows the methodology for calculating medians on an even number of values, where the median is the average of the two middle numbers. On the other hand, <span class="literal">percentile_disc(</span><span class="codeitalic">n</span><span class="literal">)</span> returns only <em>discrete</em> values. That is, the result returned will be rounded to one of the numbers in the set.</p>
<p class="indent">To make this distinction clear, let’s use <a href="ch05.xhtml#ch05list10">Listing 5-10</a> to make a test table and fill in six numbers.</p>
<p class="programs">CREATE TABLE percentile_test (<br/>    numbers integer<br/>);<br/><br/>INSERT INTO percentile_test (numbers) VALUES<br/>    (1), (2), (3), (4), (5), (6);<br/><br/>SELECT<br/>  <span class="ent">➊</span> percentile_cont(.5)<br/>    WITHIN GROUP (ORDER BY numbers),<br/>  <span class="ent">➋</span> percentile_disc(.5)<br/><span epub:type="pagebreak" id="page_67"/>    WITHIN GROUP (ORDER BY numbers)<br/>FROM percentile_test;</p>
<p class="listing" id="ch05list10"><em>Listing 5-10: Testing SQL percentile functions</em></p>
<p class="indent">In both the continuous <span class="ent">➊</span> and discrete <span class="ent">➋</span> percentile functions, we enter <span class="literal">.5</span> to represent the 50th percentile, which is equivalent to the median. Running the code returns the following:</p>
<p class="programs">percentile_cont     percentile_disc<br/>---------------     ---------------<br/>            3.5                   3</p>
<p class="indent">The <span class="literal">percentile_cont()</span> function returned what we’d expect the median to be: <span class="literal">3.5</span>. But because <span class="literal">percentile_disc()</span> calculates discrete values, it reports <span class="literal">3</span>, the last value in the first 50 percent of the numbers. Because the accepted method of calculating medians is to average the two middle values in an even-numbered set, use <span class="literal">percentile_cont(.5)</span> to find a median.</p>
<h4 class="h4" id="lev76"><em>Median and Percentiles with Census Data</em></h4>
<p class="noindent">Our census data can show how a median tells a different story than an average. <a href="ch05.xhtml#ch05list11">Listing 5-11</a> adds <span class="literal">percentile_cont()</span> alongside the <span class="literal">sum()</span> and <span class="literal">avg()</span> aggregates we’ve used so far:</p>
<p class="programs">SELECT sum(p0010001) AS "County Sum",<br/>       round(avg(p0010001), 0) AS "County Average",<br/>       percentile_cont(.5)<br/>       WITHIN GROUP (ORDER BY p0010001) AS "County Median"<br/>FROM us_counties_2010;</p>
<p class="listing" id="ch05list11"><em>Listing 5-11: Using <span class="literal">sum()</span>, <span class="literal">avg()</span>, and <span class="literal">percentile_cont()</span> aggregate functions</em></p>
<p class="indent">Your result should equal the following:</p>
<p class="programs">County Sum     County Average     County Median<br/>----------     --------------     -------------<br/> 308745538              98233             25857</p>
<p class="indent">The median and average are far apart, which shows that averages can mislead. As of 2010, half the counties in America had fewer than 25,857 people, whereas half had more. If you gave a presentation on U.S. demographics and told the audience that the “average county in America had 98,200 people,” they’d walk away with a skewed picture of reality. Nearly 40 counties had a million or more people as of the 2010 Decennial Census, and Los Angeles County had close to 10 million. That pushes the average higher.</p>
<h4 class="h4" id="lev77"><em>Finding Other Quantiles with Percentile Functions</em></h4>
<p class="noindent">You can also slice data into smaller equal groups. Most common are <em>quartiles</em> (four equal groups), <em>quintiles</em> (five groups), and <em>deciles</em> (10 groups). To <span epub:type="pagebreak" id="page_68"/>find any individual value, you can just plug it into a percentile function. For example, to find the value marking the first quartile, or the lowest 25 percent of data, you’d use a value of <span class="literal">.25</span>:</p>
<p class="programs">percentile_cont(.25)</p>
<p class="indent">However, entering values one at a time is laborious if you want to generate multiple cut points. Instead, you can pass values into <span class="literal">percentile_cont()</span> using an <em>array</em>, a SQL data type that contains a list of items. <a href="ch05.xhtml#ch05list12">Listing 5-12</a> shows how to calculate all four quartiles at once:</p>
<p class="programs">SELECT percentile_cont(<span class="ent">➊</span>array[.25,.5,.75])<br/>       WITHIN GROUP (ORDER BY p0010001) AS "quartiles"<br/>FROM us_counties_2010;</p>
<p class="listing" id="ch05list12"><em>Listing 5-12: Passing an array of values to <span class="literal">percentile_cont()</span></em></p>
<p class="indent">In this example, we create an array of cut points by enclosing values in a <em>constructor</em> <span class="ent">➊</span> called <span class="literal">array[]</span>. Inside the square brackets, we provide comma-separated values representing the three points at which to cut to create four quartiles. Run the query, and you should see this output:</p>
<p class="programs">quartiles<br/>---------------------<br/>{11104.5,25857,66699}</p>
<p class="indent">Because we passed in an array, PostgreSQL returns an array, denoted by curly brackets. Each quartile is separated by commas. The first quartile is 11,104.5, which means 25 percent of counties have a population that is equal to or lower than this value. The second quartile is the same as the median: 25,857. The third quartile is 66,699, meaning the largest 25 percent of counties have at least this large of a population.</p>
<p class="indent">Arrays come with a host of functions (noted for PostgreSQL at <em><a href="https://www.postgresql.org/docs/current/static/functions-array.html">https://www.postgresql.org/docs/current/static/functions-array.html</a></em>) that allow you to perform tasks such as adding or removing values or counting the elements. A handy function for working with the result returned in <a href="ch05.xhtml#ch05list12">Listing 5-12</a> is <span class="literal">unnest()</span>, which makes the array easier to read by turning it into rows. <a href="ch05.xhtml#ch05list13">Listing 5-13</a> shows the code:</p>
<p class="programs">SELECT unnest(<br/>            percentile_cont(array[.25,.5,.75])<br/>            WITHIN GROUP (ORDER BY p0010001)<br/>            ) AS "quartiles"<br/>FROM us_counties_2010;</p>
<p class="listing" id="ch05list13"><em>Listing 5-13: Using <span class="literal">unnest()</span> to turn an array into rows</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_69"/>Now the output should be in rows:</p>
<p class="programs">quartiles<br/>---------<br/>  11104.5<br/>    25857<br/>    66699</p>
<p class="indent">If we were computing deciles, pulling them from the resulting array and displaying them in rows would be especially helpful.</p>
<h4 class="h4" id="lev78"><em>Creating a median() Function</em></h4>
<p class="noindent">Although PostgreSQL does not have a built-in <span class="literal">median()</span> aggregate function, if you’re adventurous, the PostgreSQL wiki at <em><a href="http://wiki.postgresql.org/wiki/Aggregate_Median">http://wiki.postgresql.org/wiki/Aggregate_Median</a></em> provides a script to create one. <a href="ch05.xhtml#ch05list14">Listing 5-14</a> shows the script:</p>
<p class="programs"><span class="ent">➊</span> CREATE OR REPLACE FUNCTION _final_median(anyarray)<br/>     RETURNS float8 AS<br/>  $$ <br/>    WITH q AS<br/>    (<br/>       SELECT val<br/>       FROM unnest($1) val<br/>       WHERE VAL IS NOT NULL<br/>       ORDER BY 1<br/>    ),<br/>    cnt AS<br/>    (<br/>      SELECT COUNT(*) AS c FROM q<br/>    )<br/>    SELECT AVG(val)::float8<br/>    FROM <br/>    (<br/>      SELECT val FROM q<br/>      LIMIT  2 - MOD((SELECT c FROM cnt), 2)<br/>      OFFSET GREATEST(CEIL((SELECT c FROM cnt) / 2.0) - 1,0)<br/>    ) q2;<br/>  $$<br/>  LANGUAGE sql IMMUTABLE;<br/><br/><span class="ent">➋</span> CREATE AGGREGATE median(anyelement) (<br/>    SFUNC=array_append,<br/>    STYPE=anyarray,<br/>    FINALFUNC=_final_median,<br/>    INITCOND='{}'<br/>  );</p>
<p class="listing" id="ch05list14"><em>Listing 5-14: Creating a <span class="literal">median()</span> aggregate function in PostgreSQL</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_70"/>Given what you’ve learned so far, the code for making a <span class="literal">median()</span> aggregate function may look inscrutable. I’ll cover functions in more depth later in the book, but for now note that the code contains two main blocks: one to make a function called <span class="literal">_final_median</span> <span class="ent">➊</span> that sorts the values in the column and finds the midpoint, and a second that serves as the callable aggregate function <span class="literal">median()</span> <span class="ent">➋</span> and passes values to <span class="literal">_final_median</span>. For now, you can skip reviewing the script line by line and simply execute the code.</p>
<p class="indent">Let’s add the <span class="literal">median()</span> function to the census query and try it next to <span class="literal">percentile_cont()</span>, as shown in <a href="ch05.xhtml#ch05list15">Listing 5-15</a>:</p>
<p class="programs">SELECT sum(p0010001) AS "County Sum",<br/>       round(AVG(p0010001), 0) AS "County Average",<br/>       median(p0010001) AS "County Median",<br/>       percentile_cont(.5)<br/>       WITHIN GROUP (ORDER BY p0010001) AS "50th Percentile"<br/>FROM us_counties_2010;</p>
<p class="listing" id="ch05list15"><em>Listing 5-15: Using a <span class="literal">median()</span> aggregate function</em></p>
<p class="indent">The query results show that the median function and the percentile function return the same value:</p>
<p class="programs">County Sum     County Average     County Median     50th Percentile<br/>----------     --------------     -------------     ---------------<br/> 308745538              98233             25857               25857</p>
<p class="indent">So when should you use <span class="literal">median()</span> instead of a percentile function? There is no simple answer. The <span class="literal">median()</span> syntax is easier to remember, albeit a chore to set up for each database, and it’s specific to PostgreSQL. Also, in practice, <span class="literal">median()</span> executes more slowly and may perform poorly on large data sets or slow machines. On the other hand, <span class="literal">percentile_cont()</span> is portable across several SQL database managers, including Microsoft SQL Server, and allows you to find any percentile from 0 to 100. Ultimately, you can try both and decide.</p>
<h3 class="h3" id="lev79">Finding the Mode</h3>
<p class="noindent">Additionally, we can find the <em>mode</em>, the value that appears most often, using the PostgreSQL <span class="literal">mode()</span> function. The function is not part of standard SQL and has a syntax similar to the percentile functions. <a href="ch05.xhtml#ch05list16">Listing 5-16</a> shows a <span class="literal">mode()</span> calculation on <span class="literal">p0010001</span>, the total population column:</p>
<p class="programs">SELECT mode() WITHIN GROUP (ORDER BY p0010001)<br/>FROM us_counties_2010;</p>
<p class="listing" id="ch05list16"><em>Listing 5-16: Finding the most frequent value with <span class="literal">mode()</span></em></p>
<p class="indent">The result is <span class="literal">21720</span>, a population count shared by counties in Mississippi, Oregon, and West Virginia.</p>
<h3 class="h3" id="lev80"><span epub:type="pagebreak" id="page_71"/>Wrapping Up</h3>
<p class="noindent">Working with numbers is a key step in acquiring meaning from your data, and with the math skills covered in this chapter, you’re ready to handle the foundations of numerical analysis with SQL. Later in the book, you’ll learn about deeper statistical concepts including regression and correlation. At this point, you have the basics of sums, averages, and percentiles. You’ve also learned how a median can be a fairer assessment of a group of values than an average. That alone can help you avoid inaccurate conclusions.</p>
<p class="indent">In the next chapter, I’ll introduce you to the power of joining data in two or more tables to increase your options for data analysis. We’ll use the 2010 Census data you’ve already loaded into the <span class="literal">analysis</span> database and explore additional data sets.</p>
<div class="sidebar" id="ch05sb1">
<p class="sidebart"><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Here are three exercises to test your SQL math skills:</p>
<ol>
<li class="noindent"><p class="list">Write a SQL statement for calculating the area of a circle whose radius is 5 inches. (If you don’t remember the formula, it’s an easy web search.) Do you need parentheses in your calculation? Why or why not?</p></li>
<li class="noindent"><p class="list">Using the 2010 Census county data, find out which New York state county has the highest percentage of the population that identified as “American Indian/Alaska Native Alone.” What can you learn about that county from online research that explains the relatively large proportion of American Indian population compared with other New York counties?</p></li>
<li class="noindent"><p class="list">Was the 2010 median county population higher in California or New York?<span epub:type="pagebreak" id="page_72"/></p></li>
</ol>
</div>
</body>
</html>