<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_191"/><strong><span class="big">12</span></strong><br/><strong>ADVANCED QUERY TECHNIQUES</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">Sometimes data analysis requires advanced SQL techniques that go beyond a table join or basic <span class="literal">SELECT</span> query. For example, to find the story in your data, you might need to write a query that uses the results of other queries as inputs. Or you might need to reclassify numerical values into categories before counting them. Like other programming languages, SQL provides a collection of functions and options essential for solving more complex problems, and that is what we’ll explore in this chapter.</p>
<p class="indent">For the exercises, I’ll introduce a data set of temperatures recorded in select U.S. cities and we’ll revisit data sets you’ve created in previous chapters. The code for the exercises is available, along with all the book’s resources, at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>. You’ll continue to use the <span class="literal">analysis</span> database you’ve already built. Let’s get started.</p>
<h3 class="h3" id="lev202"><span epub:type="pagebreak" id="page_192"/>Using Subqueries</h3>
<p class="noindent">A <em>subquery</em> is nested inside another query. Typically, it’s used for a calculation or logical test that provides a value or set of data to be passed into the main portion of the query. Its syntax is not unusual: we just enclose the subquery in parentheses and use it where needed. For example, we can write a subquery that returns multiple rows and treat the results as a table in the <span class="literal">FROM</span> clause of the main query. Or we can create a <em>scalar subquery</em> that returns a single value and use it as part of an <em>expression</em> to filter rows via <span class="literal">WHERE</span>, <span class="literal">IN</span>, and <span class="literal">HAVING</span> clauses. These are the most common uses of subqueries.</p>
<p class="indent">You first encountered a subquery in <a href="ch09.xhtml#ch09">Chapter 9</a> in the ANSI SQL standard syntax for a table <span class="literal">UPDATE</span>, which is shown again here. Both the data for the update and the condition that specifies which rows to update are generated by subqueries that look for values that match the columns in <span class="codeitalic">table</span> and <span class="codeitalic">table_b</span>:</p>
<p class="programs">  UPDATE <em>table</em><br/><span class="ent">➊</span> SET <em>column</em> = (SELECT <em>column</em><br/>                FROM <em>table_b</em><br/>                WHERE <em>table.column</em> = <em>table_b.column</em>)<br/><span class="ent">➋</span> WHERE EXISTS (SELECT <em>column</em><br/>                FROM <em>table_b</em><br/>                WHERE <em>table.column</em> = <em>table_b.column</em>);</p>
<p class="indent">This example query has two subqueries that use the same syntax. We use the <span class="literal">SELECT</span> statement inside parentheses <span class="ent">➊</span> as the first subquery in the <span class="literal">SET</span> clause, which generates values for the update. Similarly, we use a second subquery in the <span class="literal">WHERE EXISTS</span> clause, again with a <span class="literal">SELECT</span> statement <span class="ent">➋</span> to filter the rows we want to update. Both subqueries are <em>correlated subqueries</em> and are so named because they depend on a value or table name from the main query that surrounds them. In this case, both subqueries depend on <em><span class="literal">table</span></em> from the main <span class="literal">UPDATE</span> statement. An <em>uncorrelated subquery</em> has no reference to objects in the main query.</p>
<p class="indent">It’s easier to understand these concepts by working with actual data, so let’s look at some examples. We’ll revisit two data sets from earlier chapters: the Decennial 2010 Census table <span class="literal">us_counties_2010</span> you created in <a href="ch04.xhtml#ch04">Chapter 4</a> and the <span class="literal">meat_poultry_egg_inspect</span> table in <a href="ch09.xhtml#ch09">Chapter 9</a>.</p>
<h4 class="h4" id="lev203"><em>Filtering with Subqueries in a WHERE Clause</em></h4>
<p class="noindent">You know that a <span class="literal">WHERE</span> clause lets you filter query results based on criteria you provide, using an expression such as <span class="literal">WHERE quantity &gt; 1000</span>. But this requires that you already know the value to use for comparison. What if you don’t? That’s one way a subquery comes in handy: it lets you write a query that generates one or more values to use as part of an expression in a <span class="literal">WHERE</span> clause.</p>
<h5 class="h5">Generating Values for a Query Expression</h5>
<p class="noindent">Say you wanted to write a query to show which U.S. counties are at or above the 90th percentile, or top 10 percent, for population. Rather than writing <span epub:type="pagebreak" id="page_193"/>two separate queries—one to calculate the 90th percentile and the other to filter by counties—you can do both at once using a subquery in a <span class="literal">WHERE</span> clause, as shown in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>:</p>
<p class="programs">  SELECT geo_name,<br/>         state_us_abbreviation,<br/>         p0010001<br/>  FROM us_counties_2010<br/><span class="ent">➊</span> WHERE p0010001 &gt;= (<br/>      SELECT percentile_cont(.9) WITHIN GROUP (ORDER BY p0010001)<br/>      FROM us_counties_2010<br/>      )<br/>  ORDER BY p0010001 DESC;</p>
<p class="listing" id="ch12list1"><em>Listing 12-1: Using a subquery in a <span class="literal">WHERE</span> clause</em></p>
<p class="indent">This query is standard in terms of what we’ve done so far except that the <span class="literal">WHERE</span> clause <span class="ent">➊</span>, which filters by the total population column <span class="literal">p0010001</span>, doesn’t include a value like it normally would. Instead, after the <span class="literal">&gt;=</span> comparison operators, we provide a second query in parentheses. This second query uses the <span class="literal">percentile_cont()</span> function in <a href="ch05.xhtml#ch05">Chapter 5</a> to generate one value: the 90th percentile cut-off point in the <span class="literal">p0010001</span> column, which will then be used in the main query.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Using <span class="literal">percentile_cont()</span> to filter with a subquery works only if you pass in a single input, as shown. If you pass in an array, as in <a href="ch05.xhtml#ch05list12">Listing 5-12</a> on <a href="ch05.xhtml#page_68">page 68</a>, <span class="literal">percentile_cont()</span> returns an array, and the query will fail to evaluate the <span class="literal">&gt;=</span> against an array type.</em></p>
</div>
<p class="indent">If you run the subquery separately by highlighting it in pgAdmin, you should see the results of the subquery, a value of <span class="literal">197444.6</span>. But you won’t see that number when you run the entire query in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>, because the result of that subquery is passed directly to the <span class="literal">WHERE</span> clause to use in filtering the results.</p>
<p class="indent">The entire query should return 315 rows, or about 10 percent of the 3,143 rows in <span class="literal">us_counties_2010</span>.</p>
<p class="programs">geo_name              state_us_abbreviation    p0010001<br/>------------------    ---------------------    --------<br/>Los Angeles County    CA                        9818605<br/>Cook County           IL                        5194675<br/>Harris County         TX                        4092459<br/>Maricopa County       AZ                        3817117<br/>San Diego County      CA                        3095313<br/><em>--snip--</em><br/>Elkhart County        IN                         197559<br/>Sangamon County       IL                         197465</p>
<p class="indent">The result includes all counties with a population greater than or equal to <span class="literal">197444.6</span>, the value the subquery generated.</p>
<h5 class="h5" id="lev204"><span epub:type="pagebreak" id="page_194"/>Using a Subquery to Identify Rows to Delete</h5>
<p class="noindent">Adding a subquery to a <span class="literal">WHERE</span> clause can be useful in query statements other than <span class="literal">SELECT</span>. For example, we can use a similar subquery in a <span class="literal">DELETE</span> statement to specify what to remove from a table. Imagine you have a table with 100 million rows that, because of its size, takes a long time to query. If you just want to work on a subset of the data (such as a particular state), you can make a copy of the table and delete what you don’t need from it.</p>
<p class="indent"><a href="ch12.xhtml#ch12list2">Listing 12-2</a> shows an example of this approach. It makes a copy of the census table using the method you learned in <a href="ch09.xhtml#ch09">Chapter 9</a> and then deletes everything from that backup except the 315 counties in the top 10 percent of population:</p>
<p class="programs">CREATE TABLE us_counties_2010_top10 AS<br/>SELECT * FROM us_counties_2010;<br/><br/>DELETE FROM us_counties_2010_top10<br/>WHERE p0010001 &lt; (<br/>    SELECT percentile_cont(.9) WITHIN GROUP (ORDER BY p0010001)<br/>    FROM us_counties_2010_top10<br/>    );</p>
<p class="listing" id="ch12list2"><em>Listing 12-2: Using a subquery in a <span class="literal">WHERE</span> clause with <span class="literal">DELETE</span></em></p>
<p class="indent">Run the code in <a href="ch12.xhtml#ch12list2">Listing 12-2</a>, and then execute <span class="literal">SELECT count(*) FROM us_counties_2010_top10;</span> to count the remaining rows in the table. The result should be 315 rows, which is the original 3,143 minus the 2,828 the subquery deleted.</p>
<h4 class="h4" id="lev205"><em>Creating Derived Tables with Subqueries</em></h4>
<p class="noindent">If your subquery returns rows and columns of data, you can convert that data to a table by placing it in a <span class="literal">FROM</span> clause, the result of which is known as a <em>derived table</em>. A derived table behaves just like any other table, so you can query it or join it to other tables, even other derived tables. This approach is helpful when a single query can’t perform all the operations you need.</p>
<p class="indent">Let’s look at a simple example. In <a href="ch05.xhtml#ch05">Chapter 5</a>, you learned the difference between average and median values. I explained that a median can often better indicate a data set’s central value because a few very large or small values (or outliers) can skew an average. For that reason, I often recommend comparing the average and median. If they’re close, the data probably falls in a <em>normal distribution</em> (the familiar bell curve), and the average is a good representation of the central value. If the average and median are far apart, some outliers might be having an effect or the distribution is skewed, not normal.</p>
<p class="indent">Finding the average and median population of U.S. counties as well as the difference between them is a two-step process. We need to calculate the average and the median, and then we need to subtract the two. We can do both operations in one fell swoop with a subquery in the <span class="literal">FROM</span> clause, as shown in <a href="ch12.xhtml#ch12list3">Listing 12-3</a>.</p>
<p class="programs"><span epub:type="pagebreak" id="page_195"/>  SELECT round(calcs.average, 0) AS average,<br/>         calcs.median,<br/>         round(calcs.average - calcs.median, 0) AS median_average_diff<br/>  FROM (<br/>     <span class="ent">➊</span> SELECT avg(p0010001) AS average,<br/>              percentile_cont(.5)<br/>                  WITHIN GROUP (ORDER BY p0010001)::numeric(10,1) AS median<br/>       FROM us_counties_2010<br/>       )<br/><span class="ent">➋</span> AS calcs;</p>
<p class="listing" id="ch12list3"><em>Listing 12-3: Subquery as a derived table in a <span class="literal">FROM</span> clause</em></p>
<p class="indent">The subquery <span class="ent">➊</span> is straightforward. We use the <span class="literal">avg()</span> and <span class="literal">percentile_cont()</span> functions to find the average and median of the census table’s <span class="literal">p0010001</span> total population column and name each column with an alias. Then we name the subquery with an alias <span class="ent">➋</span> of <span class="literal">calcs</span> so we can reference it as a table in the main query.</p>
<p class="indent">Subtracting the <span class="literal">median</span> from the <span class="literal">average</span>, both of which are returned by the subquery, is done in the main query; then the main query rounds the result and labels it with the alias <span class="literal">median_average_diff</span>. Run the query, and the result should be the following:</p>
<p class="programs">average    median     median_average_diff<br/>-------    -------    -------------------<br/>  98233    25857.0                  72376</p>
<p class="indent">The difference between the median and average, 72,736, is nearly three times the size of the median. That helps show that a relatively small number of high-population counties push the average county size over 98,000, whereas the median of all counties is much less at 25,857.</p>
<h4 class="h4" id="lev206"><em>Joining Derived Tables</em></h4>
<p class="noindent">Because derived tables behave like regular tables, you can join them. Joining derived tables lets you perform multiple preprocessing steps before arriving at the result. For example, say we wanted to determine which states have the most meat, egg, and poultry processing plants per million population; before we can calculate that rate, we need to know the number of plants in each state and the population of each state.</p>
<p class="indent">We start by counting producers by state using the <span class="literal">meat_poultry_egg_inspect</span> table in <a href="ch09.xhtml#ch09">Chapter 9</a>. Then we can use the <span class="literal">us_counties_2010</span> table to count population by state by summing and grouping county values. <a href="ch12.xhtml#ch12list4">Listing 12-4</a> shows how to write subqueries for both tasks and join them to calculate the overall rate.</p>
<p class="programs">  SELECT census.state_us_abbreviation AS st,<br/>         census.st_population,<br/>         plants.plant_count,<br/>       <span class="ent">➊</span> round((plants.plant_count/census.st_population::numeric(10,1))*1000000, 1)<br/>             AS plants_per_million<br/><span epub:type="pagebreak" id="page_196"/>  FROM<br/>      (<br/>        <span class="ent">➋</span> SELECT st,<br/>                 count(*) AS plant_count<br/>          FROM meat_poultry_egg_inspect<br/>          GROUP BY st<br/>      )<br/>      AS plants<br/>  JOIN<br/>      (<br/>        <span class="ent">➌</span> SELECT state_us_abbreviation,<br/>                 sum(p0010001) AS st_population<br/>          FROM us_counties_2010<br/>          GROUP BY state_us_abbreviation<br/>      )<br/>      AS census<br/><span class="ent">➍</span> ON plants.st = census.state_us_abbreviation<br/>  ORDER BY plants_per_million DESC;</p>
<p class="listing" id="ch12list4"><em>Listing 12-4: Joining two derived tables</em></p>
<p class="indent">You learned how to calculate rates in <a href="ch10.xhtml#ch10">Chapter 10</a>, so the math and syntax in the main query for finding <span class="literal">plants_per_million</span> <span class="ent">➊</span> should be familiar. We divide the number of plants by the population, and then multiply that quotient by 1 million. For the inputs, we use the values generated from derived tables using subqueries.</p>
<p class="indent">The first subquery <span class="ent">➋</span> finds the number of plants in each state using the <span class="literal">count()</span> aggregate function and then groups them by state. We label this subquery with the <span class="literal">plants</span> alias for reference in the main part of the query. The second subquery <span class="ent">➌</span> finds the total population by state by using <span class="literal">sum()</span> on the <span class="literal">p0010001</span> total population column and then groups those by <span class="literal">state_us_abbreviation</span>. We alias this derived table as <span class="literal">census</span>.</p>
<p class="indent">Next, we join the derived tables <span class="ent">➍</span> by linking the <span class="literal">st</span> column in <span class="literal">plants</span> to the <span class="literal">state_us_abbreviation</span> column in <span class="literal">census</span>. We then list the results in descending order based on the calculated rates. Here’s a sample output of 51 rows showing the highest and lowest rates:</p>
<p class="programs">st    st_population    plant_count    plants_per_million<br/>--    -------------    -----------    ------------------<br/>NE          1826341            110                  60.2<br/>IA          3046355            149                  48.9<br/>VT           625741             27                  43.1<br/>HI          1360301             47                  34.6<br/>ND           672591             22                  32.7<br/><em>--snip--</em><br/>SC          4625364             55                  11.9<br/>LA          4533372             49                  10.8<br/>AZ          6392017             37                   5.8<br/>DC           601723              2                   3.3<br/>WY           563626              1                   1.8</p>
<p class="indent"><span epub:type="pagebreak" id="page_197"/>The results line up with what we might expect. The top states are well-known meat producers. For example, Nebraska is one of the nation’s top cattle exporters, and Iowa leads the United States in pork production. Washington, D.C., and Wyoming at the bottom of the list are among those states with the fewest plants per million.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Your results will differ slightly if you didn’t add missing state values to the <span class="literal">meat_poultry_egg_inspect</span> table as noted in <a href="ch09.xhtml#lev146">“Updating Rows Where Values Are Missing”</a> on <a href="ch09.xhtml#page_141">page 141</a>.</em></p>
</div>
<h4 class="h4" id="lev207"><em>Generating Columns with Subqueries</em></h4>
<p class="noindent">You can also generate new columns of data with subqueries by placing a subquery in the column list after <span class="literal">SELECT</span>. Typically, you would use a single value from an aggregate. For example, the query in <a href="ch12.xhtml#ch12list5">Listing 12-5</a> selects the <span class="literal">geo_name</span> and total population column <span class="literal">p0010001</span> from <span class="literal">us_counties_2010</span>, and then adds a subquery to add the median of all counties to each row in the new column <span class="literal">us_median</span>:</p>
<p class="programs">SELECT geo_name,<br/>       state_us_abbreviation AS st,<br/>       p0010001 AS total_pop,<br/>       (SELECT percentile_cont(.5) WITHIN GROUP (ORDER BY p0010001)<br/>        FROM us_counties_2010) AS us_median<br/>FROM us_counties_2010;</p>
<p class="listing" id="ch12list5"><em>Listing 12-5: Adding a subquery to a column list</em></p>
<p class="indent">The first rows of the result set should look like this:</p>
<p class="programs">geo_name          st    total_pop    us_median<br/>--------------    --    ---------    ---------<br/>Autauga County    AL        54571        25857<br/>Baldwin County    AL       182265        25857<br/>Barbour County    AL        27457        25857<br/>Bibb County       AL        22915        25857<br/>Blount County     AL        57322        25857<br/><em>--snip--</em></p>
<p class="indent">On its own, that repeating <span class="literal">us_median</span> value isn’t very helpful because it’s the same each time. It would be more interesting and useful to generate values that indicate how much each county’s population deviates from the median value. Let’s look at how we can use the same subquery technique to do that. <a href="ch12.xhtml#ch12list6">Listing 12-6</a> builds on <a href="ch12.xhtml#ch12list5">Listing 12-5</a> by adding a subquery expression after <span class="literal">SELECT</span> that calculates the difference between the population and the median for each county:</p>
<p class="programs">  SELECT geo_name,<br/>         state_us_abbreviation AS st,<br/>         p0010001 AS total_pop,<br/>         (SELECT percentile_cont(.5) WITHIN GROUP (ORDER BY p0010001)<br/><span epub:type="pagebreak" id="page_198"/>         FROM us_counties_2010) AS us_median,<br/>     <span class="ent">➊</span> p0010001 - (SELECT percentile_cont(.5) WITHIN GROUP (ORDER BY p0010001)<br/>                   FROM us_counties_2010) AS diff_from_median<br/>  FROM us_counties_2010<br/><span class="ent">➋</span> WHERE (p0010001 - (SELECT percentile_cont(.5) WITHIN GROUP (ORDER BY p0010001)<br/>                     FROM us_counties_2010))<br/>         BETWEEN -1000 AND 1000;</p>
<p class="listing" id="ch12list6"><em>Listing 12-6: Using a subquery expression in a calculation</em></p>
<p class="indent">The added subquery <span class="ent">➊</span> is part of a column definition that subtracts the subquery’s result from <span class="literal">p0010001</span>, the total population. It puts that new data in a column with an alias of <span class="literal">diff_from_median</span>. To make this query even more useful, we can narrow the results further to show only counties whose population falls within 1,000 of the median. This would help us identify which counties in America have close to the median county population. To do this, we repeat the subquery expression in the <span class="literal">WHERE</span> clause <span class="ent">➋</span> and filter results using the <span class="literal">BETWEEN -1000 AND 1000</span> expression.</p>
<p class="indent">The outcome should reveal 71 counties with a population relatively close to the U.S. median. Here are the first five rows of the results:</p>
<div class="image"><img alt="image" src="../images/prog_page_198.jpg"/></div>
<p class="indent">Bear in mind that subqueries add to overall query execution time; therefore, if we were working with millions of rows, we could simplify <a href="ch12.xhtml#ch12list6">Listing 12-6</a> by eliminating the subquery that displays the column <span class="literal">us_median</span>. I’ve left it in this example for your reference.</p>
<h4 class="h4" id="lev208"><em>Subquery Expressions</em></h4>
<p class="noindent">You can also use subqueries to filter rows by evaluating whether a condition evaluates as <span class="literal">true</span> or <span class="literal">false</span>. For this, we can use several standard ANSI SQL <em>subquery expressions</em>, which are a combination of a keyword with a subquery and are generally used in <span class="literal">WHERE</span> clauses to filter rows based on the existence of values in another table.</p>
<p class="indent">The PostgreSQL documentation at <em><a href="https://www.postgresql.org/docs/current/static/functions-subquery.html">https://www.postgresql.org/docs/current/static/functions-subquery.html</a></em> lists available subquery expressions, but here we’ll examine the syntax for just two of them.</p>
<h5 class="h5" id="lev209">Generating Values for the IN Operator</h5>
<p class="noindent">The subquery expression <span class="literal">IN (</span><span class="codeitalic">subquery</span><span class="literal">)</span> is like the <span class="literal">IN</span> comparison operator in <a href="ch02.xhtml#ch02">Chapter 2</a> except we use a subquery to provide the list of values to <span epub:type="pagebreak" id="page_199"/>check against rather than having to manually provide one. In the following example, we use a subquery to generate <span class="literal">id</span> values from a <span class="literal">retirees</span> table, and then use that list for the <span class="literal">IN</span> operator in the <span class="literal">WHERE</span> clause. The <span class="literal">NOT IN</span> expression does the opposite to find employees whose <span class="literal">id</span> value does <em>not</em> appear in <span class="literal">retirees</span>.</p>
<p class="programs">SELECT first_name, last_name<br/>FROM employees<br/>WHERE id IN (<br/>    SELECT id<br/>    FROM retirees);</p>
<p class="indent">We would expect the output to show the names of employees who have <span class="literal">id</span> values that match those in <span class="literal">retirees</span>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The presence of <span class="literal">NULL</span> values in a subquery result set will cause a query with a <span class="literal">NOT IN</span> expression to return no rows. If your data contains <span class="literal">NULL</span> values, use the <span class="literal">WHERE NOT</span> <span class="literal">EXISTS</span> expression described in the next section.</em></p>
</div>
<h5 class="h5" id="lev210">Checking Whether Values Exist</h5>
<p class="noindent">Another subquery expression, <span class="literal">EXISTS (</span><em><span class="literal">subquery</span></em><span class="literal">)</span>, is a true/false test. It returns a value of <span class="literal">true</span> if the subquery in parentheses returns at least one row. If it returns no rows, <span class="literal">EXISTS</span> evaluates to <span class="literal">false</span>. In the following example, the query returns all names from an <span class="literal">employees</span> table as long as the subquery finds at least one value in <span class="literal">id</span> in a <span class="literal">retirees</span> table.</p>
<p class="programs">SELECT first_name, last_name<br/>FROM employees<br/>WHERE EXISTS (<br/>    SELECT id<br/>    FROM retirees);</p>
<p class="indent">Rather than return all names from <span class="literal">employees</span>, we instead could mimic the behavior of <span class="literal">IN</span> and limit names to where the subquery after <span class="literal">EXISTS</span> finds at least one corresponding <span class="literal">id</span> value in <span class="literal">retirees</span>. The following is a correlated subquery because the table named in the main query is referenced in the subquery.</p>
<p class="programs">SELECT first_name, last_name<br/>FROM employees<br/>WHERE EXISTS (<br/>    SELECT id<br/>    FROM retirees<br/>    WHERE id = employees.id);</p>
<p class="indent">This approach is particularly helpful if you need to join on more than one column, which you can’t do with the <span class="literal">IN</span> expression.</p>
<p class="indent"><span epub:type="pagebreak" id="page_200"/>You can also use the <span class="literal">NOT</span> keyword with <span class="literal">EXISTS</span>. For example, to find employees with no corresponding record in <span class="literal">retirees</span>, you would run this query:</p>
<p class="programs">SELECT first_name, last_name<br/>FROM employees<br/>WHERE NOT EXISTS (<br/>    SELECT id<br/>    FROM retirees<br/>    WHERE id = employees.id);</p>
<p class="indent">The technique of using <span class="literal">NOT</span> with <span class="literal">EXISTS</span> is helpful for assessing whether a data set is complete.</p>
<h3 class="h3" id="lev211">Common Table Expressions</h3>
<p class="noindent">Earlier in this chapter, you learned how to create derived tables by placing subqueries in a <span class="literal">FROM</span> clause. A second approach to creating temporary tables for querying uses the <em>Common Table Expression (CTE)</em>, a relatively recent addition to standard SQL that’s informally called a “<span class="literal">WITH</span> clause.” Using a CTE, you can define one or more tables up front with subqueries. Then you can query the table results as often as needed in a main query that follows.</p>
<p class="indent"><a href="ch12.xhtml#ch12list7">Listing 12-7</a> shows a simple CTE called <span class="literal">large_counties</span> based on our census data, followed by a query of that table. The code determines how many counties in each state have 100,000 people or more. Let’s walk through the example.</p>
<p class="programs"><span class="ent">➊</span> WITH<br/>      large_counties (geo_name, st, p0010001)<br/>  AS<br/>      (<br/>        <span class="ent">➋</span> SELECT geo_name, state_us_abbreviation, p0010001<br/>          FROM us_counties_2010<br/>          WHERE p0010001 &gt;= 100000<br/>      )<br/><span class="ent">➌</span> SELECT st, count(*)<br/>  FROM large_counties<br/>  GROUP BY st<br/>  ORDER BY count(*) DESC;</p>
<p class="listing" id="ch12list7"><em>Listing 12-7: Using a simple CTE to find large counties</em></p>
<p class="indent">The <span class="literal">WITH ... AS</span> block <span class="ent">➊</span> defines the CTE’s temporary table <span class="literal">large_counties</span>. After <span class="literal">WITH</span>, we name the table and list its column names in parentheses. Unlike column definitions in a <span class="literal">CREATE TABLE</span> statement, we don’t need to provide data types, because the temporary table inherits those from the subquery <span class="ent">➋</span>, which is enclosed in parentheses after <span class="literal">AS</span>. The <span epub:type="pagebreak" id="page_201"/>subquery must return the same number of columns as defined in the temporary table, but the column names don’t need to match. Also, the column list is optional if you’re not renaming columns, although including the list is still a good idea for clarity even if you don’t rename columns.</p>
<p class="indent">The main query <span class="ent">➌</span> counts and groups the rows in <span class="literal">large_counties</span> by <span class="literal">st</span>, and then orders by the count in descending order. The top five rows of the results should look like this:</p>
<p class="programs">st    count<br/>--    -----<br/>TX       39<br/>CA       35<br/>FL       33<br/>PA       31<br/>OH       28<br/><em>--snip--</em></p>
<p class="indent">As you can see, Texas, California, and Florida are among the states with the highest number of counties with a population of 100,000 or more.</p>
<p class="indent">You could find the same results using a <span class="literal">SELECT</span> query instead of a CTE, as shown here:</p>
<p class="programs">SELECT state_us_abbreviation, count(*)<br/>FROM us_counties_2010<br/>WHERE p0010001 &gt;= 100000<br/>GROUP BY state_us_abbreviation<br/>ORDER BY count(*) DESC;</p>
<p class="indent">So why use a CTE? One reason is that by using a CTE, you can pre-stage subsets of data to feed into a larger query for more complex analysis. Also, you can reuse each table defined in a CTE in multiple places in the main query, which means you don’t have to repeat the <span class="literal">SELECT</span> query each time. Another commonly cited advantage is that the code is more readable than if you performed the same operation with subqueries.</p>
<p class="indent"><a href="ch12.xhtml#ch12list8">Listing 12-8</a> uses a CTE to rewrite the join of derived tables in <a href="ch12.xhtml#ch12list4">Listing 12-4</a> (finding the states that have the most meat, egg, and poultry processing plants per million population) into a more readable format:</p>
<p class="programs">  WITH<br/>    <span class="ent">➊</span> counties (st, population) AS<br/>      (SELECT state_us_abbreviation, sum(population_count_100_percent)<br/>       FROM us_counties_2010<br/>       GROUP BY state_us_abbreviation),<br/><br/>    <span class="ent">➋</span> plants (st, plants) AS<br/>      (SELECT st, count(*) AS plants<br/>       FROM meat_poultry_egg_inspect<br/>       GROUP BY st)<br/><br/><span epub:type="pagebreak" id="page_202"/>  SELECT counties.st,<br/>         population,<br/>         plants,<br/>         round((plants/population::numeric(10,1)) * 1000000, 1) AS per_million<br/><span class="ent">➌</span> FROM counties JOIN plants<br/>  ON counties.st = plants.st<br/>  ORDER BY per_million DESC;</p>
<p class="listing" id="ch12list8"><em>Listing 12-8: Using CTEs in a table join</em></p>
<p class="indent">Following the <span class="literal">WITH</span> keyword, we define two tables using subqueries. The first subquery, <span class="literal">counties</span> <span class="ent">➊</span>, returns the population of each state. The second, <span class="literal">plants</span> <span class="ent">➋</span>, returns the number of plants per state. With those tables defined, we join them <span class="ent">➌</span> on the <span class="literal">st</span> column in each table and calculate the rate per million. The results are identical to the joined derived tables in <a href="ch12.xhtml#ch12list4">Listing 12-4</a>, but <a href="ch12.xhtml#ch12list8">Listing 12-8</a> is easier to read.</p>
<p class="indent">As another example, you can use a CTE to simplify queries with redundant code. For example, in <a href="ch12.xhtml#ch12list6">Listing 12-6</a>, we used a subquery with the <span class="literal">percentile_cont()</span> function in three different locations to find median county population. In <a href="ch12.xhtml#ch12list9">Listing 12-9</a>, we can write that subquery just once as a CTE:</p>
<p class="programs"><span class="ent">➊</span> WITH us_median AS<br/>      (SELECT percentile_cont(.5)<br/>       WITHIN GROUP (ORDER BY p0010001) AS us_median_pop<br/>       FROM us_counties_2010)<br/><br/>  SELECT geo_name,<br/>         state_us_abbreviation AS st,<br/>         p0010001 AS total_pop,<br/>       <span class="ent">➋</span> us_median_pop,<br/>       <span class="ent">➌</span> p0010001 - us_median_pop AS diff_from_median<br/><span class="ent">➍</span> FROM us_counties_2010 CROSS JOIN us_median<br/><span class="ent">➎</span> WHERE (p0010001 - us_median_pop)<br/>         BETWEEN -1000 AND 1000;</p>
<p class="listing" id="ch12list9"><em>Listing 12-9: Using CTEs to minimize redundant code</em></p>
<p class="indent">After the <span class="literal">WITH</span> keyword, we define <span class="literal">us_median</span> <span class="ent">➊</span> as the result of the same subquery used in <a href="ch12.xhtml#ch12list6">Listing 12-6</a>, which finds the median population using <span class="literal">percentile_cont()</span>. Then we reference the <span class="literal">us_median_pop</span> column on its own <span class="ent">➋</span>, as part of a calculated column <span class="ent">➌</span>, and in a <span class="literal">WHERE</span> clause <span class="ent">➎</span>. To make the value available to every row in the <span class="literal">us_counties_2010</span> table during <span class="literal">SELECT</span>, we use the <span class="literal">CROSS JOIN</span> query <span class="ent">➍</span> you learned in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>
<p class="indent">This query provides identical results to those in <a href="ch12.xhtml#ch12list6">Listing 12-6</a>, but we only had to write the subquery once to find the median. Not only does this save time, but it also lets you revise the query more easily. For example, to find counties whose population is close to the 90th percentile, you can substitute <span class="literal">.9</span> for <span class="literal">.5</span> as input to <span class="literal">percentile_cont()</span> in just one place.</p>
<h3 class="h3" id="lev212"><span epub:type="pagebreak" id="page_203"/>Cross Tabulations</h3>
<p class="noindent"><em>Cross tabulations</em> provide a simple way to summarize and compare variables by displaying them in a table layout, or matrix. In a matrix, rows represent one variable, columns represent another variable, and each cell where a row and column intersects holds a value, such as a count or percentage.</p>
<p class="indent">You’ll often see cross tabulations, also called <em>pivot tables</em> or <em>crosstabs</em>, used to report summaries of survey results or to compare sets of variables. A frequent example happens during every election when candidates’ votes are tallied by geography:</p>
<p class="programs">candidate    ward 1    ward 2    ward 3<br/>---------    ------    ------    ------<br/>Dirk            602     1,799     2,112<br/>Pratt           599     1,398     1,616<br/>Lerxst          911       902     1,114</p>
<p class="indent">In this case, the candidates’ names are one variable, the wards (or city districts) are another variable, and the cells at the intersection of the two hold the vote totals for that candidate in that ward. Let’s look at how to generate cross tabulations.</p>
<h4 class="h4" id="lev213"><em>Installing the crosstab() Function</em></h4>
<p class="noindent">Standard ANSI SQL doesn’t have a crosstab function, but PostgreSQL does as part of a <em>module</em> you can install easily. Modules include PostgreSQL extras that aren’t part of the core application; they include functions related to security, text search, and more. You can find a list of PostgreSQL modules at <em><a href="https://www.postgresql.org/docs/current/static/contrib.html">https://www.postgresql.org/docs/current/static/contrib.html</a></em>.</p>
<p class="indent">PostgreSQL’s <span class="literal">crosstab()</span> function is part of the <span class="literal">tablefunc</span> module. To install <span class="literal">tablefunc</span> in the pgAdmin Query Tool, execute this command:</p>
<p class="programs">CREATE EXTENSION tablefunc;</p>
<p class="indent">PostgreSQL should return the message <span class="literal">CREATE EXTENSION</span> when it’s done installing. (If you’re working with another database management system, check the documentation to see whether it offers a similar functionality. For example, Microsoft SQL Server has the <span class="literal">PIVOT</span> command.)</p>
<p class="indent">Next, we’ll create a basic crosstab so you can learn the syntax, and then we’ll handle a more complex case.</p>
<h4 class="h4" id="lev214"><em>Tabulating Survey Results</em></h4>
<p class="noindent">Let’s say your company needs a fun employee activity, so you coordinate an ice cream social at your three offices in the city. The trouble is, people are particular about ice cream flavors. To choose flavors people will like, you decide to conduct a survey.</p>
<p class="indent">The CSV file <em>ice_cream_survey.csv</em> contains 200 responses to your survey. You can download this file, along with all the book’s resources, <span epub:type="pagebreak" id="page_204"/>at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>. Each row includes a <span class="literal">response_id</span>, <span class="literal">office</span>, and <span class="literal">flavor</span>. You’ll need to count how many people chose each flavor at each office and present the results in a readable way to your colleagues.</p>
<p class="indent">In your <span class="literal">analysis</span> database, use the code in <a href="ch12.xhtml#ch12list10">Listing 12-10</a> to create a table and load the data. Make sure you change the file path to the location on your computer where you saved the CSV file.</p>
<p class="programs">CREATE TABLE ice_cream_survey (<br/>    response_id integer PRIMARY KEY,<br/>    office varchar(20),<br/>    flavor varchar(20)<br/>);<br/><br/>COPY ice_cream_survey<br/>FROM '<em>C:\YourDirectory\</em>ice_cream_survey.csv'<br/>WITH (FORMAT CSV, HEADER);</p>
<p class="listing" id="ch12list10"><em>Listing 12-10: Creating and filling the <span class="literal">ice_cream_survey</span> table</em></p>
<p class="indent">If you want to inspect the data, run the following to view the first five rows:</p>
<p class="programs">SELECT *<br/>FROM ice_cream_survey<br/>LIMIT 5;</p>
<p class="indent">The data should look like this:</p>
<p class="programs">response_id    office      flavor<br/>-----------    --------    ----------<br/>          1    Uptown      Chocolate <br/>          2    Midtown     Chocolate <br/>          3    Downtown    Strawberry<br/>          4    Uptown      Chocolate<br/>          5    Midtown     Chocolate</p>
<p class="indent">It looks like chocolate is in the lead! But let’s confirm this choice by using the code in <a href="ch12.xhtml#ch12list11">Listing 12-11</a> to generate a crosstab from the table:</p>
<p class="programs">  SELECT *<br/><span class="ent">➊</span> FROM crosstab('SELECT <span class="ent">➋</span>office,<br/>                        <span class="ent">➌</span>flavor,<br/>                        <span class="ent">➍</span>count(*)<br/>                  FROM ice_cream_survey<br/>                  GROUP BY office, flavor<br/>                  ORDER BY office',<br/><br/>              <span class="ent">➎</span> 'SELECT flavor<br/>                  FROM ice_cream_survey<br/>                  GROUP BY flavor<br/>                  ORDER BY flavor')<br/><br/><span epub:type="pagebreak" id="page_205"/><span class="ent">➏</span> AS (office varchar(20),<br/>      chocolate bigint,<br/>      strawberry bigint,<br/>      vanilla bigint);</p>
<p class="listing" id="ch12list11"><em>Listing 12-11: Generating the ice cream survey crosstab</em></p>
<p class="indent">The query begins with a <span class="literal">SELECT *</span> statement that selects everything from the contents of the <span class="literal">crosstab()</span> function <span class="ent">➊</span>. We place two subqueries inside the <span class="literal">crosstab()</span> function. The first subquery generates the data for the crosstab and has three required columns. The first column, <span class="literal">office</span> <span class="ent">➋</span>, supplies the row names for the crosstab, and the second column, <span class="literal">flavor</span> <span class="ent">➌</span>, supplies the category columns. The third column supplies the values for each cell where row and column intersect in the table. In this case, we want the intersecting cells to show a <span class="literal">count()</span> <span class="ent">➍</span> of each flavor selected at each office. This first subquery on its own creates a simple aggregated list.</p>
<p class="indent">The second subquery <span class="ent">➎</span> produces the set of category names for the columns. The <span class="literal">crosstab()</span> function requires that the second subquery return only one column, so here we use <span class="literal">SELECT</span> to retrieve the <span class="literal">flavor</span> column, and we use <span class="literal">GROUP BY</span> to return that column’s unique values.</p>
<p class="indent">Then we specify the names and data types of the crosstab’s output columns following the <span class="literal">AS</span> keyword <span class="ent">➏</span>. The list must match the row and column names in the order the subqueries generate them. For example, because the second subquery that supplies the category columns orders the flavors alphabetically, the output column list does as well.</p>
<p class="indent">When we run the code, our data displays in a clean, readable crosstab:</p>
<p class="programs">office      chocolate    strawberry    vanilla<br/>--------    ---------    ----------    -------<br/>Downtown           23            32         19<br/>Midtown            41                       23<br/>Uptown             22            17         23</p>
<p class="indent">It’s easy to see at a glance that the Midtown office favors chocolate but has no interest in strawberry, which is represented by a <span class="literal">NULL</span> value showing that strawberry received no votes. But strawberry is the top choice Downtown, and the Uptown office is more evenly split among the three flavors.</p>
<h4 class="h4" id="lev215"><em>Tabulating City Temperature Readings</em></h4>
<p class="noindent">Let’s create another crosstab, but this time we’ll use real data. The <em>temperature_readings.csv</em> file, also available with all the book’s resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>, contains a year’s worth of daily temperature readings from three observation stations around the United States: Chicago, Seattle, and Waikiki, a neighborhood on the south shore of the city of Honolulu. The data come from the U.S. National Oceanic and Atmospheric Administration (NOAA) at <em><a href="https://www.ncdc.noaa.gov/cdo-web/datatools/findstation/">https://www.ncdc.noaa.gov/cdo-web/datatools/findstation/</a></em>.</p>
<p class="indent">Each row in the CSV file contains four values: the station name, the date, the day’s maximum temperature, and the day’s minimum temperature. All temperatures are in Fahrenheit. For each month in each city, we <span epub:type="pagebreak" id="page_206"/>want to calculate the median high temperature so we can compare climates. <a href="ch12.xhtml#ch12list12">Listing 12-12</a> contains the code to create the <span class="literal">temperature_readings</span> table and import the CSV file:</p>
<p class="programs">CREATE TABLE temperature_readings (<br/>    reading_id bigserial,<br/>    station_name varchar(50),<br/>    observation_date date,<br/>    max_temp integer,<br/>    min_temp integer<br/>);<br/><br/>COPY temperature_readings<br/>     (station_name, observation_date, max_temp, min_temp)<br/>FROM '<em>C:\YourDirectory\</em>temperature_readings.csv'<br/>WITH (FORMAT CSV, HEADER);</p>
<p class="listing" id="ch12list12"><em>Listing 12-12: Creating and filling a <span class="literal">temperature_readings</span> table</em></p>
<p class="indent">The table contains the four columns from the CSV file along with an added <span class="literal">reading_id</span> of type <span class="literal">bigserial</span> that we use as a surrogate primary key. If you perform a quick count on the table, you should have 1,077 rows. Now, let’s see what cross tabulating the data does using <a href="ch12.xhtml#ch12list13">Listing 12-13</a>:</p>
<p class="programs">SELECT *<br/>FROM crosstab('SELECT<br/>               <span class="ent">➊</span> station_name,<br/>               <span class="ent">➋</span> date_part(''month'', observation_date),<br/>               <span class="ent">➌</span> percentile_cont(.5)<br/>                      WITHIN GROUP (ORDER BY max_temp)<br/>               FROM temperature_readings<br/>               GROUP BY station_name,<br/>                        date_part(''month'', observation_date)<br/>               ORDER BY station_name',<br/><br/>              'SELECT month<br/>               FROM <span class="ent">➍</span>generate_series(1,12) month')<br/><br/>AS (station varchar(50),<br/>    jan numeric(3,0),<br/>    feb numeric(3,0),<br/>    mar numeric(3,0),<br/>    apr numeric(3,0),<br/>    may numeric(3,0),<br/>    jun numeric(3,0),<br/>    jul numeric(3,0),<br/>    aug numeric(3,0),<br/>    sep numeric(3,0),<br/>    oct numeric(3,0),<br/>    nov numeric(3,0),<br/>    dec numeric(3,0)<br/>);</p>
<p class="listing" id="ch12list13"><em>Listing 12-13: Generating the temperature readings crosstab</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_207"/>The structure of the crosstab is the same as in <a href="ch12.xhtml#ch12list11">Listing 12-11</a>. The first subquery inside the <span class="literal">crosstab()</span> function generates the data for the crosstab, calculating the median maximum temperature for each month. It supplies the three required columns. The first column, <span class="literal">station_name</span> <span class="ent">➊</span>, names the rows. The second column uses the <span class="literal">date_part()</span> function <span class="ent">➋</span> you learned in <a href="ch11.xhtml#ch11">Chapter 11</a> to extract the month from <span class="literal">observation_date</span>, which provides the crosstab columns. Then we use <span class="literal">percentile_cont(.5)</span> <span class="ent">➌</span> to find the 50th percentile, or the median, of the <span class="literal">max_temp</span>. We group by station name and month so we have a median <span class="literal">max_temp</span> for each month at each station.</p>
<p class="indent">As in <a href="ch12.xhtml#ch12list11">Listing 12-11</a>, the second subquery produces the set of category names for the columns. I’m using a function called <span class="literal">generate_series()</span> <span class="ent">➍</span> in a manner noted in the official PostgreSQL documentation to create a list of numbers from 1 to 12 that match the month numbers <span class="literal">date_part()</span> extracts from <span class="literal">observation_date</span>.</p>
<p class="indent">Following <span class="literal">AS</span>, we provide the names and data types for the crosstab’s output columns. Each is a <span class="literal">numeric</span> type, matching the output of the percentile function. The following output is practically poetry:</p>
<div class="image"><img alt="image" src="../images/prog_page_207.jpg"/></div>
<p class="indent">We’ve transformed a raw set of daily readings into a compact table showing the median maximum temperature each month for each station. You can see at a glance that the temperature in Waikiki is consistently balmy, whereas Chicago’s median high temperatures vary from just above freezing to downright pleasant. Seattle falls between the two.</p>
<p class="indent">Crosstabs do take time to set up, but viewing data sets in a matrix often makes comparisons easier than viewing the same data in a vertical list. Keep in mind that the <span class="literal">crosstab()</span> function is CPU-intensive, so tread carefully when querying sets that have millions or billions of rows.</p>
<h3 class="h3" id="lev216">Reclassifying Values with CASE</h3>
<p class="noindent">The ANSI Standard SQL <span class="literal">CASE</span> statement is a <em>conditional expression</em>, meaning it lets you add some “if this, then . . .” logic to a query. You can use <span class="literal">CASE</span> in multiple ways, but for data analysis, it’s handy for reclassifying values into categories. You can create categories based on ranges in your data and classify values according to those categories.</p>
<p class="indent">The <span class="literal">CASE</span> syntax follows this pattern:</p>
<p class="programs"><span class="ent">➊</span> CASE WHEN <em>condition</em> THEN <em>result</em><br/>     <span class="ent">➋</span> WHEN <em>another_condition</em> THEN <em>result</em><br/>     <span class="ent">➌</span> ELSE <em>result</em><br/><span class="ent">➍</span> END</p>
<p class="indent"><span epub:type="pagebreak" id="page_208"/>We give the <span class="literal">CASE</span> keyword <span class="ent">➊</span>, and then provide at least one <span class="literal">WHEN</span> <em><span class="literal">condition</span></em> <span class="literal">THEN</span> <em><span class="literal">result</span></em> clause, where <em><span class="literal">condition</span></em> is any expression the database can evaluate as <span class="literal">true</span> or <span class="literal">false</span>, such as <span class="literal">county = 'Dutchess County'</span> or <span class="literal">date &gt; '1995-08-09'</span>. If the condition is <span class="literal">true</span>, the <span class="literal">CASE</span> statement returns the <em><span class="literal">result</span></em> and stops checking any further conditions. The result can be any valid data type. If the condition is <span class="literal">false</span>, the database moves on to evaluate the next condition.</p>
<p class="indent">To evaluate more conditions, we can add optional <span class="literal">WHEN ... THEN</span> clauses <span class="ent">➋</span>. We can also provide an optional <span class="literal">ELSE</span> clause <span class="ent">➌</span> to return a result in case no condition evaluates as <span class="literal">true</span>. Without an <span class="literal">ELSE</span> clause, the statement would return a <span class="literal">NULL</span> when no conditions are <span class="literal">true</span>. The statement finishes with an <span class="literal">END</span> keyword <span class="ent">➍</span>.</p>
<p class="indent"><a href="ch12.xhtml#ch12list14">Listing 12-14</a> shows how to use the <span class="literal">CASE</span> statement to reclassify the temperature readings data into descriptive groups (named according to my own bias against cold weather):</p>
<p class="programs">SELECT max_temp,<br/>       CASE WHEN max_temp &gt;= 90 THEN 'Hot'<br/>            WHEN max_temp BETWEEN 70 AND 89 THEN 'Warm'<br/>            WHEN max_temp BETWEEN 50 AND 69 THEN 'Pleasant'<br/>            WHEN max_temp BETWEEN 33 AND 49 THEN 'Cold'<br/>            WHEN max_temp BETWEEN 20 AND 32 THEN 'Freezing'<br/>            ELSE 'Inhumane'<br/>        END AS temperature_group<br/>FROM temperature_readings;</p>
<p class="listing" id="ch12list14"><em>Listing 12-14: Reclassifying temperature data with <span class="literal">CASE</span></em></p>
<p class="indent">We create five ranges for the <span class="literal">max_temp</span> column in <span class="literal">temperature_readings</span>, which we define using comparison operators. The <span class="literal">CASE</span> statement evaluates each value to find whether any of the five expressions are <span class="literal">true</span>. If so, the statement outputs the appropriate text. Note that the ranges account for all possible values in the column, leaving no gaps. If none of the statements is <span class="literal">true</span>, then the <span class="literal">ELSE</span> clause assigns the value to the category <span class="literal">Inhumane</span>. The way I’ve structured the ranges, this happens only when <span class="literal">max_temp</span> is below 20 degrees. Alternatively, we could replace <span class="literal">ELSE</span> with a <span class="literal">WHEN</span> clause that looks for temperatures less than or equal to 19 degrees by using <span class="literal">max_temp &lt;= 19</span>.</p>
<p class="indent">Run the code; the first five rows of output should look like this:</p>
<p class="programs">max_temp    temperature_group<br/>--------    -----------------<br/>      31    Freezing<br/>      34    Cold<br/>      32    Freezing<br/>      32    Freezing<br/>      34    Cold<br/>      <em>--snip--</em></p>
<p class="indent">Now that we’ve collapsed the data set into six categories, let’s use those categories to compare climate among the three cities in the table.</p>
<h3 class="h3" id="lev217"><span epub:type="pagebreak" id="page_209"/>Using CASE in a Common Table Expression</h3>
<p class="noindent">The operation we performed with <span class="literal">CASE</span> on the temperature data in the previous section is a good example of a preprocessing step you would use in a CTE. Now that we’ve grouped the temperatures in categories, let’s count the groups by city in a CTE to see how many days of the year fall into each temperature category.</p>
<p class="indent"><a href="ch12.xhtml#ch12list15">Listing 12-15</a> shows the code for reclassifying the daily maximum temperatures recast to generate a <span class="literal">temps_collapsed</span> CTE and then use it for an analysis:</p>
<p class="programs"><span class="ent">➊</span> WITH temps_collapsed (station_name, max_temperature_group) AS<br/>      (SELECT station_name,<br/>             CASE WHEN max_temp &gt;= 90 THEN 'Hot'<br/>                  WHEN max_temp BETWEEN 70 AND 89 THEN 'Warm'<br/>                  WHEN max_temp BETWEEN 50 AND 69 THEN 'Pleasant'<br/>                  WHEN max_temp BETWEEN 33 AND 49 THEN 'Cold'<br/>                  WHEN max_temp BETWEEN 20 AND 32 THEN 'Freezing'<br/>                  ELSE 'Inhumane'<br/>              END<br/>       FROM temperature_readings)<br/><br/><span class="ent">➋</span> SELECT station_name, max_temperature_group, count(*)<br/>  FROM temps_collapsed<br/>  GROUP BY station_name, max_temperature_group<br/>  ORDER BY station_name, count(*) DESC;</p>
<p class="listing" id="ch12list15"><em>Listing 12-15: Using <span class="literal">CASE</span> in a CTE</em></p>
<p class="indent">This code reclassifies the temperatures, and then counts and groups by station name to find general climate classifications of each city. The <span class="literal">WITH</span> keyword defines the CTE of <span class="literal">temps_collapsed</span> <span class="ent">➊</span>, which has two columns: <span class="literal">station_name</span> and <span class="literal">max_temperature_group</span>. We then run a <span class="literal">SELECT</span> query on the CTE <span class="ent">➋</span>, performing straightforward <span class="literal">count(*)</span> and <span class="literal">GROUP BY</span> operations on both columns. The results should look like this:</p>
<p class="programs">station_name                      max_temperature_group    count<br/>------------------------------    ---------------------    -----<br/>CHICAGO NORTHERLY ISLAND IL US    Warm                       133<br/>CHICAGO NORTHERLY ISLAND IL US    Cold                        92<br/>CHICAGO NORTHERLY ISLAND IL US    Pleasant                    91<br/>CHICAGO NORTHERLY ISLAND IL US    Freezing                    30<br/>CHICAGO NORTHERLY ISLAND IL US    Inhumane                     8<br/>CHICAGO NORTHERLY ISLAND IL US    Hot                          8<br/>SEATTLE BOEING FIELD WA US        Pleasant                   198<br/>SEATTLE BOEING FIELD WA US        Warm                        98<br/>SEATTLE BOEING FIELD WA US        Cold                        50<br/>SEATTLE BOEING FIELD WA US        Hot                          3<br/>WAIKIKI 717.2 HI US               Warm                       361<br/>WAIKIKI 717.2 HI US               Hot                          5</p>
<p class="indent">Using this classification scheme, the amazingly consistent Waikiki weather, with <span class="literal">Warm</span> maximum temperatures 361 days of the year, confirms <span epub:type="pagebreak" id="page_210"/>its appeal as a vacation destination. From a temperature standpoint, Seattle looks good too, with nearly 300 days of high temps categorized as <span class="literal">Pleasant</span> or <span class="literal">Warm</span> (although this belies Seattle’s legendary rainfall). Chicago, with 30 days of <span class="literal">Freezing</span> max temps and 8 days <span class="literal">Inhumane</span>, probably isn’t for me.</p>
<h3 class="h3" id="lev218">Wrapping Up</h3>
<p class="noindent">In this chapter, you learned to make queries work harder for you. You can now add subqueries in multiple locations to provide finer control over filtering or preprocessing data before analyzing it in a main query. You also can visualize data in a matrix using cross tabulations and reclassify data into groups; both techniques give you more ways to find and tell stories using your data. Great work!</p>
<p class="indent">Throughout the next chapters, we’ll dive into SQL techniques that are more specific to PostgreSQL. We’ll begin by working with and searching text and strings.</p>
<div class="sidebar" id="ch12sb1">
<p class="sidebart"><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Here are two tasks to help you become more familiar with the concepts introduced in the chapter:</p>
<ol>
<li class="noindent"><p class="list">Revise the code in <a href="ch12.xhtml#ch12list15">Listing 12-15</a> to dig deeper into the nuances of Waikiki’s high temperatures. Limit the <span class="literal">temps_collapsed</span> table to the Waikiki maximum daily temperature observations. Then use the <span class="literal">WHEN</span> clauses in the <span class="literal">CASE</span> statement to reclassify the temperatures into seven groups that would result in the following text output:</p>
<p class="programs">'90 or more'<br/>'88-89'<br/>'86-87'<br/>'84-85'<br/>'82-83'<br/>'80-81'<br/>'79 or less'</p>
<p class="indent">In which of those groups does Waikiki’s daily maximum temperature fall most often?</p></li>
<li class="noindent"><p class="list">Revise the ice cream survey crosstab in <a href="ch12.xhtml#ch12list11">Listing 12-11</a> to flip the table. In other words, make <span class="literal">flavor</span> the rows and <span class="literal">office</span> the columns. Which elements of the query do you need to change? Are the counts different?</p></li>
</ol>
</div>
</body>
</html>