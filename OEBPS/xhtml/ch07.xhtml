<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_93"/><strong><span class="big">7</span></strong><br/><strong>TABLE DESIGN THAT WORKS FOR YOU</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">Obsession with detail can be a good thing. When you’re running out the door, it’s reassuring to know your keys will be hanging on the hook where you <em>always</em> leave them. The same holds true for database design. When you need to excavate a nugget of information from dozens of tables and millions of rows, you’ll appreciate a dose of that same detail obsession. When you organize data into a finely tuned, smartly named set of tables, the analysis experience becomes more manageable.</p>
<p class="indent">In this chapter, I’ll build on <a href="ch06.xhtml#ch06">Chapter 6</a> by introducing <em>best practices</em> for organizing and tuning SQL databases, whether they’re yours or ones you inherit for analysis. You already know how to create basic tables and add columns with the appropriate data type and a primary key. Now, we’ll dig deeper into table design by exploring naming rules and conventions, ways to maintain the integrity of your data, and how to add indexes to tables to speed up queries.</p>
<h3 class="h3" id="lev99"><span epub:type="pagebreak" id="page_94"/>Naming Tables, Columns, and Other Identifiers</h3>
<p class="noindent">Developers tend to follow different SQL style patterns when naming tables, columns, and other objects (called <em>identifiers</em>). Some prefer to use <em>camel case</em>, as in <span class="literal">berrySmoothie</span>, where words are strung together and the first letter of each word is capitalized except for the first word. <em>Pascal case</em>, as in <span class="literal">BerrySmoothie</span>, follows a similar pattern but capitalizes the first letter of the first word too. With <em>snake case</em>, as in <span class="literal">berry_smoothie</span>, all the words are lowercase and separated by underscores. So far, I’ve been using snake case in most of the examples, such as in the table <span class="literal">us_counties_2010</span>.</p>
<p class="indent">You’ll find passionate supporters of each naming convention, and some preferences are tied to individual database applications or programming languages. For example, Microsoft recommends Pascal case for its SQL Server users. Whichever convention you prefer, it’s most important to choose a style and apply it consistently. Be sure to check whether your organization has a style guide or offer to collaborate on one, and then follow it religiously.</p>
<p class="indent">Mixing styles or following none generally leads to a mess. It will be difficult to know which table is the most current, which is the backup, or the difference between two similarly named tables. For example, imagine connecting to a database and finding the following collection of tables:</p>
<p class="programs">Customers<br/>customers<br/>custBackup<br/>customer_analysis<br/>customer_test2<br/>customer_testMarch2012<br/>customeranalysis</p>
<p class="indent">In addition, working without a consistent naming scheme makes it problematic for others to dive into your data and makes it challenging for you to pick up where you left off.</p>
<p class="indent">Let’s explore considerations related to naming identifiers and suggestions for best practices.</p>
<h4 class="h4" id="lev100"><em>Using Quotes Around Identifiers to Enable Mixed Case</em></h4>
<p class="noindent">Standard ANSI SQL and many database-specific variants of SQL treat identifiers as case-insensitive unless you provide a delimiter around them—typically double quotes. Consider these two hypothetical <span class="literal">CREATE TABLE</span> statements for PostgreSQL:</p>
<p class="programs">CREATE TABLE customers (<br/>    customer_id serial,<br/>    <em>--snip--</em><br/>);<br/><br/>CREATE TABLE Customers (<br/><span epub:type="pagebreak" id="page_95"/>    customer_id serial,<br/>    <em>--snip--</em><br/>);</p>
<p class="indent">When you execute these statements in order, the first <span class="literal">CREATE TABLE</span> command creates a table called <span class="literal">customers</span>. But rather than creating a second table called <span class="literal">Customers</span>, the second statement will throw an error: <span class="literal">relation</span> <span class="literal">"customers"</span> <span class="literal">already exists</span>. Because you didn’t quote the identifier, PostgreSQL treats <span class="literal">customers</span> and <span class="literal">Customers</span> as the same identifier, disregarding the case. If you want to preserve the uppercase letter and create a separate table named <span class="literal">Customers</span>, you must surround the identifier with quotes, like this:</p>
<p class="programs">CREATE TABLE "Customers" (<br/>    customer_id serial,<br/>    <em>--snip--</em><br/>);</p>
<p class="indent">Now, PostgreSQL retains the uppercase <span class="literal">C</span> and creates <span class="literal">Customers</span> as well as <span class="literal">customers</span>. Later, to query <span class="literal">Customers</span> rather than <span class="literal">customers</span>, you’ll have to quote its name in the <span class="literal">SELECT</span> statement:</p>
<p class="programs">SELECT * FROM "Customers";</p>
<p class="indent">Of course, you wouldn’t want two tables with such similar names because of the high risk of a mix-up. This example simply illustrates the behavior of SQL in PostgreSQL.</p>
<h4 class="h4" id="lev101"><em>Pitfalls with Quoting Identifiers</em></h4>
<p class="noindent">Using quotation marks also permits characters not otherwise allowed in an identifier, including spaces. But be aware of the negatives of using this method: for example, you might want to throw quotes around <span class="literal">"trees planted"</span> and use that as a column name in a reforestation database, but then all users will have to provide quotes on every subsequent reference to that column. Omit the quotes and the database will respond with an error, identifying <span class="literal">trees</span> and <span class="literal">planted</span> as separate columns missing a comma between them. A more readable and reliable option is to use snake case, as in <span class="literal">trees_planted</span>.</p>
<p class="indent">Another downside to quoting is that it lets you use SQL <em>reserved keywords</em>, such as <span class="literal">TABLE</span>, <span class="literal">WHERE</span>, or <span class="literal">SELECT</span>, as an identifier. Reserved keywords are words SQL designates as having special meaning in the language. Most database developers frown on using reserved keywords as identifiers. At a minimum it’s confusing, and at worst neglecting or forgetting to quote that keyword later will result in an error because the database will interpret the word as a command instead of an identifier.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>For PostgreSQL, you can find a list of keywords documented at</em> <a href="https://www.postgresql.org/docs/current/static/sql-keywords-appendix.html">https://www.postgresql.org/docs/current/static/sql-keywords-appendix.html</a>. In addition, many code editors and database tools, including pgAdmin, will automatically highlight keywords in a particular color.</p>
</div>
<h4 class="h4" id="lev102"><span epub:type="pagebreak" id="page_96"/><em>Guidelines for Naming Identifiers</em></h4>
<p class="noindent">Given the extra burden of quoting and its potential problems, it’s best to keep your identifier names simple, unquoted, and consistent. Here are my recommendations:</p>
<ul>
<li class="noindent"><strong>Use snake case.</strong> Snake case is readable and reliable, as shown in the earlier <span class="literal">trees_planted</span> example. It’s used throughout the official PostgreSQL documentation and helps make multiword names easy to understand: <span class="literal">video_on_demand</span> makes more sense at a glance than <span class="literal">videoondemand</span>.</li>
<li class="noindent"><strong>Make names easy to understand and avoid cryptic abbreviations.</strong> If you’re building a database related to travel, <span class="literal">arrival_time</span> is a better reminder of the content as a column name than <span class="literal">arv_tm</span>.</li>
<li class="noindent"><strong>For table names, use plurals.</strong> Tables hold rows, and each row represents one instance of an entity. So, use plural names for tables, such as <span class="literal">teachers</span>, <span class="literal">vehicles</span>, or <span class="literal">departments</span>.</li>
<li class="noindent"><strong>Mind the length.</strong> The maximum number of characters allowed for an identifier name varies by database application: the SQL standard is 128 characters, but PostgreSQL limits you to 63, and the Oracle system maximum is 30. If you’re writing code that may get reused in another database system, lean toward shorter identifier names.</li>
<li class="noindent"><strong>When making copies of tables, use names that will help you manage them later.</strong> One method is to append a <span class="codeitalic">YYYY_MM_DD</span> date to the table name when you create it, such as <span class="literal">tire_sizes_2017_10_20</span>. An additional benefit is that the table names will sort in date order.</li>
</ul>
<h3 class="h3" id="lev103">Controlling Column Values with Constraints</h3>
<p class="noindent">A column’s data type already broadly defines the kind of data it will accept: integers versus characters, for example. But SQL provides several additional constraints that let us further specify acceptable values for a column based on rules and logical tests. With constraints, we can avoid the “garbage in, garbage out” phenomenon, which is what happens when poor-quality data result in inaccurate or incomplete analysis. Constraints help maintain the quality of the data and ensure the integrity of the relationships among tables.</p>
<p class="indentb">In <a href="ch06.xhtml#ch06">Chapter 6</a>, you learned about <em>primary</em> and <em>foreign keys</em>, which are two of the most commonly used constraints. Let’s review them as well as the following additional constraint types:</p>
<p class="hang"><span class="codestrong">CHECK</span> Evaluates whether the data falls within values we specify</p>
<p class="hang"><span class="codestrong">UNIQUE</span> Ensures that values in a column or group of columns are unique in each row in the table</p>
<p class="hang"><span class="codestrong">NOT NULL</span> Prevents <span class="literal">NULL</span> values in a column</p>
<p class="indentt"><span epub:type="pagebreak" id="page_97"/>We can add constraints in two ways: as a <em>column constraint</em> or as a <em>table constraint</em>. A column constraint only applies to that column. It’s declared with the column name and data type in the <span class="literal">CREATE TABLE</span> statement, and it gets checked whenever a change is made to the column. With a table constraint, we can supply criteria that apply to one or more columns. We declare it in the <span class="literal">CREATE TABLE</span> statement immediately after defining all the table columns, and it gets checked whenever a change is made to a row in the table.</p>
<p class="indent">Let’s explore these constraints, their syntax, and their usefulness in table design.</p>
<h4 class="h4" id="lev104"><em>Primary Keys: Natural vs. Surrogate</em></h4>
<p class="noindent">In <a href="ch06.xhtml#ch06">Chapter 6</a>, you learned about giving a table a <em>primary key</em>: a column or collection of columns whose values uniquely identify each row in a table. A primary key is a constraint, and it imposes two rules on the column or columns that make up the key:</p>
<ol>
<li class="noindent"><p class="list">Each column in the key must have a unique value for each row.</p></li>
<li class="noindent"><p class="list">No column in the key can have missing values.</p></li>
</ol>
<p class="indent">Primary keys also provide a means of relating tables to each other and maintaining <em>referential integrity</em>, which is ensuring that rows in related tables have matching values when we expect them to. The simple primary key example in <a href="ch06.xhtml#lev82">“Relating Tables with Key Columns”</a> on <a href="ch06.xhtml#page_74">page 74</a> had a single ID field that used an integer inserted by us, the user. However, as with most areas of SQL, you can implement primary keys in several ways. Often, the data will suggest the best path. But first we must assess whether to use a <em>natural key</em> or a <em>surrogate key</em> as the primary key.</p>
<h5 class="h5">Using Existing Columns for Natural Keys</h5>
<p class="noindent">You implement a natural key by using one or more of the table’s existing columns rather than creating a column and filling it with artificial values to act as keys. If a column’s values obey the primary key constraint—unique for every row and never empty—it can be used as a natural key. A value in the column can change as long as the new value doesn’t cause a violation of the constraint.</p>
<p class="indent">An example of a natural key is a driver’s license identification number issued by a local Department of Motor Vehicles. Within a governmental jurisdiction, such as a state in the United States, we’d reasonably expect that all drivers would receive a unique ID on their licenses. But if we were compiling a national driver’s license database, we might not be able to make that assumption; several states could independently issue the same ID code. In that case, the <span class="literal">driver_id</span> column may not have unique values and cannot be used as the natural key unless it’s combined with one or more additional columns. Regardless, as you build tables, you’ll encounter many values suitable for natural keys: a part number, a serial number, or a book’s ISBN are all good examples.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_98"/>Introducing Columns for Surrogate Keys</h5>
<p class="noindent">Instead of relying on existing data, a surrogate key typically consists of a single column that you fill with artificial values. This might be a sequential number auto-generated by the database; for example, using a serial data type (covered in <a href="ch03.xhtml#lev34">“Auto-Incrementing Integers”</a> on <a href="ch03.xhtml#page_27">page 27</a>). Some developers like to use a <em>Universally Unique Identifier (UUID)</em>, which is a code comprised of 32 hexadecimal digits that identifies computer hardware or software. Here’s an example:</p>
<p class="programs">2911d8a8-6dea-4a46-af23-d64175a08237</p>
<h5 class="h5">Pros and Cons of Key Types</h5>
<p class="noindent">As with most SQL debates, there are arguments for using either type of primary key. Reasons cited for using natural keys often include the following:</p>
<ul>
<li class="noindent"><p class="list">The data already exists in the table, and you don’t need to add a column to create a key.</p></li>
<li class="noindent"><p class="list">Because the natural key data has meaning, it can reduce the need to join tables when searching.</p>
<p class="noindentt">Alternatively, advocates of surrogate keys highlight these points in favor:</p></li>
<li class="noindentt"><p class="list">Because a surrogate key doesn’t have any meaning in itself and its values are independent of the data in the table, if your data changes later, you’re not limited by the key structure.</p></li>
<li class="noindent"><p class="list">Natural keys tend to consume more storage than the integers typically used for surrogate keys.</p></li>
</ul>
<p class="indent">A well-designed table should have one or more columns that can serve as a natural key. An example is a product table with a unique product code. But in a table of employees, it might be difficult to find any single column, or even multiple columns, that would be unique on a row-by-row basis to serve as a primary key. In that case, you can create a surrogate key, but you probably should reconsider the table structure.</p>
<h5 class="h5">Primary Key Syntax</h5>
<p class="noindent">In “<span class="literal">JOIN</span> Types” on <a href="ch06.xhtml#page_78">page 78</a>, you created primary keys on the <span class="literal">schools_left</span> and <span class="literal">schools_right</span> tables to try out <span class="literal">JOIN</span> types. In fact, these were surrogate keys: in both tables, you created columns called <span class="literal">id</span> to use as the key and used the keywords <span class="literal">CONSTRAINT</span> <span class="codeitalic">key_name PRIMARY KEY</span> to declare them as primary keys. Let’s work through several more primary key examples.</p>
<p class="indent">In <a href="ch07.xhtml#ch07list1">Listing 7-1</a>, we declare a primary key using the column constraint and table constraint methods on a table similar to the driver’s license example mentioned earlier. Because we expect the driver’s license IDs to always be unique, we’ll use that column as a natural key.</p>
<p class="programs"><span epub:type="pagebreak" id="page_99"/>  CREATE TABLE natural_key_example (<br/>    <span class="ent">➊</span> license_id varchar(10) CONSTRAINT license_key PRIMARY KEY,<br/>      first_name varchar(50),<br/>      last_name varchar(50)<br/>  );<br/><br/><span class="ent">➋</span> DROP TABLE natural_key_example;<br/><br/>  CREATE TABLE natural_key_example (<br/>      license_id varchar(10),<br/>      first_name varchar(50),<br/>      last_name varchar(50),<br/>    <span class="ent">➌</span> CONSTRAINT license_key PRIMARY KEY (license_id)<br/>  );</p>
<p class="listing" id="ch07list1"><em>Listing 7-1: Declaring a single-column natural key as a primary key</em></p>
<p class="indent">We first use the column constraint syntax to declare <span class="literal">license_id</span> as the primary key by adding the <span class="literal">CONSTRAINT</span> keyword <span class="ent">➊</span> followed by a name for the key and then the keywords <span class="literal">PRIMARY KEY</span>. An advantage of using this syntax is that it’s easy to understand at a glance which column is designated as the primary key. Note that in the column constraint syntax you can omit the <span class="literal">CONSTRAINT</span> keyword and name for the key, and simply use <span class="literal">PRIMARY KEY</span>.</p>
<p class="indent">Next, we delete the table from the database by using the <span class="literal">DROP TABLE</span> command <span class="ent">➋</span> to prepare for the table constraint example.</p>
<p class="indent">To add the same primary key using the table constraint syntax, we declare the <span class="literal">CONSTRAINT</span> after listing the final column <span class="ent">➌</span> with the column we want to use as the key in parentheses. In this example, we end up with the same column for the primary key as we did with the column constraint syntax. However, you must use the table constraint syntax when you want to create a primary key using more than one column. In that case, you would list the columns in parentheses, separated by commas. We’ll explore that in a moment.</p>
<p class="indent">First, let’s look at how having a primary key protects you from ruining the integrity of your data. <a href="ch07.xhtml#ch07list2">Listing 7-2</a> contains two <span class="literal">INSERT</span> statements:</p>
<p class="programs">INSERT INTO natural_key_example (license_id, first_name, last_name)<br/>VALUES ('T229901', 'Lynn', 'Malero');<br/><br/>INSERT INTO natural_key_example (license_id, first_name, last_name)<br/>VALUES ('T229901', 'Sam', 'Tracy');</p>
<p class="listing" id="ch07list2"><em>Listing 7-2: An example of a primary key violation</em></p>
<p class="indent">When you execute the first <span class="literal">INSERT</span> statement on its own, the server loads a row into the <span class="literal">natural_key_example</span> table without any issue. When you attempt to execute the second, the server replies with an error:</p>
<p class="programs">ERROR: duplicate key value violates unique constraint "license_key"<br/>DETAIL: Key (license_id)=(T229901) already exists.</p>
<p class="indent"><span epub:type="pagebreak" id="page_100"/>Before adding the row, the server checked whether a <span class="literal">license_id</span> of <span class="literal">T229901</span> was already present in the table. Because it was, and because a primary key by definition must be unique for each row, the server rejected the operation. The rules of the fictional DMV state that no two drivers can have the same license ID, so checking for and rejecting duplicate data is one way for the database to enforce that rule.</p>
<h5 class="h5" id="lev105">Creating a Composite Primary Key</h5>
<p class="noindent">If we want to create a natural key but a single column in the table isn’t sufficient for meeting the primary key requirements for uniqueness, we may be able to create a suitable key from a combination of columns, which is called a <em>composite primary key</em>.</p>
<p class="indent">As a hypothetical example, let’s use a table that tracks student school attendance. The combination of a student ID column and a date column would give us unique data for each row, tracking whether or not the student was in school each day during a school year. To create a composite primary key from two or more columns, you must declare it using the table constraint syntax mentioned earlier. <a href="ch07.xhtml#ch07list3">Listing 7-3</a> creates an example table for the student attendance scenario. The school database would record each <span class="literal">student_id</span> only once per <span class="literal">school_day</span>, creating a unique value for the row. A <span class="literal">present</span> column of data type <span class="literal">boolean</span> indicates whether the student was there on that day.</p>
<p class="programs">CREATE TABLE natural_key_composite_example (<br/>    student_id varchar(10),<br/>    school_day date,<br/>    present boolean,<br/>    CONSTRAINT student_key PRIMARY KEY (student_id, school_day)<br/>);</p>
<p class="listing" id="ch07list3"><em>Listing 7-3: Declaring a composite primary key as a natural key</em></p>
<p class="indent">The syntax in <a href="ch07.xhtml#ch07list3">Listing 7-3</a> follows the same table constraint format for adding a primary key for one column, but we pass two (or more) columns as arguments rather than one. Again, we can simulate a key violation by attempting to insert a row where the combination of values in the two key columns—<span class="literal">student_id</span> and <span class="literal">school_day</span>—is not unique to the table. Run the code in <a href="ch07.xhtml#ch07list4">Listing 7-4</a>:</p>
<p class="programs">INSERT INTO natural_key_composite_example (student_id, school_day, present)<br/>VALUES(775, '1/22/2017', 'Y');<br/><br/>INSERT INTO natural_key_composite_example (student_id, school_day, present)<br/>VALUES(775, '1/23/2017', 'Y');<br/><br/>INSERT INTO natural_key_composite_example (student_id, school_day, present)<br/>VALUES(775, '1/23/2017', 'N');</p>
<p class="listing" id="ch07list4"><em>Listing 7-4: Example of a composite primary key violation</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_101"/>The first two <span class="literal">INSERT</span> statements execute fine because there’s no duplication of values in the combination of key columns. But the third statement causes an error because the <span class="literal">student_id</span> and <span class="literal">school_day</span> values it contains match a combination that already exists in the table:</p>
<p class="programs">ERROR: duplicate key value violates unique constraint "student_key"<br/>DETAIL: Key (student_id, school_day)=(775, 2017-01-23) already exists.</p>
<p class="indent">You can create composite keys with more than two columns. The specific database you’re using imposes the limit to the number of columns you can use.</p>
<h5 class="h5" id="lev106">Creating an Auto-Incrementing Surrogate Key</h5>
<p class="noindent">If a table you’re creating has no columns suitable for a natural primary key, you may have a data integrity problem; in that case, it’s best to reconsider how you’re structuring the database. If you’re inheriting data for analysis or feel strongly about using surrogate keys, you can create a column and fill it with unique values. Earlier, I mentioned that some developers use UUIDs for this; others rely on software to generate a unique code. For our purposes, an easy way to create a surrogate primary key is with an auto-incrementing integer using one of the serial data types discussed in <a href="ch03.xhtml#lev34">“Auto-Incrementing Integers”</a> on <a href="ch03.xhtml#page_27">page 27</a>.</p>
<p class="indent">Recall the three serial types: <span class="literal">smallserial</span>, <span class="literal">serial</span>, and <span class="literal">bigserial</span>. They correspond to the integer types <span class="literal">smallint</span>, <span class="literal">integer</span>, and <span class="literal">bigint</span> in terms of the range of values they handle and the amount of disk storage they consume. For a primary key, it may be tempting to try to save disk space by using <span class="literal">serial</span>, which handles numbers as large as 2,147,483,647. But many a database developer has received a late-night call from a user frantic to know why their application is broken, only to discover that the database is trying to generate a number one greater than the data type’s maximum. For this reason, with PostgreSQL, it’s generally wise to use <span class="literal">bigserial</span>, which accepts numbers as high as 9.2 <em>quintillion</em>. You can set it and forget it, as shown in the first column defined in <a href="ch07.xhtml#ch07list5">Listing 7-5</a>:</p>
<p class="programs">  CREATE TABLE surrogate_key_example (<br/>    <span class="ent">➊</span> order_number bigserial,<br/>      product_name varchar(50),<br/>      order_date date,<br/>    <span class="ent">➋</span> CONSTRAINT order_key PRIMARY KEY (order_number)<br/>  );<br/><br/><span class="ent">➌</span> INSERT INTO surrogate_key_example (product_name, order_date)<br/>  VALUES ('Beachball Polish', '2015-03-17'),<br/>         ('Wrinkle De-Atomizer', '2017-05-22'),<br/>         ('Flux Capacitor', '1985-10-26');<br/>  SELECT * FROM surrogate_key_example;</p>
<p class="listing" id="ch07list5"><em>Listing 7-5: Declaring a <span class="literal">bigserial</span> column as a surrogate key</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_102"/><a href="ch07.xhtml#ch07list5">Listing 7-5</a> shows how to declare the <span class="literal">bigserial</span> <span class="ent">➊</span> data type for an <span class="literal">order_number</span> column and set the column as the primary key <span class="ent">➋</span>. When you insert data into the table <span class="ent">➌</span>, you can omit the <span class="literal">order_number</span> column. With <span class="literal">order_number</span> set to <span class="literal">bigserial</span>, the database will create a new value for that column on each insert. The new value will be one greater than the largest already created for the column.</p>
<p class="indent">Run <span class="literal">SELECT * FROM surrogate_key_example;</span> to see how the column fills in automatically:</p>
<p class="programs">order_number    product_name           order_date<br/>------------    -------------------    ----------<br/>           1    Beachball Polish       2015-03-17<br/>           2    Wrinkle De-Atomizer    2017-05-22<br/>           3    Flux Capacitor         1985-10-26</p>
<p class="indent">The database will add one to <span class="literal">order_number</span> each time a new row is inserted. But it won’t fill any gaps in the sequence created after rows are deleted.</p>
<h4 class="h4" id="lev107"><em>Foreign Keys</em></h4>
<p class="noindent">With the <em>foreign key</em> constraint, SQL very helpfully provides a way to ensure data in related tables doesn’t end up unrelated, or orphaned. A foreign key is one or more columns in a table that match the primary key of another table. But a foreign key also imposes a constraint: values entered must already exist in the primary key or other unique key of the table it references. If not, the value is rejected. This constraint ensures that we don’t end up with rows in one table that have no relation to rows in the other tables we can join them to.</p>
<p class="indent">To illustrate, <a href="ch07.xhtml#ch07list6">Listing 7-6</a> shows two tables from a hypothetical database tracking motor vehicle activity:</p>
<p class="programs">  CREATE TABLE licenses (<br/>      license_id varchar(10),<br/>      first_name varchar(50),<br/>      last_name varchar(50),<br/>    <span class="ent">➊</span> CONSTRAINT licenses_key PRIMARY KEY (license_id)<br/>  );<br/><br/>  CREATE TABLE registrations (<br/>      registration_id varchar(10),<br/>      registration_date date,<br/>    <span class="ent">➋</span> license_id varchar(10) REFERENCES licenses (license_id),<br/>      CONSTRAINT registration_key PRIMARY KEY (registration_id, license_id)<br/>  );<br/><br/><span class="ent">➌</span> INSERT INTO licenses (license_id, first_name, last_name)<br/>  VALUES ('T229901', 'Lynn', 'Malero');<br/><br/><span class="ent">➍</span> INSERT INTO registrations (registration_id, registration_date, license_id)<br/>  VALUES ('A203391', '3/17/2017', 'T229901');<br/><br/><span epub:type="pagebreak" id="page_103"/><span class="ent">➎</span> INSERT INTO registrations (registration_id, registration_date, license_id)<br/>  VALUES ('A75772', '3/17/2017', 'T000001');</p>
<p class="listing" id="ch07list6"><em>Listing 7-6: A foreign key example</em></p>
<p class="indent">The first table, <span class="literal">licenses</span>, is similar to the <span class="literal">natural_key_example</span> table we made earlier and uses a driver’s unique <span class="literal">license_id</span> <span class="ent">➊</span> as a natural primary key. The second table, <span class="literal">registrations</span>, is for tracking vehicle registrations. A single license ID might be connected to multiple vehicle registrations, because each licensed driver can register multiple vehicles over a number of years. Also, a single vehicle could be registered to multiple license holders, establishing, as you learned in <a href="ch06.xhtml#ch06">Chapter 6</a>, a many-to-many relationship.</p>
<p class="indent">Here’s how that relationship is expressed via SQL: in the <span class="literal">registrations</span> table, we designate the column <span class="literal">license_id</span> as a foreign key by adding the <span class="literal">REFERENCES</span> keyword, followed by the table name and column for it to reference <span class="ent">➋</span>.</p>
<p class="indent">Now, when we insert a row into <span class="literal">registrations</span>, the database will test whether the value inserted into <span class="literal">license_id</span> already exists in the <span class="literal">license_id</span> primary key column of the <span class="literal">licenses</span> table. If it doesn’t, the database returns an error, which is important. If any rows in <span class="literal">registrations</span> didn’t correspond to a row in <span class="literal">licenses</span>, we’d have no way to write a query to find the person who registered the vehicle.</p>
<p class="indent">To see this constraint in action, create the two tables and execute the <span class="literal">INSERT</span> statements one at a time. The first adds a row to <span class="literal">licenses</span> <span class="ent">➌</span> that includes the value <span class="literal">T229901</span> for the <span class="literal">license_id</span>. The second adds a row to <span class="literal">registrations</span> <span class="ent">➍</span> where the foreign key contains the same value. So far, so good, because the value exists in both tables. But we encounter an error with the third insert, which tries to add a row to <span class="literal">registrations</span> <span class="ent">➎</span> with a value for <span class="literal">license_id</span> that’s not in <span class="literal">licenses</span>:</p>
<p class="programs">ERROR: insert or update on table "registrations" violates foreign key<br/>constraint "registrations_license_id_fkey"<br/>DETAIL: Key (license_id)=(T000001) is not present in table "licenses".</p>
<p class="indent">The resulting error is good because it shows the database is keeping the data clean. But it also indicates a few practical implications: first, it affects the order we insert data. We cannot add data to a table that contains a foreign key before the other table referenced by the key has the related records, or we’ll get an error. In this example, we’d have to create a driver’s license record before inserting a related registration record (if you think about it, that’s what your local department of motor vehicles probably does).</p>
<p class="indent">Second, the reverse applies when we delete data. To maintain referential integrity, the foreign key constraint prevents us from deleting a row from <span class="literal">licenses</span> before removing any related rows in <span class="literal">registrations</span>, because doing so would leave an orphaned record. We would have to delete the related row in <span class="literal">registrations</span> first, and then delete the row in <span class="literal">licenses</span>. However, ANSI SQL provides a way to handle this order of operations automatically using the <span class="literal">ON DELETE</span> <span class="literal">CASCADE</span> keywords, which I’ll discuss next.</p>
<h4 class="h4" id="lev108"><span epub:type="pagebreak" id="page_104"/><em>Automatically Deleting Related Records with CASCADE</em></h4>
<p class="noindent">To delete a row in <span class="literal">licenses</span> and have that action automatically delete any related rows in <span class="literal">registrations</span>, we can specify that behavior by adding <span class="literal">ON DELETE CASCADE</span> when defining the foreign key constraint.</p>
<p class="indent">When we create the <span class="literal">registrations</span> table, the keywords would go at the end of the definition of the <span class="literal">license_id</span> column, like this:</p>
<p class="programs">CREATE TABLE registrations (<br/>    registration_id varchar(10),<br/>    registration_date date,<br/>    license_id varchar(10) REFERENCES licenses (license_id) ON DELETE CASCADE,<br/>    CONSTRAINT registration_key PRIMARY KEY (registration_id, license_id)<br/>);</p>
<p class="indent">Now, deleting a row in <span class="literal">licenses</span> should also delete all related rows in <span class="literal">registrations</span>. This allows us to delete a driver’s license without first having to manually remove any registrations to it. It also maintains data integrity by ensuring deleting a license doesn’t leave orphaned rows in <span class="literal">registrations</span>.</p>
<h4 class="h4" id="lev109"><em>The CHECK Constraint</em></h4>
<p class="noindent">A <span class="literal">CHECK</span> constraint evaluates whether data added to a column meets the expected criteria, which we specify with a logical test. If the criteria aren’t met, the database returns an error. The <span class="literal">CHECK</span> constraint is extremely valuable because it can prevent columns from getting loaded with nonsensical data. For example, a new employee’s birthdate probably shouldn’t be more than 120 years in the past, so you can set a cap on birthdates. Or, in most schools I know, <span class="literal">Z</span> isn’t a valid letter grade for a course (although my barely passing algebra grade felt like it), so we might insert constraints that only accept the values A–F.</p>
<p class="indent">As with primary keys, we can implement a <span class="literal">CHECK</span> constraint as a column constraint or a table constraint. For a column constraint, declare it in the <span class="literal">CREATE TABLE</span> statement after the column name and data type: <span class="literal">CHECK (</span><span class="codeitalic">logical expression</span><span class="literal">)</span>. As a table constraint, use the syntax <span class="literal">CONSTRAINT</span> <span class="codeitalic">constraint_name</span> <span class="literal">CHECK (</span><span class="codeitalic">logical expression</span><span class="literal">)</span> after all columns are defined.</p>
<p class="indent"><a href="ch07.xhtml#ch07list7">Listing 7-7</a> shows a <span class="literal">CHECK</span> constraint applied to two columns in a table we might use to track the user role and salary of employees within an organization. It uses the table constraint syntax for the primary key and the <span class="literal">CHECK</span> constraint.</p>
<p class="programs">CREATE TABLE check_constraint_example (<br/>    user_id bigserial,<br/>    user_role varchar(50),<br/>    salary integer,<br/>    CONSTRAINT user_id_key PRIMARY KEY (user_id),<br/>  <span class="ent">➊</span> CONSTRAINT check_role_in_list CHECK (user_role IN('Admin', 'Staff')),<br/>  <span class="ent">➋</span> CONSTRAINT check_salary_not_zero CHECK (salary &gt; 0)<br/>);</p>
<p class="listing" id="ch07list7"><em>Listing 7-7: Examples of <span class="literal">CHECK</span> constraints</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_105"/>We create the table and set the <span class="literal">user_id</span> column as an auto-incrementing surrogate primary key. The first <span class="literal">CHECK</span> <span class="ent">➊</span> tests whether values entered into the <span class="literal">user_role</span> column match one of two predefined strings, <span class="literal">Admin</span> or <span class="literal">Staff</span>, by using the SQL <span class="literal">IN</span> operator. The second <span class="literal">CHECK</span> tests whether values entered in the <span class="literal">salary</span> column are greater than 0, because no one should be earning a negative amount <span class="ent">➋</span>. Both tests are another example of a <em>Boolean expression</em>, a statement that evaluates as either true or false. If a value tested by the constraint evaluates as <span class="literal">true</span>, the check passes.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Developers may debate whether check logic belongs in the database, in the application in front of the database, such as a human resources system, or both. One advantage of checks in the database is that the database will maintain data integrity in the case of changes to the application, even if a new system gets built or users are given alternate ways to add data.</em></p>
</div>
<p class="indent">When values are inserted or updated, the database checks them against the constraint. If the values in either column violate the constraint—or, for that matter, if the primary key constraint is violated—the database will reject the change.</p>
<p class="indent">If we use the table constraint syntax, we also can combine more than one test in a single <span class="literal">CHECK</span> statement. Say we have a table related to student achievement. We could add the following:</p>
<p class="programs">CONSTRAINT grad_check CHECK (credits &gt;= 120 AND tuition = 'Paid')</p>
<p class="indent">Notice that we combine two logical tests by enclosing them in parentheses and connecting them with <span class="literal">AND</span>. Here, both Boolean expressions must evaluate as <span class="literal">true</span> for the entire check to pass. You can also test values across columns, as in the following example where we want to make sure an item’s sale price is a discount on the original, assuming we have columns for both values:</p>
<p class="programs">CONSTRAINT sale_check CHECK (sale_price &lt; retail_price)</p>
<p class="indent">Inside the parentheses, the logical expression checks that the sale price is less than the retail price.</p>
<h4 class="h4" id="lev110"><em>The UNIQUE Constraint</em></h4>
<p class="noindent">We can also ensure that a column has a unique value in each row by using the <span class="literal">UNIQUE</span> constraint. If ensuring unique values sounds similar to the purpose of a primary key, it is. But <span class="literal">UNIQUE</span> has one important difference. In a primary key, no values can be <span class="literal">NULL</span>, but a <span class="literal">UNIQUE</span> constraint permits multiple <span class="literal">NULL</span> values in a column.</p>
<p class="indent">To show the usefulness of <span class="literal">UNIQUE</span>, look at the code in <a href="ch07.xhtml#ch07list8">Listing 7-8</a>, which is a table for tracking contact info:</p>
<p class="programs">  CREATE TABLE unique_constraint_example (<br/>      contact_id bigserial CONSTRAINT contact_id_key PRIMARY KEY,<br/><span epub:type="pagebreak" id="page_106"/>      first_name varchar(50),<br/>      last_name varchar(50),<br/>      email varchar(200),<br/>    <span class="ent">➊</span> CONSTRAINT email_unique UNIQUE (email)<br/>  );<br/><br/>  INSERT INTO unique_constraint_example (first_name, last_name, email)<br/>  VALUES ('Samantha', 'Lee', 'slee@example.org');<br/><br/>  INSERT INTO unique_constraint_example (first_name, last_name, email)<br/>  VALUES ('Betty', 'Diaz', 'bdiaz@example.org');<br/><br/>  INSERT INTO unique_constraint_example (first_name, last_name, email)<br/><span class="ent">➋</span> VALUES ('Sasha', 'Lee', 'slee@example.org');</p>
<p class="listing" id="ch07list8"><em>Listing 7-8: A <span class="literal">UNIQUE</span> constraint example</em></p>
<p class="indent">In this table, <span class="literal">contact_id</span> serves as a surrogate primary key, uniquely identifying each row. But we also have an <span class="literal">email</span> column, the main point of contact with each person. We’d expect this column to contain only unique email addresses, but those addresses might change over time. So, we use <span class="literal">UNIQUE</span> <span class="ent">➊</span> to ensure that any time we add or update a contact’s email we’re not providing one that already exists. If we do try to insert an email that already exists <span class="ent">➋</span>, the database will return an error:</p>
<p class="programs">ERROR: duplicate key value violates unique constraint "email_unique"<br/>DETAIL: Key (email)=(slee@example.org) already exists.</p>
<p class="indent">Again, the error shows the database is working for us.</p>
<h4 class="h4" id="lev111"><em>The NOT NULL Constraint</em></h4>
<p class="noindent">In <a href="ch06.xhtml#ch06">Chapter 6</a>, you learned about <span class="literal">NULL</span>, a special value in SQL that represents a condition where no data is present in a row in a column or the value is unknown. You’ve also learned that <span class="literal">NULL</span> values are not allowed in a primary key, because primary keys need to uniquely identify each row in a table. But there will be other columns besides primary keys where you don’t want to allow empty values. For example, in a table listing each student in a school, it would be necessary for columns containing first and last names to be filled for each row. To require a value in a column, SQL provides the <span class="literal">NOT NULL</span> constraint, which simply prevents a column from accepting empty values.</p>
<p class="indent"><a href="ch07.xhtml#ch07list9">Listing 7-9</a> demonstrates the <span class="literal">NOT NULL</span> syntax:</p>
<p class="programs">CREATE TABLE not_null_example (<br/>    student_id bigserial,<br/>    first_name varchar(50) NOT NULL,<br/>    last_name varchar(50) NOT NULL,<br/>    CONSTRAINT student_id_key PRIMARY KEY (student_id)<br/>);</p>
<p class="listing" id="ch07list9"><em>Listing 7-9: A <span class="literal">NOT NULL</span> constraint example</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_107"/>Here, we declare <span class="literal">NOT NULL</span> for the <span class="literal">first_name</span> and <span class="literal">last_name</span> columns because it’s likely we’d require those pieces of information in a table tracking student information. If we attempt an <span class="literal">INSERT</span> on the table and don’t include values for those columns, the database will notify us of the violation.</p>
<h4 class="h4" id="lev112"><em>Removing Constraints or Adding Them Later</em></h4>
<p class="noindent">So far, we’ve been placing constraints on tables at the time of creation. You can also remove a constraint or later add one to an existing table using <span class="literal">ALTER TABLE</span>, the SQL command that makes changes to tables and columns. We’ll work with <span class="literal">ALTER TABLE</span> more in <a href="ch09.xhtml#ch09">Chapter 9</a>, but for now we’ll review the syntax for adding and removing constraints.</p>
<p class="indent">To remove a primary key, foreign key, or a <span class="literal">UNIQUE</span> constraint, you would write an <span class="literal">ALTER TABLE</span> statement in this format:</p>
<p class="programs">ALTER TABLE <em>table_name</em> DROP CONSTRAINT <em>constraint_name</em>;</p>
<p class="indent">To drop a <span class="literal">NOT NULL</span> constraint, the statement operates on the column, so you must use the additional <span class="literal">ALTER COLUMN</span> keywords, like so:</p>
<p class="programs">ALTER TABLE <em>table_name</em> ALTER COLUMN <em>column_name</em> DROP NOT NULL;</p>
<p class="indent">Let’s use these statements to modify the <span class="literal">not_null_example</span> table you just made, as shown in <a href="ch07.xhtml#ch07list10">Listing 7-10</a>:</p>
<p class="programs">ALTER TABLE not_null_example DROP CONSTRAINT student_id_key;<br/>ALTER TABLE not_null_example ADD CONSTRAINT student_id_key PRIMARY KEY (student_id);<br/>ALTER TABLE not_null_example ALTER COLUMN first_name DROP NOT NULL;<br/>ALTER TABLE not_null_example ALTER COLUMN first_name SET NOT NULL;</p>
<p class="listing" id="ch07list10"><em>Listing 7-10: Dropping and adding a primary key and a <span class="literal">NOT NULL</span> constraint</em></p>
<p class="indent">Execute the statements one at a time to make changes to the table. Each time, you can view the changes to the table definition in pgAdmin by clicking the table name once, and then clicking the <strong>SQL</strong> tab above the query window. With the first <span class="literal">ALTER TABLE</span> statement, we use <span class="literal">DROP CONSTRAINT</span> to remove the primary key named <span class="literal">student_id_key</span>. We then add the primary key back using <span class="literal">ADD CONSTRAINT</span>. We’d use that same syntax to add a constraint to any existing table.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You can only add a constraint to an existing table if the data in the target column obeys the limits of the constraint. For example, you can’t place a primary key constraint on a column that has duplicate or empty values.</em></p>
</div>
<p class="indent">In the third statement, <span class="literal">ALTER COLUMN</span> and <span class="literal">DROP NOT NULL</span> remove the <span class="literal">NOT NULL</span> constraint from the <span class="literal">first_name</span> column. Finally, <span class="literal">SET NOT NULL</span> adds the constraint.</p>
<h3 class="h3" id="lev113"><span epub:type="pagebreak" id="page_108"/>Speeding Up Queries with Indexes</h3>
<p class="noindent">In the same way that a book’s index helps you find information more quickly, you can speed up queries by adding an <em>index</em> to one or more columns. The database uses the index as a shortcut rather than scanning each row to find data. That’s admittedly a simplistic picture of what, in SQL databases, is a nontrivial topic. I could write several chapters on SQL indexes and tuning databases for performance, but instead I’ll offer general guidance on using indexes and a PostgreSQL-specific example that demonstrates their benefits.</p>
<h4 class="h4" id="lev114"><em>B-Tree: PostgreSQL’s Default Index</em></h4>
<p class="noindent">While following along in this book, you’ve already created several indexes, perhaps without knowing. Each time you add a primary key or <span class="literal">UNIQUE</span> constraint to a table, PostgreSQL (as well as most database systems) places an index on the column. Indexes are stored separately from the table data, but they’re accessed automatically when you run a query and are updated every time a row is added or removed from the table.</p>
<p class="indent">In PostgreSQL, the default index type is the <em>B-Tree index</em>. It’s created automatically on the columns designated for the primary key or a <span class="literal">UNIQUE</span> constraint, and it’s also the type created by default when you execute a <span class="literal">CREATE INDEX</span> statement. B-Tree, short for <em>balanced tree</em>, is so named because the structure organizes the data in a way that when you search for a value, it looks from the top of the tree down through branches until it locates the data you want. (Of course, the process is a lot more complicated than that. A good start on understanding more about the B-Tree is the B-Tree Wikipedia entry.) A B-Tree index is useful for data that can be ordered and searched using equality and range operators, such as <span class="literal">&lt;</span>, <span class="literal">&lt;=</span>, <span class="literal">=</span>, <span class="literal">&gt;=</span>, <span class="literal">&gt;</span>, and <span class="literal">BETWEEN</span>.</p>
<p class="indent">PostgreSQL incorporates additional index types, including the <em>Generalized Inverted Index (GIN)</em> and the <em>Generalized Search Tree (GiST)</em>. Each has distinct uses, and I’ll incorporate them in later chapters on full text search and queries using geometry types.</p>
<p class="indent">For now, let’s see a B-Tree index speed a simple search query. For this exercise, we’ll use a large data set comprising more than 900,000 New York City street addresses, compiled by the OpenAddresses project at <em><a href="https://openaddresses.io/">https://openaddresses.io/</a></em>. The file with the data, <em>city_of_new_york.csv</em>, is available for you to download along with all the resources for this book from <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>.</p>
<p class="indent">After you’ve downloaded the file, use the code in <a href="ch07.xhtml#ch07list11">Listing 7-11</a> to create a <span class="literal">new_york_addresses</span> table and import the address data. You’re a pro at this by now, although the import will take longer than the tiny data sets you’ve loaded so far. The final, loaded table is 126MB, and on one of my systems, it took nearly a minute for the <span class="literal">COPY</span> command to complete.</p>
<p class="programs">CREATE TABLE new_york_addresses (<br/>    longitude numeric(9,6),<br/>    latitude numeric(9,6),<br/><span epub:type="pagebreak" id="page_109"/>    street_number varchar(10),<br/>    street varchar(32),<br/>    unit varchar(7),<br/>    postcode varchar(5),<br/>    id integer CONSTRAINT new_york_key PRIMARY KEY<br/>);<br/><br/>COPY new_york_addresses<br/>FROM '<em>C:\YourDirectory\</em>city_of_new_york.csv'<br/>WITH (FORMAT CSV, HEADER);</p>
<p class="listing" id="ch07list11"><em>Listing 7-11: Importing New York City address data</em></p>
<p class="indent">When the data loads, run a quick <span class="literal">SELECT</span> query to visually check that you have 940,374 rows and seven columns. A common use for this data might be to search for matches in the <span class="literal">street</span> column, so we’ll use that example for exploring index performance.</p>
<h5 class="h5" id="lev115">Benchmarking Query Performance with EXPLAIN</h5>
<p class="noindent">We’ll measure how well an index can improve query speed by checking the performance before and after adding one. To do this, we’ll use PostgreSQL’s <span class="literal">EXPLAIN</span> command, which is specific to PostgreSQL and not part of standard SQL. The <span class="literal">EXPLAIN</span> command provides output that lists the <em>query plan</em> for a specific database query. This might include how the database plans to scan the table, whether or not it will use indexes, and so on. If we add the <span class="literal">ANALYZE</span> keyword, <span class="literal">EXPLAIN</span> will carry out the query and show the actual execution time, which is what we want for the current exercise.</p>
<h5 class="h5" id="lev116">Recording Some Control Execution Times</h5>
<p class="noindent">Run each of the three queries in <a href="ch07.xhtml#ch07list12">Listing 7-12</a> one at a time. We’re using typical <span class="literal">SELECT</span> queries with a <span class="literal">WHERE</span> clause but with the keywords <span class="literal">EXPLAIN ANALYZE</span> included at the beginning. Instead of showing the query results, these keywords tell the database to execute the query and display statistics about the query process and how long it took to execute.</p>
<p class="programs">EXPLAIN ANALYZE SELECT * FROM new_york_addresses<br/>WHERE street = 'BROADWAY';<br/><br/>EXPLAIN ANALYZE SELECT * FROM new_york_addresses<br/>WHERE street = '52 STREET';<br/><br/>EXPLAIN ANALYZE SELECT * FROM new_york_addresses<br/>WHERE street = 'ZWICKY AVENUE';</p>
<p class="listing" id="ch07list12"><em>Listing 7-12: Benchmark queries for index performance</em></p>
<p class="indent">On my system, the first query returns these stats:</p>
<p class="programs">
<span class="ent">➊</span> Seq Scan on new_york_addresses  (cost=0.00..20730.68 rows=3730 width=46)<br/>  (actual time=0.055..289.426 rows=3336 loops=1)<br/>     Filter: ((street)::text = 'BROADWAY'::text)<br/><span epub:type="pagebreak" id="page_110"/>     Rows Removed by Filter: 937038<br/>   Planning time: 0.617 ms<br/><span class="ent">➋</span> Execution time: 289.838 ms</p>
<p class="indent">Not all the output is relevant here, so I won’t decode it all, but two lines are pertinent. The first indicates that to find any rows where <span class="literal">street = 'BROADWAY'</span>, the database will conduct a sequential scan <span class="ent">➊</span> of the table. That’s a synonym for a full table scan: each row will be examined, and the database will remove any row that doesn’t match <span class="literal">BROADWAY</span>. The execution time (on my computer about 290 milliseconds) <span class="ent">➋</span> is how long this will take. Your time will depend on factors including your computer hardware.</p>
<p class="indent">Run each query in <a href="ch07.xhtml#ch07list12">Listing 7-12</a> and record the execution time for each.</p>
<h5 class="h5" id="lev117">Adding the Index</h5>
<p class="noindent">Now, let’s see how adding an index changes the query’s search method and how fast it works. <a href="ch07.xhtml#ch07list13">Listing 7-13</a> shows the SQL statement for creating the index with PostgreSQL:</p>
<p class="programs">CREATE INDEX street_idx ON new_york_addresses (street);</p>
<p class="listing" id="ch07list13"><em>Listing 7-13: Creating a B-Tree index on the <span class="literal">new_york_addresses</span> table</em></p>
<p class="indent">Notice that it’s similar to the commands for creating constraints we’ve covered in the chapter already. (Other database systems have their own variants and options for creating indexes, and there is no ANSI standard.) We give the <span class="literal">CREATE INDEX</span> keywords followed by a name we choose for the index, in this case <span class="literal">street_idx</span>. Then <span class="literal">ON</span> is added, followed by the target table and column.</p>
<p class="indent">Execute the <span class="literal">CREATE INDEX</span> statement, and PostgreSQL will scan the values in the <span class="literal">street</span> column and build the index from them. We only need to create the index once. When the task finishes, rerun each of the three queries in <a href="ch07.xhtml#ch07list12">Listing 7-12</a> and record the execution times reported by <span class="literal">EXPLAIN ANALYZE</span>. For example:</p>
<p class="programs">  Bitmap Heap Scan on new_york_addresses  (cost=65.80..5962.17 rows=2758<br/>  width=46) (actual time=1.792..9.816 rows=3336 loops=1)<br/>    Recheck Cond: ((street)::text = 'BROADWAY'::text)<br/>    Heap Blocks: exact=2157<br/><span class="ent">➊</span>   -&gt;  Bitmap Index Scan on street_idx  (cost=0.00..65.11 rows=2758 width=0) <br/>         (actual time=1.253..1.253 rows=3336 loops=1)<br/>           Index Cond: ((street)::text = 'BROADWAY'::text)<br/>  Planning time: 0.163 ms<br/><span class="ent">➋</span> Execution time: 5.887 ms</p>
<p class="indent">Do you notice a change? First, instead of a sequential scan, the <span class="literal">EXPLAIN ANALYZE</span> statistics for each query show that the database is now using an index scan on <span class="literal">street_idx</span> <span class="ent">➊</span> instead of visiting each row. Also, the query speed is now markedly faster <span class="ent">➋</span>. <a href="ch07.xhtml#ch07tab1">Table 7-1</a> shows the execution times (rounded) from my computer before and after adding the index.</p>
<p class="tabcap" id="ch07tab1"><span epub:type="pagebreak" id="page_111"/><strong>Table 7-1:</strong> Measuring Index Performance</p>
<table class="topbot-d">
<thead>
<tr>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Query Filter</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Before Index</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>After Index</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">WHERE street = 'BROADWAY'</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">290 ms</p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">6 ms</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">WHERE street = '52 STREET'</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">271 ms</p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">6 ms</p></td>
</tr>
<tr>
<td class="table-ca" style="vertical-align: top;"><p class="taba"><span class="literal">WHERE street = 'ZWICKY AVENUE'</span></p></td>
<td class="table-ca" style="vertical-align: top;"><p class="taba">306 ms</p></td>
<td class="table-ca" style="vertical-align: top;"><p class="taba">1 ms</p></td>
</tr>
</tbody>
</table>
<p class="indent">The execution times are much, much better, effectively a quarter second faster or more per query. Is a quarter second that impressive? Well, whether you’re seeking answers in data using repeated querying or creating a database system for thousands of users, the time savings adds up.</p>
<p class="indent">If you ever need to remove an index from a table—perhaps if you’re testing the performance of several index types—use the <span class="literal">DROP INDEX</span> command followed by the name of the index to remove.</p>
<h4 class="h4" id="lev118"><em>Considerations When Using Indexes</em></h4>
<p class="noindent">You’ve seen that indexes have significant performance benefits, so does that mean you should add an index to every column in a table? Not so fast! Indexes are valuable, but they’re not always needed. In addition, they do enlarge the database and impose a maintenance cost on writing data. Here are a few tips for judging when to uses indexes:</p>
<ul>
<li class="noindent">Consult the documentation for the database manager you’re using to learn about the kinds of indexes available and which to use on particular data types. PostgreSQL, for example, has five more index types in addition to B-Tree. One, called GiST, is particularly suited to the geometry data types I’ll discuss later in the book. Full text search, which you’ll learn in <a href="ch13.xhtml#ch13">Chapter 13</a>, also benefits from indexing.</li>
<li class="noindent">Consider adding indexes to any columns you’ll use in table joins. Primary keys are indexed by default in PostgreSQL, but foreign key columns in related tables are not and are a good target for indexes.</li>
<li class="noindent">Add indexes to columns that will frequently end up in a query <span class="literal">WHERE</span> clause. As you’ve seen, search performance is significantly improved via indexes.</li>
<li class="noindent">Use <span class="literal">EXPLAIN ANALYZE</span> to test performance under a variety of configurations if you’re unsure. Optimization is a process!</li>
</ul>
<h3 class="h3" id="lev119">Wrapping Up</h3>
<p class="noindent">With the tools you’ve added to your toolbox in this chapter, you’re ready to ensure that the databases you build or inherit are best suited for your collection and exploration of data. Your queries will run faster, you can exclude unwanted values, and your database objects will have consistent organization. That’s a boon for you and for others who share your data.</p>
<p class="indent">This chapter concludes the first part of the book, which focused on giving you the essentials to dig into SQL databases. I’ll continue building <span epub:type="pagebreak" id="page_112"/>on these foundations as we explore more complex queries and strategies for data analysis. In the next chapter, we’ll use SQL aggregate functions to assess the quality of a data set and get usable information from it.</p>
<div class="sidebar" id="ch07sb1">
<p class="sidebart"><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Are you ready to test yourself on the concepts covered in this chapter? Consider the following two tables from a database you’re making to keep track of your vinyl LP collection. Start by reviewing these <span class="literal">CREATE TABLE</span> statements:</p>
<p class="programs">CREATE TABLE albums (<br/>    album_id bigserial,<br/>    album_catalog_code varchar(100),<br/>    album_title text,<br/>    album_artist text,<br/>    album_release_date date,<br/>    album_genre varchar(40),<br/>    album_description text<br/>);<br/><br/>CREATE TABLE songs (<br/>    song_id bigserial,<br/>    song_title text,<br/>    song_artist text,<br/>    album_id bigint<br/>);</p>
<p class="spara1">The <span class="literal">albums</span> table includes information specific to the overall collection of songs on the disc. The <span class="literal">songs</span> table catalogs each track on the album. Each song has a title and its own artist column, because each song might feature its own collection of artists.</p>
<p class="spara1">Use the tables to answer these questions:</p>
<ol>
<li class="noindent"><p class="list">Modify these <span class="literal">CREATE TABLE</span> statements to include primary and foreign keys plus additional constraints on both tables. Explain why you made your choices.</p></li>
<li class="noindent"><p class="list">Instead of using <span class="literal">album_id</span> as a surrogate key for your primary key, are there any columns in <span class="literal">albums</span> that could be useful as a natural key? What would you have to know to decide?</p></li>
<li class="noindent"><p class="list">To speed up queries, which columns are good candidates for indexes?</p></li>
</ol>
</div>
</body>
</html>