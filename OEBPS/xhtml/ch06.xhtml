<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_73"/><strong><span class="big">6</span></strong><br/><strong>JOINING TABLES IN A RELATIONAL DATABASE</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">In <a href="ch01.xhtml#ch01">Chapter 1</a>, I introduced the concept of a <em>relational database</em>, an application that supports data stored across multiple, related tables. In a relational model, each table typically holds data on one entity—such as students, cars, purchases, houses—and each row in the table describes one of those entities. A process known as a <em>table join</em> allows us to link rows in one table to rows in other tables.</p>
<p class="indent">The concept of relational databases came from the British computer scientist Edgar F. Codd. While working for IBM in 1970, he published a paper called “A Relational Model of Data for Large Shared Data Banks.” His ideas revolutionized database design and led to the development of SQL. Using the relational model, you can build tables that eliminate duplicate data, are easier to maintain, and provide for increased flexibility in writing queries to get just the data you want.</p>
<h3 class="h3" id="lev81"><span epub:type="pagebreak" id="page_74"/>Linking Tables Using JOIN</h3>
<p class="noindent">To connect tables in a query, we use a <span class="literal">JOIN ... ON</span> statement (or one of the other <span class="literal">JOIN</span> variants I’ll cover in this chapter). The <span class="literal">JOIN</span> statement links one table to another in the database during a query, using matching values in columns we specify in both tables. The syntax takes this form:</p>
<p class="programs">SELECT *<br/>FROM <em>table_a</em> JOIN <em>table_b</em><br/>ON <em>table_a.key_column</em> = <em>table_b.foreign_key_column</em></p>
<p class="indent">This is similar to the basic <span class="literal">SELECT</span> syntax you’ve already learned, but instead of naming one table in the <span class="literal">FROM</span> clause, we name a table, give the <span class="literal">JOIN</span> keyword, and then name a second table. The <span class="literal">ON</span> keyword follows, where we specify the columns we want to use to match values. When the query runs, it examines both tables and then returns columns from both tables where the values match in the columns specified in the <span class="literal">ON</span> clause.</p>
<p class="indent">Matching based on equality between values is the most common use of the <span class="literal">ON</span> clause, but you can use any expression that evaluates to the <em>Boolean</em> results <span class="literal">true</span> or <span class="literal">false</span>. For example, you could match where values from one column are greater than or equal to values in the other:</p>
<p class="programs">ON <em>table_a.key_column</em> &gt;= <em>table_b.foreign_key_column</em></p>
<p class="indent">That’s rare, but it’s an option if your analysis requires it.</p>
<h3 class="h3" id="lev82">Relating Tables with Key Columns</h3>
<p class="noindent">Consider this example of relating tables with key columns: imagine you’re a data analyst with the task of checking on a public agency’s payroll spending by department. You file a Freedom of Information Act request for that agency’s salary data, expecting to receive a simple spreadsheet listing each employee and their salary, arranged like this:</p>
<p class="programs">dept    location    first_name    last_name    salary<br/>----    --------    ----------    ---------    ------<br/>Tax     Atlanta     Nancy         Jones        62500<br/>Tax     Atlanta     Lee           Smith        59300<br/>IT      Boston      Soo           Nguyen       83000<br/>IT      Boston      Janet         King         95000</p>
<p class="indent">But that’s not what arrives. Instead, the agency sends you a data dump from its payroll system: a dozen CSV files, each representing one table in its database. You read the document explaining the data layout (be sure to always ask for it!) and start to make sense of the columns in each table. Two of the tables stand out: one named <span class="literal">employees</span> and another named <span class="literal">departments</span>.</p>
<p class="indent">Using the code in <a href="ch06.xhtml#ch06list1">Listing 6-1</a>, let’s create versions of these tables, insert rows, and examine how to join the data in both tables. Using the <span class="literal">analysis</span> <span epub:type="pagebreak" id="page_75"/>database you’ve created for these exercises, run all the code, and then look at the data either by using a basic <span class="literal">SELECT</span> statement or clicking the table name in pgAdmin and selecting <strong>View/Edit Data <span class="ent">▸</span> All Rows</strong>.</p>
<p class="programs">CREATE TABLE departments (<br/>    dept_id bigserial,<br/>    dept varchar(100),<br/>    city varchar(100),<br/>  <span class="ent">➊</span> CONSTRAINT dept_key PRIMARY KEY (dept_id),<br/>  <span class="ent">➋</span> CONSTRAINT dept_city_unique UNIQUE (dept, city)<br/>);<br/><br/>CREATE TABLE employees (<br/>    emp_id bigserial,<br/>    first_name varchar(100),<br/>    last_name varchar(100),<br/>    salary integer,<br/>  <span class="ent">➌</span> dept_id integer REFERENCES departments (dept_id),<br/>  <span class="ent">➍</span> CONSTRAINT emp_key PRIMARY KEY (emp_id),<br/>  <span class="ent">➎</span> CONSTRAINT emp_dept_unique UNIQUE (emp_id, dept_id)<br/>);<br/><br/>INSERT INTO departments (dept, city)<br/>VALUES<br/>    ('Tax', 'Atlanta'),<br/>    ('IT', 'Boston');<br/>    <br/>INSERT INTO employees (first_name, last_name, salary, dept_id)<br/>VALUES<br/>    ('Nancy', 'Jones', 62500, 1),<br/>    ('Lee', 'Smith', 59300, 1),<br/>    ('Soo', 'Nguyen', 83000, 2),<br/>    ('Janet', 'King', 95000, 2);</p>
<p class="listing" id="ch06list1"><em>Listing 6-1: Creating the <span class="literal">departments</span> and <span class="literal">employees</span> tables</em></p>
<p class="indent">The two tables follow Codd’s relational model in that each describes attributes about a single entity, in this case the agency’s departments and employees. In the <span class="literal">departments</span> table, you should see the following contents:</p>
<p class="programs">dept_id    dept    city<br/>-------    ----    -------<br/>      1    Tax     Atlanta<br/>      2    IT      Boston</p>
<p class="indent">The <span class="literal">dept_id</span> column is the table’s primary key. A <em>primary key</em> is a column or collection of columns whose values uniquely identify each row in a table. A valid primary key column enforces certain constraints:</p>
<ul>
<li class="noindent">The column or collection of columns must have a unique value for each row.</li>
<li class="noindent">The column or collection of columns can’t have missing values.</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_76"/>You define the primary key for <span class="literal">departments</span> <span class="ent">➊</span> and <span class="literal">employees</span> <span class="ent">➍</span> using a <span class="literal">CONSTRAINT</span> keyword, which I’ll cover in depth with additional constraint types in <a href="ch07.xhtml#ch07">Chapter 7</a>. The <span class="literal">dept_id</span> column uniquely identifies the department, and although this example contains only a department name and city, such a table would likely include additional information, such as an address or contact information.</p>
<p class="indent">The <span class="literal">employees</span> table should have the following contents:</p>
<p class="programs">emp_id    first_name    last_name    salary    dept_id<br/>------    ----------    ---------    ------    -------<br/>     1    Nancy         Jones        62500           1<br/>     2    Lee           Smith        59300           1<br/>     3    Soo           Nguyen       83000           2<br/>     4    Janet         King         95000           2</p>
<p class="indent">The <span class="literal">emp_id</span> column uniquely identifies each row in the <span class="literal">employees</span> table. For you to know which department each employee works in, the table includes a <span class="literal">dept_id</span> column. The values in this column refer to values in the <span class="literal">departments</span> table’s primary key. We call this a <em>foreign key</em>, which you add as a constraint <span class="ent">➌</span> when creating the table. A foreign key constraint requires a value entered in a column to already exist in the primary key of the table it references. So, values in <span class="literal">dept_id</span> in the <span class="literal">employees</span> table must exist in <span class="literal">dept_id</span> in the <span class="literal">departments</span> table; otherwise, you can’t add them. Unlike a primary key, a foreign key column can be empty, and it can contain duplicate values.</p>
<p class="indent">In this example, the <span class="literal">dept_id</span> associated with the employee <span class="literal">Nancy Jones</span> is <span class="literal">1</span>; this refers to the value of <span class="literal">1</span> in the <span class="literal">departments</span> table’s primary key, <span class="literal">dept_id</span>. That tells us that <span class="literal">Nancy Jones</span> is part of the <span class="literal">Tax</span> department located in <span class="literal">Atlanta</span>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Primary key values only need to be unique within a table. That’s why it’s okay for both the <span class="literal">employees</span> table and the <span class="literal">departments</span> table to have primary key values using the same numbers.</em></p>
</div>
<p class="indent">Both tables also include a <span class="literal">UNIQUE</span> constraint, which I’ll also discuss in more depth in “The <span class="literal">UNIQUE</span> Constraint” on <a href="ch07.xhtml#page_105">page 105</a>. Briefly, it guarantees that values in a column, or a combination of values in more than one column, are unique. In <span class="literal">departments</span>, it requires that each row have a unique pair of values for <span class="literal">dept</span> and <span class="literal">city</span> <span class="ent">➋</span>. In <span class="literal">employees</span>, each row must have a unique pair of <span class="literal">emp_id</span> and <span class="literal">dept_id</span> <span class="ent">➎</span>. You add these constraints to avoid duplicate data. For example, you can’t have two tax departments in Atlanta.</p>
<p class="indent">You might ask: what is the advantage of breaking apart data into components like this? Well, consider what this sample of data would look like if you had received it the way you initially thought you would, all in one table:</p>
<p class="programs">dept    location    first_name    last_name    salary<br/>----    --------    ----------    ---------    ------<br/>Tax     Atlanta     Nancy         Jones        62500<br/>Tax     Atlanta     Lee           Smith        59300<br/>IT      Boston      Soo           Nguyen       83000<br/>IT      Boston      Janet         King         95000</p>
<p class="indent"><span epub:type="pagebreak" id="page_77"/>First, when you combine data from various entities in one table, inevitably you have to repeat information. This happens here: the department name and location is spelled out for each employee. This is fine when the table consists of four rows like this, or even 4,000. But when a table holds millions of rows, repeating lengthy strings is redundant and wastes precious space.</p>
<p class="indent">Second, cramming unrelated data into one table makes managing the data difficult. What if the Marketing department changes its name to Brand Marketing? Each row in the table would require an update. It’s simpler to store department names and locations in just one table and update it only once.</p>
<p class="indent">Now that you know the basics of how tables can relate, let’s look at how to join them in a query.</p>
<h3 class="h3" id="lev83">Querying Multiple Tables Using JOIN</h3>
<p class="noindent">When you join tables in a query, the database connects rows in both tables where the columns you specified for the join have matching values. The query results then include columns from both tables if you requested them as part of the query. You also can use columns from the joined tables to filter results using a <span class="literal">WHERE</span> clause.</p>
<p class="indent">Queries that join tables are similar in syntax to basic <span class="literal">SELECT</span> statements. The difference is that the query also specifies the following:</p>
<ul>
<li class="noindent">The tables and columns to join, using a SQL <span class="literal">JOIN ... ON</span> statement</li>
<li class="noindent">The type of join to perform using variations of the <span class="literal">JOIN</span> keyword</li>
</ul>
<p class="indent">Let’s look at the overall <span class="literal">JOIN ... ON</span> syntax first and then explore various types of joins. To join the example <span class="literal">employees</span> and <span class="literal">departments</span> tables and see all related data from both, start by writing a query like the one in <a href="ch06.xhtml#ch06list2">Listing 6-2</a>:</p>
<p class="programs"><span class="ent">➊</span> SELECT *<br/><span class="ent">➋</span> FROM employees JOIN departments<br/><span class="ent">➌</span> ON employees.dept_id = departments.dept_id;</p>
<p class="listing" id="ch06list2"><em>Listing 6-2: Joining the <span class="literal">employees</span> and <span class="literal">departments</span> tables</em></p>
<p class="indent">In the example, you include an asterisk wildcard with the <span class="literal">SELECT</span> statement to choose all columns from both tables <span class="ent">➊</span>. Next, the <span class="literal">JOIN</span> keyword <span class="ent">➋</span> goes between the two tables you want data from. Finally, you specify the columns to join the tables using the <span class="literal">ON</span> keyword <span class="ent">➌</span>. For each table, you provide the table name, a period, and the column that contains the key values. An equal sign goes between the two table and column names.</p>
<p class="indent"><span epub:type="pagebreak" id="page_78"/>When you run the query, the results include all values from both tables where values in the <span class="literal">dept_id</span> columns match. In fact, even the <span class="literal">dept_id</span> field appears twice because you selected all columns of both tables:</p>
<div class="image"><img alt="image" src="../images/prog_page_78.jpg"/></div>
<p class="indent">So, even though the data lives in two tables, each with a focused set of columns, you can query those tables to pull the relevant data back together. In <a href="ch06.xhtml#lev94">“Selecting Specific Columns in a Join”</a> on <a href="ch06.xhtml#page_85">page 85</a>, I’ll show you how to retrieve only the columns you want from both tables.</p>
<h3 class="h3" id="lev84">JOIN Types</h3>
<p class="noindent">There’s more than one way to join tables in SQL, and the type of join you’ll use depends on how you want to retrieve data. The following list describes the different types of joins. While reviewing each, it’s helpful to think of two tables side by side, one on the left of the <span class="literal">JOIN</span> keyword and the other on the right. A data-driven example of each join follows the list:</p>
<p class="hang"><span class="codestrong">JOIN</span> Returns rows from both tables where matching values are found in the joined columns of both tables. Alternate syntax is <span class="literal">INNER JOIN</span>.</p>
<p class="hang"><span class="codestrong">LEFT JOIN</span> Returns every row from the left table plus rows that match values in the joined column from the right table. When a left table row doesn’t have a match in the right table, the result shows no values from the right table.</p>
<p class="hang"><span class="codestrong">RIGHT JOIN</span> Returns every row from the right table plus rows that match the key values in the key column from the left table. When a right table row doesn’t have a match in the left table, the result shows no values from the left table.</p>
<p class="hang"><span class="codestrong">FULL OUTER JOIN</span> Returns every row from both tables and matches rows; then joins the rows where values in the joined columns match. If there’s no match for a value in either the left or right table, the query result contains an empty row for the other table.</p>
<p class="hang"><span class="codestrong">CROSS JOIN</span> Returns every possible combination of rows from both tables.</p>
<p class="indentt">These join types are best illustrated with data. Say you have two simple tables that hold names of schools. To better visualize join types, let’s call the tables <span class="literal">schools_left</span> and <span class="literal">schools_right</span>. There are four rows in <span class="literal">schools_left</span>:</p>
<p class="programs">id    left_school<br/>--    ------------------------<br/> 1    Oak Street School<br/> 2    Roosevelt High School<br/><span epub:type="pagebreak" id="page_79"/> 5    Washington Middle School<br/> 6    Jefferson High School</p>
<p class="indent">There are five rows in <span class="literal">schools_right</span>:</p>
<p class="programs">id    right_school<br/>--    ---------------------<br/> 1    Oak Street School<br/> 2    Roosevelt High School<br/> 3    Morrison Elementary<br/> 4    Chase Magnet Academy<br/> 6    Jefferson High School</p>
<p class="indent">Notice that only schools with the <span class="literal">id</span> of <span class="literal">1</span>, <span class="literal">2</span>, and <span class="literal">6</span> match in both tables. Working with two tables of similar data is a common scenario for a data analyst, and a common task would be to identify which schools exist in both tables. Using different joins can help you find those schools, plus other details.</p>
<p class="indent">Again using your <span class="literal">analysis</span> database, run the code in <a href="ch06.xhtml#ch06list3">Listing 6-3</a> to build and populate these two tables:</p>
<p class="programs">  CREATE TABLE schools_left (<br/>    <span class="ent">➊</span> id integer CONSTRAINT left_id_key PRIMARY KEY,<br/>      left_school varchar(30)<br/>  );<br/><br/>  CREATE TABLE schools_right (<br/>    <span class="ent">➋</span> id integer CONSTRAINT right_id_key PRIMARY KEY,<br/>      right_school varchar(30)<br/>  );<br/><br/><span class="ent">➌</span> INSERT INTO schools_left (id, left_school) VALUES<br/>      (1, 'Oak Street School'),<br/>      (2, 'Roosevelt High School'),<br/>      (5, 'Washington Middle School'),<br/>      (6, 'Jefferson High School');<br/><br/>  INSERT INTO schools_right (id, right_school) VALUES<br/>      (1, 'Oak Street School'),<br/>      (2, 'Roosevelt High School'),<br/>      (3, 'Morrison Elementary'),<br/>      (4, 'Chase Magnet Academy'),<br/>      (6, 'Jefferson High School');</p>
<p class="listing" id="ch06list3"><em>Listing 6-3: Creating two tables to explore <span class="literal">JOIN</span> types</em></p>
<p class="indent">We create and fill two tables: the declarations for these should by now look familiar, but there’s one new element: we add a primary key to each table. After the declaration for the <span class="literal">schools_left</span> <span class="literal">id</span> column <span class="ent">➊</span> and <span class="literal">schools_right</span> <span class="literal">id</span> column, <span class="ent">➋</span> the keywords <span class="literal">CONSTRAINT</span> <span class="codeitalic">key_name</span> <span class="literal">PRIMARY KEY</span> indicate that those columns will serve as the primary key for their table. <span epub:type="pagebreak" id="page_80"/>That means for each row in both tables, the <span class="literal">id</span> column must be filled and contain a value that is unique for each row in that table. Finally, we use the familiar <span class="literal">INSERT</span> statements <span class="ent">➌</span> to add the data to the tables.</p>
<h4 class="h4" id="lev85"><em>JOIN</em></h4>
<p class="noindent">We use <span class="literal">JOIN</span>, or <span class="literal">INNER</span> <span class="literal">JOIN</span>, when we want to return rows that have a match in the columns we used for the join. To see an example of this, run the code in <a href="ch06.xhtml#ch06list4">Listing 6-4</a>, which joins the two tables you just made:</p>
<p class="programs">SELECT *<br/>FROM schools_left JOIN schools_right<br/>ON schools_left.id = schools_right.id;</p>
<p class="listing" id="ch06list4"><em>Listing 6-4: Using <span class="literal">JOIN</span></em></p>
<p class="indent">Similar to the method we used in <a href="ch06.xhtml#ch06list2">Listing 6-2</a>, we specify the two tables to join around the <span class="literal">JOIN</span> keyword. Then we specify which columns we’re joining on, in this case the <span class="literal">id</span> columns of both tables. Three school IDs match in both tables, so <span class="literal">JOIN</span> returns only the three rows of those IDs that match. Schools that exist only in one of the two tables don’t appear in the result. Notice also that the columns from the left table display on the left of the result table:</p>
<p class="programs">id    left_school              id    right_school<br/>--    ---------------------    --    ---------------------<br/> 1    Oak Street School         1    Oak Street School<br/> 2    Roosevelt High School     2    Roosevelt High School<br/> 6    Jefferson High School     6    Jefferson High School</p>
<p class="indent">When should you use <span class="literal">JOIN</span>? Typically, when you’re working with well-structured, well-maintained data sets and only need to find rows that exist in all the tables you’re joining. Because <span class="literal">JOIN</span> doesn’t provide rows that exist in only one of the tables, if you want to see all the data in one or more of the tables, use one of the other join types.</p>
<h4 class="h4" id="lev86"><em>LEFT JOIN and RIGHT JOIN</em></h4>
<p class="noindent">In contrast to <span class="literal">JOIN</span>, the <span class="literal">LEFT JOIN</span> and <span class="literal">RIGHT JOIN</span> keywords each return all rows from one table and display blank rows from the other table if no matching values are found in the joined columns. Let’s look at <span class="literal">LEFT JOIN</span> in action first. Execute the code in <a href="ch06.xhtml#ch06list5">Listing 6-5</a>:</p>
<p class="programs">SELECT *<br/>FROM schools_left LEFT JOIN schools_right<br/>ON schools_left.id = schools_right.id;</p>
<p class="listing" id="ch06list5"><em>Listing 6-5: Using <span class="literal">LEFT JOIN</span></em></p>
<p class="indent"><span epub:type="pagebreak" id="page_81"/>The result of the query shows all four rows from <span class="literal">schools_left</span> as well as the three rows in <span class="literal">schools_right</span> where the <span class="literal">id</span> fields matched. Because <span class="literal">schools_right</span> doesn’t contain a value of <span class="literal">5</span> in its <span class="literal">right_id</span> column, there’s no match, so <span class="literal">LEFT</span> <span class="literal">JOIN</span> shows an empty row on the right rather than omitting the entire row from the left table as with <span class="literal">JOIN</span>. The rows from <span class="literal">schools_right</span> that don’t match any values in <span class="literal">schools_left</span> are omitted from the results:</p>
<p class="programs">id    left_school                 id    right_school<br/>--    ------------------------    --    ---------------------<br/> 1    Oak Street School            1    Oak Street School<br/> 2    Roosevelt High School        2    Roosevelt High School<br/> 5    Washington Middle School<br/> 6    Jefferson High School        6    Jefferson High School</p>
<p class="indent">We see similar but opposite behavior by running <span class="literal">RIGHT JOIN</span>, as in <a href="ch06.xhtml#ch06list6">Listing 6-6</a>:</p>
<p class="programs">SELECT *<br/>FROM schools_left RIGHT JOIN schools_right<br/>ON schools_left.id = schools_right.id;</p>
<p class="listing" id="ch06list6"><em>Listing 6-6: Using <span class="literal">RIGHT JOIN</span></em></p>
<p class="indent">This time, the query returns all rows from <span class="literal">schools_right</span> plus rows from <span class="literal">schools_left</span> where the <span class="literal">id</span> columns have matching values, but the query doesn’t return the rows of <span class="literal">schools_left</span> that don’t have a match with <span class="literal">schools_right</span>:</p>
<p class="programs">id    left_school              id    right_school<br/>--    ---------------------    --    ---------------------<br/> 1    Oak Street School         1    Oak Street School<br/> 2    Roosevelt High School     2    Roosevelt High School<br/>                                3    Morrison Elementary<br/>                                4    Chase Magnet Academy<br/> 6    Jefferson High School     6    Jefferson High School</p>
<p class="indent">You’d use either of these join types in a few circumstances:</p>
<ul>
<li class="noindent">You want your query results to contain all the rows from one of the tables.</li>
<li class="noindent">You want to look for missing values in one of the tables; for example, when you’re comparing data about an entity representing two different time periods.</li>
<li class="noindent">When you know some rows in a joined table won’t have matching values.</li>
</ul>
<h4 class="h4" id="lev87"><span epub:type="pagebreak" id="page_82"/><em>FULL OUTER JOIN</em></h4>
<p class="noindent">When you want to see all rows from both tables in a join, regardless of whether any match, use the <span class="literal">FULL OUTER JOIN</span> option. To see it in action, run <a href="ch06.xhtml#ch06list7">Listing 6-7</a>:</p>
<p class="programs">SELECT *<br/>FROM schools_left FULL OUTER JOIN schools_right<br/>ON schools_left.id = schools_right.id;</p>
<p class="listing" id="ch06list7"><em>Listing 6-7: Using <span class="literal">FULL OUTER JOIN</span></em></p>
<p class="indent">The result gives every row from the left table, including matching rows and blanks for missing rows from the right table, followed by any leftover missing rows from the right table:</p>
<p class="programs">id    left_school                 id    right_school<br/>--    ------------------------    --    ---------------------<br/> 1    Oak Street School            1    Oak Street School<br/> 2    Roosevelt High School        2    Roosevelt High School<br/> 5    Washington Middle School<br/> 6    Jefferson High School        6    Jefferson High School<br/>                                   4    Chase Magnet Academy<br/>                                   3    Morrison Elementary</p>
<p class="indent">A full outer join is admittedly less useful and used less often than inner and left or right joins. Still, you can use it for a couple of tasks: to merge two data sources that partially overlap or to visualize the degree to which the tables share matching values.</p>
<h4 class="h4" id="lev88"><em>CROSS JOIN</em></h4>
<p class="noindent">In a <span class="literal">CROSS JOIN</span> query, the result (also known as a <em>Cartesian product</em>) lines up each row in the left table with each row in the right table to present all possible combinations of rows. <a href="ch06.xhtml#ch06list8">Listing 6-8</a> shows the <span class="literal">CROSS JOIN</span> syntax; because the join doesn’t need to find matches between key fields, there’s no need to provide the clause using the <span class="literal">ON</span> keyword.</p>
<p class="programs">SELECT *<br/>FROM schools_left CROSS JOIN schools_right;</p>
<p class="listing" id="ch06list8"><em>Listing 6-8: Using <span class="literal">CROSS JOIN</span></em></p>
<p class="indent">The result has 20 rows—the product of four rows in the left table times five rows in the right:</p>
<p class="programs">id    left_school                 id    right_school<br/>--    ------------------------    --    ---------------------<br/> 1    Oak Street School            1    Oak Street School<br/> 1    Oak Street School            2    Roosevelt High School<br/> 1    Oak Street School            3    Morrison Elementary<br/> 1    Oak Street School            4    Chase Magnet Academy<br/><span epub:type="pagebreak" id="page_83"/> 1    Oak Street School            6    Jefferson High School<br/> 2    Roosevelt High School        1    Oak Street School<br/> 2    Roosevelt High School        2    Roosevelt High School<br/> 2    Roosevelt High School        3    Morrison Elementary<br/> 2    Roosevelt High School        4    Chase Magnet Academy<br/> 2    Roosevelt High School        6    Jefferson High School<br/> 5    Washington Middle School     1    Oak Street School<br/> 5    Washington Middle School     2    Roosevelt High School<br/> 5    Washington Middle School     3    Morrison Elementary<br/> 5    Washington Middle School     4    Chase Magnet Academy<br/> 5    Washington Middle School     6    Jefferson High School<br/> 6    Jefferson High School        1    Oak Street School<br/> 6    Jefferson High School        2    Roosevelt High School<br/> 6    Jefferson High School        3    Morrison Elementary<br/> 6    Jefferson High School        4    Chase Magnet Academy<br/> 6    Jefferson High School        6    Jefferson High School</p>
<p class="indent">Unless you want to take an extra-long coffee break, I’d suggest avoiding a <span class="literal">CROSS JOIN</span> query on large tables. Two tables with 250,000 records each would produce a result set of 62.5 <em>billion</em> rows and tax even the hardiest server. A more practical use would be generating data to create a checklist, such as all colors you’d want to offer for each shirt style in a warehouse.</p>
<h3 class="h3" id="lev89">Using NULL to Find Rows with Missing Values</h3>
<p class="noindent">Being able to reveal missing data from one of the tables is valuable when you’re digging through data. Any time you join tables, it’s wise to vet the quality of the data and understand it better by discovering whether all key values in one table appear in another. There are many reasons why a discrepancy might exist, such as a clerical error, incomplete output from the database, or some change in the data over time. All this information is important context for making correct inferences about the data.</p>
<p class="indent">When you have only a handful of rows, eyeballing the data is an easy way to look for rows with missing data. For large tables, you need a better strategy: filtering to show all rows without a match. To do this, we employ the keyword <span class="literal">NULL</span>.</p>
<p class="indent">In SQL, <span class="literal">NULL</span> is a special value that represents a condition in which there’s no data present or where the data is unknown because it wasn’t included. For example, if a person filling out an address form skips the “Middle Initial” field, rather than storing an empty string in the database, we’d use <span class="literal">NULL</span> to represent the unknown value. It’s important to keep in mind that <span class="literal">NULL</span> is different from <span class="literal">0</span> or an empty string that you’d place in a character field using two quotes (<span class="literal">""</span>). Both those values could have some unintended meaning that’s open to misinterpretation, so you use <span class="literal">NULL</span> to show that the value is unknown. And unlike <span class="literal">0</span> or an empty string, you can use <span class="literal">NULL</span> across data types.</p>
<p class="indent">When a SQL join returns empty rows in one of the tables, those columns don’t come back empty but instead come back with the value <span class="literal">NULL</span>. In <span epub:type="pagebreak" id="page_84"/><a href="ch06.xhtml#ch06list9">Listing 6-9</a>, we’ll find those rows by adding a <span class="literal">WHERE</span> clause to filter for <span class="literal">NULL</span> by using the phrase <span class="literal">IS NULL</span> on the <span class="literal">right_id</span> column. If we wanted to look for columns <em>with</em> data, we’d use <span class="literal">IS NOT NULL</span>.</p>
<p class="programs">SELECT *<br/>FROM schools_left LEFT JOIN schools_right<br/>ON schools_left.id = schools_right.id<br/>WHERE schools_right.id IS NULL;</p>
<p class="listing" id="ch06list9"><em>Listing 6-9: Filtering to show missing values with <span class="literal">IS NULL</span></em></p>
<p class="indent">Now the result of the join shows only the one row from the left table that didn’t have a match on the right side.</p>
<p class="programs">id    left_school                 id    right_school<br/>--    ------------------------    --    ------------<br/> 5    Washington Middle School</p>
<h3 class="h3" id="lev90">Three Types of Table Relationships</h3>
<p class="noindent">Part of the science (or art, some may say) of joining tables involves understanding how the database designer intends for the tables to relate, also known as the database’s <em>relational model</em>. The three types of table relationships are one to one, one to many, and many to many.</p>
<h4 class="h4" id="lev91"><em>One-to-One Relationship</em></h4>
<p class="noindent">In our <span class="literal">JOIN</span> example in <a href="ch06.xhtml#ch06list4">Listing 6-4</a>, there is only one match for an <span class="literal">id</span> in each of the two tables. In addition, there are no duplicate <span class="literal">id</span> values in either table: only one row in the left table exists with an <span class="literal">id</span> of <span class="literal">1</span>, and only one row in the right table has an <span class="literal">id</span> of <span class="literal">1</span>. In database parlance, this is called a <em>one-to-one</em> relationship. Consider another example: joining two tables with state-by-state census data. One table might contain household income data and the other data on educational attainment. Both tables would have 51 rows (one for each state plus Washington, D.C.), and if we wanted to join them on a key such as state name, state abbreviation, or a standard geography code, we’d have only one match for each key value in each table.</p>
<h4 class="h4" id="lev92"><em>One-to-Many Relationship</em></h4>
<p class="noindent">In a <em>one-to-many</em> relationship, a key value in the first table will have multiple matching values in the second table’s joined column. Consider a database that tracks automobiles. One table would hold data on automobile manufacturers, with one row each for Ford, Honda, Kia, and so on. A second table with model names, such as Focus, Civic, Sedona, and Accord, would have several rows matching each row in the manufacturers’ table.</p>
<h4 class="h4" id="lev93"><span epub:type="pagebreak" id="page_85"/><em>Many-to-Many Relationship</em></h4>
<p class="noindent">In a <em>many-to-many</em> relationship, multiple rows in the first table will have multiple matching rows in the second table. As an example, a table of baseball players could be joined to a table of field positions. Each player can be assigned to multiple positions, and each position can be played by multiple people.</p>
<p class="indent">Understanding these relationships is essential because it helps us discern whether the results of queries accurately reflect the structure of the database.</p>
<h3 class="h3" id="lev94">Selecting Specific Columns in a Join</h3>
<p class="noindent">So far, we’ve used the asterisk wildcard to select all columns from both tables. That’s okay for quick data checks, but more often you’ll want to specify a subset of columns. You can focus on just the data you want and avoid inadvertently changing the query results if someone adds a new column to a table.</p>
<p class="indent">As you learned in single-table queries, to select particular columns you use the <span class="literal">SELECT</span> keyword followed by the desired column names. When joining tables, the syntax changes slightly: you must include the column as well as its table name. The reason is that more than one table can contain columns with the same name, which is certainly true of our joined tables so far.</p>
<p class="indent">Consider the following query, which tries to fetch an <span class="literal">id</span> column without naming the table:</p>
<p class="programs">SELECT id<br/>FROM schools_left LEFT JOIN schools_right<br/>ON schools_left.id = schools_right.id;</p>
<p class="indent">Because <span class="literal">id</span> exists in both <span class="literal">schools_left</span> and <span class="literal">schools_right</span>, the server throws an error that appears in pgAdmin’s results pane: <span class="literal">column reference "id" is ambiguous</span>. It’s not clear which table <span class="literal">id</span> belongs to.</p>
<p class="indent">To fix the error, we need to add the table name in front of each column we’re querying, as we do in the <span class="literal">ON</span> clause. <a href="ch06.xhtml#ch06list10">Listing 6-10</a> shows the syntax, specifying that we want the <span class="literal">id</span> column from <span class="literal">schools_left</span>. We’re also fetching the school names from both tables.</p>
<p class="programs">SELECT schools_left.id,<br/>       schools_left.left_school,<br/>       schools_right.right_school<br/>FROM schools_left LEFT JOIN schools_right<br/>ON schools_left.id = schools_right.id;</p>
<p class="listing" id="ch06list10"><em>Listing 6-10: Querying specific columns in a join</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_86"/>We simply prefix each column name with the table it comes from, and the rest of the query syntax is the same. The result returns the requested columns from each table:</p>
<p class="programs">id    left_school                 right_school<br/>--    ------------------------    ---------------------<br/> 1    Oak Street School           Oak Street School<br/> 2    Roosevelt High School       Roosevelt High School<br/> 5    Washington Middle School<br/> 6    Jefferson High School       Jefferson High School</p>
<p class="indent">We can also add the <span class="literal">AS</span> keyword we used previously with census data to make it clear in the results that the <span class="literal">id</span> column is from <span class="literal">schools_left</span>. The syntax would look like this:</p>
<p class="programs">SELECT schools_left.id AS left_id, ...</p>
<p class="indent">This would display the name of the <span class="literal">schools_left id</span> column as <span class="literal">left_id</span>. We could do this for all the other columns we select using the same syntax, but the next section describes another, better method we can use to rename multiple columns.</p>
<h3 class="h3" id="lev95">Simplifying JOIN Syntax with Table Aliases</h3>
<p class="noindent">Naming the table for a column is easy enough, but doing so for multiple columns clutters your code. One of the best ways to serve your colleagues is to write code that’s readable, which should generally not involve making them wade through table names repeated for 25 columns! The way to write more concise code is to use a shorthand approach called <em>table aliases</em>.</p>
<p class="indent">To create a table alias, we place a character or two after the table name when we declare it in the <span class="literal">FROM</span> clause. (You can use more than a couple of characters for an alias, but if the goal is to simplify code, don’t go overboard.) Those characters then serve as an alias we can use instead of the full table name anywhere we reference the table in the code. <a href="ch06.xhtml#ch06list11">Listing 6-11</a> demonstrates how this works:</p>
<p class="programs">  SELECT lt.id,<br/>         lt.left_school,<br/>         rt.right_school<br/><span class="ent">➊</span> FROM schools_left AS lt LEFT JOIN schools_right AS rt<br/>  ON lt.id = rt.id;</p>
<p class="listing" id="ch06list11"><em>Listing 6-11: Simplifying code with table aliases</em></p>
<p class="indent">In the <span class="literal">FROM</span> clause, we declare the alias <span class="literal">lt</span> to represent <span class="literal">schools_left</span> and the alias <span class="literal">rt</span> to represent <span class="literal">schools_right</span> <span class="ent">➊</span> using the <span class="literal">AS</span> keyword. Once that’s in place, we can use the aliases instead of the full table names everywhere else in the code. Immediately, our SQL looks more compact, and that’s ideal.</p>
<h3 class="h3" id="lev96"><span epub:type="pagebreak" id="page_87"/>Joining Multiple Tables</h3>
<p class="noindent">Of course, SQL joins aren’t limited to two tables. We can continue adding tables to the query as long as we have columns with matching values to join on. Let’s say we obtain two more school-related tables and want to join them to <span class="literal">schools_left</span> in a three-table join. Here are the tables: <span class="literal">schools_enrollment</span> has the number of students per school:</p>
<p class="programs">id    enrollment<br/>--    ----------<br/> 1           360<br/> 2          1001<br/> 5           450<br/> 6           927</p>
<p class="indent">The <span class="literal">schools_grades</span> table contains the grade levels housed in each building:</p>
<p class="programs">id    grades<br/>--    ------<br/> 1    K-3<br/> 2    9-12<br/> 5    6-8<br/> 6    9-12</p>
<p class="indent">To write the query, we’ll use <a href="ch06.xhtml#ch06list12">Listing 6-12</a> to create the tables and load the data:</p>
<p class="programs">  CREATE TABLE schools_enrollment (<br/>      id integer,<br/>      enrollment integer<br/>  );<br/><br/>  CREATE TABLE schools_grades (<br/>      id integer,<br/>      grades varchar(10)<br/>  );<br/><br/>  INSERT INTO schools_enrollment (id, enrollment)<br/>  VALUES<br/>      (1, 360),<br/>      (2, 1001),<br/>      (5, 450),<br/>      (6, 927);<br/><br/>  INSERT INTO schools_grades (id, grades)<br/>  VALUES<br/>      (1, 'K-3'),<br/>      (2, '9-12'),<br/>      (5, '6-8'),<br/>      (6, '9-12');<br/><span epub:type="pagebreak" id="page_88"/>  SELECT lt.id, lt.left_school, en.enrollment, gr.grades<br/><span class="ent">➊</span> FROM schools_left AS lt LEFT JOIN schools_enrollment AS en<br/>      ON lt.id = en.id<br/><span class="ent">➋</span> LEFT JOIN schools_grades AS gr<br/>      ON lt.id = gr.id;</p>
<p class="listing" id="ch06list12"><em>Listing 6-12: Joining multiple tables</em></p>
<p class="indent">After we run the <span class="literal">CREATE TABLE</span> and <span class="literal">INSERT</span> portions of the script, the results consist of <span class="literal">schools_enrollment</span> and <span class="literal">schools_grades</span> tables, each with records that relate to <span class="literal">schools_left</span> from earlier in the chapter. We then connect all three tables.</p>
<p class="indent">In the <span class="literal">SELECT</span> query, we join <span class="literal">schools_left</span> to <span class="literal">schools_enrollment</span> <span class="ent">➊</span> using the tables’ <span class="literal">id</span> fields. We also declare table aliases to keep the code compact. Next, the query joins <span class="literal">schools_left</span> to <span class="literal">school_grades</span> again on the <span class="literal">id</span> fields <span class="ent">➋</span>.</p>
<p class="indent">Our result now includes columns from all three tables:</p>
<p class="programs">id    left_school                 enrollment    grades<br/>--    ------------------------    ----------    ------<br/> 1    Oak Street School                  360    K-3<br/> 2    Roosevelt High School             1001    9-12<br/> 5    Washington Middle School           450    6-8<br/> 6    Jefferson High School              927    9-12</p>
<p class="indent">If you need to, you can add even more tables to the query using additional joins. You can also join on different columns, depending on the tables’ relationships. Although there is no hard limit in SQL to the number of tables you can join in a single query, some database systems might impose one. Check the documentation.</p>
<h3 class="h3" id="lev97">Performing Math on Joined Table Columns</h3>
<p class="noindent">The math functions we explored in <a href="ch05.xhtml#ch05">Chapter 5</a> are just as usable when working with joined tables. We just need to include the table name when referencing a column in an operation, as we did when selecting table columns. If you work with any data that has a new release at regular intervals, you’ll find this concept useful for joining a newly released table to an older one and exploring how values have changed.</p>
<p class="indent">That’s certainly what I and many journalists do each time a new set of census data is released. We’ll load the new data and try to find patterns in the growth or decline of the population, income, education, and other indicators. Let’s look at how to do this by revisiting the <span class="literal">us_counties_2010</span> table we created in <a href="ch04.xhtml#ch04">Chapter 4</a> and loading similar county data from the previous Decennial Census, in 2000, to a new table. Run the code in <a href="ch06.xhtml#ch06list13">Listing 6-13</a>, making sure you’ve saved the CSV file somewhere first:</p>
<p class="programs"><span class="ent">➊</span> CREATE TABLE us_counties_2000 (<br/>      geo_name varchar(90),<br/>      state_us_abbreviation varchar(2),<br/>      state_fips varchar(2),<br/><span epub:type="pagebreak" id="page_89"/>      county_fips varchar(3),<br/>      p0010001 integer,<br/>      p0010002 integer,<br/>      p0010003 integer,<br/>      p0010004 integer,<br/>      p0010005 integer,<br/>      p0010006 integer,<br/>      p0010007 integer,<br/>      p0010008 integer,<br/>      p0010009 integer,<br/>      p0010010 integer,<br/>      p0020002 integer,<br/>      p0020003 integer<br/>  );<br/><br/><span class="ent">➋</span> COPY us_counties_2000<br/>  FROM '<em>C:\YourDirectory\</em>us_counties_2000.csv'<br/>  WITH (FORMAT CSV, HEADER);<br/><br/><span class="ent">➌</span> SELECT c2010.geo_name,<br/>         c2010.state_us_abbreviation AS state,<br/>         c2010.p0010001 AS pop_2010,<br/>         c2000.p0010001 AS pop_2000<br/>         c2010.p0010001 - c2000.p0010001 AS raw_change,<br/>       <span class="ent">➍</span> round( (CAST(c2010.p0010001 AS numeric(8,1)) - c2000.p0010001)<br/>             / c2000.p0010001 * 100, 1 ) AS pct_change<br/>  FROM us_counties_2010 c2010 INNER JOIN us_counties_2000 c2000<br/><span class="ent">➎</span> ON c2010.state_fips = c2000.state_fips<br/>     AND c2010.county_fips = c2000.county_fips<br/>   <span class="ent">➏</span> AND c2010.p0010001 &lt;&gt; c2000.p0010001<br/><span class="ent">➐</span> ORDER BY pct_change DESC;</p>
<p class="listing" id="ch06list13"><em>Listing 6-13: Performing math on joined census tables</em></p>
<p class="indent">In this code, we’re building on earlier foundations. We have the familiar <span class="literal">CREATE TABLE</span> statement <span class="ent">➊</span>, which for this exercise includes state and county codes, a <span class="literal">geo_name</span> column with the full name of the state and county, and nine columns with population counts including total population and counts by race. The <span class="literal">COPY</span> statement <span class="ent">➋</span> imports a CSV file with the census data; you can find <em>us_counties_2000.csv</em> along with all of the book’s resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>. After you’ve downloaded the file, you’ll need to change the file path to the location where you saved it.</p>
<p class="indent">When you’ve finished the import, you should have a table named <span class="literal">us_counties_2000</span> with 3,141 rows. As with the 2010 data, this table has a column named <span class="literal">p0010001</span> that contains the total population for each county in the United States. Because both tables have the same column, it makes sense to calculate the percent change in population for each county between 2000 and 2010. Which counties have led the nation in growth? Which ones have a decline in population?</p>
<p class="indent">We’ll use the percent change calculation we used in <a href="ch05.xhtml#ch05">Chapter 5</a> to get the answer. The <span class="literal">SELECT</span> statement <span class="ent">➌</span> includes the county’s name and state abbreviation from the 2010 table, which is aliased with <span class="literal">c2010</span>. Next are <span epub:type="pagebreak" id="page_90"/>the <span class="literal">p0010001</span> total population columns from the 2010 and 2000 tables, both renamed with unique names using <span class="literal">AS</span> to distinguish them in the results. To get the raw change in population, we subtract the 2000 population from the 2010 count, and to find the percent change, we employ a formula <span class="ent">➍</span> and round the results to one decimal point.</p>
<p class="indent">We join by matching values in two columns in both tables: <span class="literal">state_fips</span> and <span class="literal">county_fips</span> <span class="ent">➎</span>. The reason to join on two columns instead of one is that in both tables, we need the combination of a state code and a county code to find a unique county. I’ve added a third condition <span class="ent">➏</span> to illustrate using an inequality. This limits the join to counties where the <span class="literal">p0010001</span> population column has a different value. We combine all three conditions using the <span class="literal">AND</span> keyword. Using that syntax, a join happens when all three conditions are satisfied. Finally, the results are sorted in descending order by percent change <span class="ent">➐</span> so we can see the fastest growers at the top.</p>
<p class="indent">That’s a lot of work, but it’s worth it. Here’s what the first five rows of the results indicate:</p>
<div class="image"><img alt="image" src="../images/prog_page_90.jpg"/></div>
<p class="indent">Two counties, Kendall in Illinois and Pinal in Arizona, more than doubled their population in 10 years, with counties in Florida, South Dakota, and Virginia not far behind. That’s a valuable story we’ve extracted from this analysis and a starting point for understanding national population trends. If you were to dig into the data further, you might find that many of the counties with the largest growth from 2000 to 2010 were suburban bedroom communities that benefited from the decade’s housing boom, and that a more recent trend sees Americans leaving rural areas to move to cities. That could make for an interesting analysis following the 2020 Decennial Census.</p>
<h3 class="h3" id="lev98">Wrapping Up</h3>
<p class="noindent">Given that table relationships are foundational to database architecture, learning to join tables in queries allows you to handle many of the more complex data sets you’ll encounter. Experimenting with the different types of joins on tables can tell you a great deal about how data have been gathered and reveal when there’s a quality issue. Make trying various joins a routine part of your exploration of a new data set.</p>
<p class="indent">Moving forward, we’ll continue building on these bigger concepts as we drill deeper into finding information in data sets and working with the finer nuances of handling data types and making sure we have quality data. But first, we’ll look at one more foundational element: employing best practices to build reliable, speedy databases with SQL.</p>
<div class="sidebar" id="ch06sb1">
<p class="sidebart"><span epub:type="pagebreak" id="page_91"/><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Continue your exploration of joins with these exercises:</p>
<ol>
<li class="noindent"><p class="list">The table <span class="literal">us_counties_2010</span> contains 3,143 rows, and <span class="literal">us_counties_2000</span> has 3,141. That reflects the ongoing adjustments to county-level geographies that typically result from government decision making. Using appropriate joins and the <span class="literal">NULL</span> value, identify which counties don’t exist in both tables. For fun, search online to find out why they’re missing.</p></li>
<li class="noindent"><p class="list">Using either the <span class="literal">median()</span> or <span class="literal">percentile_cont()</span> functions in <a href="ch05.xhtml#ch05">Chapter 5</a>, determine the median of the percent change in county population.</p></li>
<li class="noindent"><p class="list">Which county had the greatest percentage loss of population between 2000 and 2010? Do you have any idea why? (Hint: A major weather event happened in 2005.)<span epub:type="pagebreak" id="page_92"/></p></li>
</ol>
</div>
</body>
</html>