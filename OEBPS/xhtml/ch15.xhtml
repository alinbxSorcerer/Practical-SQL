<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_267"/><strong><span class="big">15</span></strong><br/><strong>SAVING TIME WITH VIEWS, FUNCTIONS, AND TRIGGERS</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">One of the advantages of using a programming language is that it allows us to automate repetitive, boring tasks. For example, if you have to run the same query every month to update the same table, sooner or later you’ll search for a shortcut to accomplish the task. The good news is that shortcuts exist! In this chapter, you’ll learn techniques to encapsulate queries and logic into reusable PostgreSQL database objects that will speed up your workflow. As you read through this chapter, keep in mind the DRY programming principle: Don’t Repeat Yourself. Avoiding repetition saves time and prevents unnecessary mistakes.</p>
<p class="indent">You’ll begin by learning to save queries as reusable database <em>views</em>. Next, you’ll explore how to create your own functions to perform operations on your data. You’ve already used functions, such as <span class="literal">round()</span> and <span class="literal">upper()</span>, to transform data; now, you’ll make functions to perform <span epub:type="pagebreak" id="page_268"/>operations you specify. Then you’ll set up <em>triggers</em> to run functions automatically when certain events occur on a table. Using these techniques, you can reduce repetitive work and help maintain the integrity of your data.</p>
<p class="indent">We’ll use tables created from examples in earlier chapters to practice these techniques. If you connected to the <span class="literal">gis_analysis</span> database in pgAdmin while working through <a href="ch14.xhtml#ch14">Chapter 14</a>, follow the instructions in that chapter to return to the <span class="literal">analysis</span> database. All the code for this chapter is available for download along with the book’s resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>. Let’s get started.</p>
<h3 class="h3" id="lev267">Using Views to Simplify Queries</h3>
<p class="noindent">A <em>view</em> is a virtual table you can create dynamically using a saved query. For example, every time you access the view, the saved query runs automatically and displays the results. Similar to a regular table, you can query a view, join a view to regular tables (or other views), and use the view to update or insert data into the table it’s based on, albeit with some caveats.</p>
<p class="indent">In this section, we’ll look at regular views with a PostgreSQL syntax that is largely in line with the ANSI SQL standard. These views execute their underlying query each time you access the view, but they don’t store data the way a table does. A <em>materialized view</em>, which is specific to PostgreSQL, Oracle, and a limited number of other database systems, caches data created by the view, and you can later update that cached data. We won’t explore materialized views here, but you can browse to <em><a href="https://www.postgresql.org/docs/current/static/sql-creatematerializedview.html">https://www.postgresql.org/docs/current/static/sql-creatematerializedview.html</a></em> to learn more.</p>
<p class="indent">Views are especially useful because they allow you to:</p>
<ul>
<li class="noindent"><p class="list"><strong>Avoid duplicate effort</strong> by letting you write a query once and access the results when needed</p></li>
<li class="noindent"><p class="list"><strong>Reduce complexity</strong> for yourself or other database users by showing only columns relevant to your needs</p></li>
<li class="noindent"><p class="list"><strong>Provide security</strong> by limiting access to only certain columns in a table</p></li>
</ul>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>To ensure data security and fully prevent users from seeing sensitive information, such as the underlying salary data in the <span class="literal">employees</span> table, you must restrict access by setting account permissions in PostgreSQL. Typically, a database administrator handles this function for an organization, but if you want to explore this issue further, read the PostgreSQL documentation on user roles at</em> <a href="https://www.postgresql.org/docs/current/static/sql-createrole.html">https://www.postgresql.org/docs/current/static/sql-createrole.html</a> <em>and the <span class="literal">GRANT</span> command at</em> <a href="https://www.postgresql.org/docs/current/static/sql-grant.html">https://www.postgresql.org/docs/current/static/sql-grant.html</a>.</p>
</div>
<p class="indent">Views are easy to create and maintain. Let’s work through several examples to see how they work.</p>
<h4 class="h4" id="lev268"><span epub:type="pagebreak" id="page_269"/><em>Creating and Querying Views</em></h4>
<p class="noindent">In this section, we’ll use data in the Decennial U.S. Census <span class="literal">us_counties_2010</span> table you imported in <a href="ch04.xhtml#ch04">Chapter 4</a>. <a href="ch15.xhtml#ch15list1">Listing 15-1</a> uses this data to create a view called <span class="literal">nevada_counties_pop_2010</span> that displays only four out of the original 16 columns, showing data on just Nevada counties:</p>
<p class="programs"><span class="ent">➊</span> CREATE OR REPLACE VIEW nevada_counties_pop_2010 AS<br/>    <span class="ent">➋</span> SELECT geo_name,<br/>             state_fips,<br/>             county_fips,<br/>             p0010001 AS pop_2010<br/>      FROM us_counties_2010<br/>      WHERE state_us_abbreviation = 'NV'<br/>    <span class="ent">➌</span> ORDER BY county_fips;</p>
<p class="listing" id="ch15list1"><em>Listing 15-1: Creating a view that displays Nevada 2010 counties</em></p>
<p class="indent">Here, we define the view using the keywords <span class="literal">CREATE OR REPLACE VIEW</span> <span class="ent">➊</span>, followed by the view’s name and <span class="literal">AS</span>. Next is a standard SQL query <span class="literal">SELECT</span> <span class="ent">➋</span> that fetches the total population (the <span class="literal">p0010001</span> column) for each Nevada county from the <span class="literal">us_counties_2010</span> table. Then we order the data by the county’s FIPS (Federal Information Processing Standards) code <span class="ent">➌</span>, which is a standard designator the Census Bureau and other federal agencies use to specify each county and state.</p>
<p class="indent">Notice the <span class="literal">OR REPLACE</span> keywords after <span class="literal">CREATE</span>, which tell the database that if a view with this name already exists, replace it with the definition here. But here’s a caveat according to the PostgreSQL documentation: the query that generates the view <span class="ent">➋</span> must have the columns with the same names and same data types in the same order as the view it’s replacing. However, you can add columns at the end of the column list.</p>
<p class="indent">Run the code in <a href="ch15.xhtml#ch15list1">Listing 15-1</a> using pgAdmin. The database should respond with the message <span class="literal">CREATE VIEW</span>. To find the view you created, in pgAdmin’s object browser, right-click the <span class="literal">analysis</span> database and choose <strong>Refresh</strong>. Choose <strong>Schemas <span class="ent">▸</span> public <span class="ent">▸</span> Views</strong> to see the new view. When you right-click the view and choose <strong>Properties</strong>, you should see the query under the <strong>Definition</strong> tab in the dialog that opens.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>As with other database objects, you can delete a view using the <span class="literal">DROP</span> command. In this example, the syntax would be <span class="literal">DROP VIEW nevada_counties_pop_2010;</span>.</em></p>
</div>
<p class="indent">After creating the view, you can use the view in the <span class="literal">FROM</span> clause of a <span class="literal">SELECT</span> query the same way you would use an ordinary table. Enter the code in <a href="ch15.xhtml#ch15list2">Listing 15-2</a>, which retrieves the first five rows from the view:</p>
<p class="programs">SELECT *<br/>FROM nevada_counties_pop_2010<br/>LIMIT 5;</p>
<p class="listing" id="ch15list2"><em>Listing 15-2: Querying the <span class="literal">nevada_counties_pop_2010</span> view</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_270"/>Aside from the five-row limit, the result should be the same as if you had run the <span class="literal">SELECT</span> query used to create the view in <a href="ch15.xhtml#ch15list1">Listing 15-1</a>:</p>
<p class="programs">geo_name            state_fips    county_fips    pop_2010<br/>----------------    ----------    -----------    --------<br/>Churchill County    32            001               24877<br/>Clark County        32            003             1951269<br/>Douglas County      32            005               46997<br/>Elko County         32            007               48818<br/>Esmeralda County    32            009                 783</p>
<p class="indent">This simple example isn’t very useful unless quickly listing Nevada county population is a task you’ll perform frequently. So, let’s imagine a question data-minded analysts in a political research organization might ask often: what was the percent change in population for each county in Nevada (or any other state) from 2000 to 2010?</p>
<p class="indent">We wrote a query to answer this question in <a href="ch06.xhtml#ch06list13">Listing 6-13</a> (see <a href="ch06.xhtml#lev97">“Performing Math on Joined Table Columns”</a> on <a href="ch06.xhtml#page_88">page 88</a>). It wasn’t onerous to create, but it did require joining tables on two columns and using a percent change formula that involved rounding and type casting. To avoid repeating that work, we can save a query similar to the one in <a href="ch06.xhtml#ch06list13">Listing 6-13</a> as a view. <a href="ch15.xhtml#ch15list3">Listing 15-3</a> does this using a modified version of the earlier code in <a href="ch15.xhtml#ch15list1">Listing 15-1</a>:</p>
<p class="programs"><span class="ent">➊</span> CREATE OR REPLACE VIEW county_pop_change_2010_2000 AS<br/>    <span class="ent">➋</span> SELECT c2010.geo_name,<br/>             c2010.state_us_abbreviation AS st,<br/>             c2010.state_fips,<br/>             c2010.county_fips,<br/>             c2010.p0010001 AS pop_2010,<br/>             c2000.p0010001 AS pop_2000,<br/>           <span class="ent">➌</span> round( (CAST(c2010.p0010001 AS numeric(8,1)) - c2000.p0010001)<br/>                 / c2000.p0010001 * 100, 1 ) AS pct_change_2010_2000<br/>    <span class="ent">➍</span> FROM us_counties_2010 c2010 INNER JOIN us_counties_2000 c2000<br/>      ON c2010.state_fips = c2000.state_fips<br/>         AND c2010.county_fips = c2000.county_fips<br/>      ORDER BY c2010.state_fips, c2010.county_fips;</p>
<p class="listing" id="ch15list3"><em>Listing 15-3: Creating a view showing population change for U.S. counties</em></p>
<p class="indent">We start the view definition with <span class="literal">CREATE OR REPLACE VIEW</span> <span class="ent">➊</span>, followed by the name of the view and <span class="literal">AS</span>. The <span class="literal">SELECT</span> query <span class="ent">➋</span> names columns from the census tables and includes a column definition with a percent change calculation <span class="ent">➌</span> that you learned about in <a href="ch05.xhtml#ch05">Chapter 5</a>. Then we join the Census 2010 and 2000 tables <span class="ent">➍</span> using the state and county FIPS codes. Run the code, and the database should again respond with <span class="literal">CREATE VIEW</span>.</p>
<p class="indent">Now that we’ve created the view, we can use the code in <a href="ch15.xhtml#ch15list4">Listing 15-4</a> to run a simple query against the new view that retrieves data for Nevada counties:</p>
<p class="programs">  SELECT geo_name,<br/>         st,<br/><span epub:type="pagebreak" id="page_271"/>         pop_2010,<br/>       <span class="ent">➊</span> pct_change_2010_2000<br/>  FROM county_pop_change_2010_2000<br/><span class="ent">➋</span> WHERE st = 'NV'<br/>  LIMIT 5;</p>
<p class="listing" id="ch15list4"><em>Listing 15-4: Selecting columns from the <span class="literal">county_pop_change_2010_2000</span> view</em></p>
<p class="indent">In <a href="ch15.xhtml#ch15list2">Listing 15-2</a>, in the query against the first view we created, we retrieved every column in the view by using the asterisk wildcard after the <span class="literal">SELECT</span> keyword. <a href="ch15.xhtml#ch15list4">Listing 15-4</a> shows that, as with a query on a table, we can name specific columns when querying a view. Here, we specify four of the <span class="literal">county_pop_change_2010_2000</span> view’s seven columns. One is <span class="literal">pct_ch</span><span class="literal">ange_2010_2000</span> <span class="ent">➊</span>, which returns the result of the percent change calculation we’re looking for. As you can see, it’s much simpler to write the column name like this than the whole formula! We’re also filtering the results using a <span class="literal">WHERE</span> clause <span class="ent">➋</span>, similar to how we would filter any query instead of returning all rows.</p>
<p class="indent">After querying the four columns from the view, the results should look like this:</p>
<p class="programs">geo_name            st    pop_2010    pct_change_2010_2000<br/>----------------    --    --------    --------------------<br/>Churchill County    NV       24877                     3.7<br/>Clark County        NV     1951269                    41.8<br/>Douglas County      NV       46997                    13.9<br/>Elko County         NV       48818                     7.8<br/>Esmeralda County    NV         783                   -19.4</p>
<p class="indent">Now we can revisit this view as often as we like to pull data for presentations or to answer questions about the percent change in population for each county in Nevada (or any other state) from 2000 to 2010.</p>
<p class="indent">Looking at just these five rows, you can see that a couple of interesting stories emerge: the effect of the 2000s’ housing boom on Clark County, which includes the city of Las Vegas, as well as a sharp drop in population in Esmeralda County, which has one of the lowest population densities in the United States.</p>
<h4 class="h4" id="lev269"><em>Inserting, Updating, and Deleting Data Using a View</em></h4>
<p class="noindent">You can update or insert data in the underlying table that a view queries as long as the view meets certain conditions. One requirement is that the view must reference a single table. If the view’s query joins tables, as with the population change view we just built in the previous section, then you can’t perform inserts or updates directly. Also, the view’s query can’t contain <span class="literal">DISTINCT</span>, <span class="literal">GROUP BY</span>, or other clauses. (See a complete list of restrictions at <em><a href="https://www.postgresql.org/docs/current/static/sql-createview.html">https://www.postgresql.org/docs/current/static/sql-createview.html</a></em>.)</p>
<p class="indent">You already know how to directly insert and update data on a table, so why do it through a view? One reason is that with a view you can exercise more control over which data a user can update. Let’s work through an example to see how this works.</p>
<h5 class="h5" id="lev270"><span epub:type="pagebreak" id="page_272"/>Creating a View of Employees</h5>
<p class="noindent">In the <a href="ch06.xhtml#ch06">Chapter 6</a> lesson on joins, we created and filled <span class="literal">departments</span> and <span class="literal">employees</span> tables with four rows about people and where they work (if you skipped that section, you can revisit <a href="ch06.xhtml#ch06list1">Listing 6-1</a> on <a href="ch06.xhtml#page_75">page 75</a>). Running a quick <span class="literal">SELECT * FROM employees;</span> query shows the table’s contents, as you can see here:</p>
<p class="programs">emp_id    first_name    last_name    salary    dept_id<br/>------    ----------    ---------    ------    -------<br/>     1    Nancy         Jones         62500          1<br/>     2    Lee           Smith         59300          1<br/>     3    Soo           Nguyen        83000          2<br/>     4    Janet         King          95000          2</p>
<p class="indent">Let’s say we want to give users in the Tax Department (its <span class="literal">dept_id</span> is <span class="literal">1</span>) the ability to add, remove, or update their employees’ names without letting them change salary information or data of employees in another department. To do this, we can set up a view using <a href="ch15.xhtml#ch15list5">Listing 15-5</a>:</p>
<p class="programs">CREATE OR REPLACE VIEW employees_tax_dept AS<br/>     SELECT emp_id,<br/>            first_name,<br/>            last_name,<br/>            dept_id<br/>     FROM employees<br/>   <span class="ent">➊</span> WHERE dept_id = 1<br/>     ORDER BY emp_id<br/>   <span class="ent">➋</span> WITH LOCAL CHECK OPTION;</p>
<p class="listing" id="ch15list5"><em>Listing 15-5: Creating a view on the <span class="literal">employees</span> table</em></p>
<p class="indent">Similar to the views we’ve created so far, we’re selecting only the columns we want to show from the <span class="literal">employees</span> table and using <span class="literal">WHERE</span> to filter the results on <span class="literal">dept_id = 1</span> <span class="ent">➊</span> to list only Tax Department staff. To restrict inserts or updates to Tax Department employees only, we add the <span class="literal">WITH LOCAL CHECK OPTION</span> <span class="ent">➋</span>, which rejects any insert or update that does not meet the criteria of the <span class="literal">WHERE</span> clause. For example, the option won’t allow anyone to insert or update a row in the underlying table where the employee’s <span class="literal">dept_id</span> is 3.</p>
<p class="indent">Create the <span class="literal">employees_tax_dept</span> view by running the code in <a href="ch15.xhtml#ch15list5">Listing 15-5</a>. Then run <span class="literal">SELECT * FROM employees_tax_dept;</span>, which should provide these two rows:</p>
<p class="programs">emp_id    first_name    last_name    dept_id<br/>------    ----------    ---------    -------<br/>     1    Nancy         Jones              1<br/>     2    Lee           Smith              1</p>
<p class="indent">The result shows the employees who work in the Tax Department; they’re two of the four rows in the entire <span class="literal">employees</span> table.</p>
<p class="indent">Now, let’s look at how inserts and updates work via this view.</p>
<h5 class="h5" id="lev271"><span epub:type="pagebreak" id="page_273"/>Inserting Rows Using the employees_tax_dept View</h5>
<p class="noindent">We can also use a view to insert or update data, but instead of using the table name in the <span class="literal">INSERT</span> or <span class="literal">UPDATE</span> statement, we substitute the view name. After we add or change data using a view, the change is applied to the underlying table, which in this case is <span class="literal">employees</span>. The view then reflects the change via the query it runs.</p>
<p class="indent"><a href="ch15.xhtml#ch15list6">Listing 15-6</a> shows two examples that attempt to add new employee records via the <span class="literal">employees_tax_dept</span> view. The first succeeds, but the second fails.</p>
<p class="programs"><span class="ent">➊</span> INSERT INTO employees_tax_dept (first_name, last_name, dept_id)<br/>  VALUES ('Suzanne', 'Legere', 1);<br/><br/><span class="ent">➋</span> INSERT INTO employees_tax_dept (first_name, last_name, dept_id)<br/>  VALUES ('Jamil', 'White', 2);<br/><br/><span class="ent">➌</span> SELECT * FROM employees_tax_dept;<br/><br/><span class="ent">➍</span> SELECT * FROM employees;</p>
<p class="listing" id="ch15list6"><em>Listing 15-6: Successful and rejected inserts via the <span class="literal">employees_tax_dept</span> view</em></p>
<p class="indent">In the first <span class="literal">INSERT</span> <span class="ent">➊</span>, which follows the insert format you learned in <a href="ch01.xhtml#ch01">Chapter 1</a>, we supply the first and last names of Suzanne Legere plus her <span class="literal">dept_id</span>. Because the <span class="literal">dept_id</span> is <span class="literal">1</span>, the value satisfies the <span class="literal">LOCAL CHECK</span> in the view, and the insert succeeds when it executes.</p>
<p class="indent">But when we run the second <span class="literal">INSERT</span> <span class="ent">➋</span> to add an employee named Jamil White using a <span class="literal">dept_id</span> of <span class="literal">2</span>, the operation fails with the error message <span class="literal">new row violates check option for view "employees_tax_dept"</span>. The reason is that when we created the view in <a href="ch15.xhtml#ch15list5">Listing 15-5</a>, we used the <span class="literal">WHERE</span> clause to show only rows with <span class="literal">dept_id = 1</span>. The <span class="literal">dept_id</span> of <span class="literal">2</span> does not pass the <span class="literal">LOCAL CHECK</span> in the view, and it’s prevented from being inserted.</p>
<p class="indent">Run the <span class="literal">SELECT</span> statement <span class="ent">➌</span> on the view to check that Suzanne Legere was successfully added:</p>
<p class="programs">emp_id    first_name    last_name    dept_id<br/>------    ----------    ---------    -------<br/>     1    Nancy         Jones              1<br/>     2    Lee           Smith              1<br/>     5    Suzanne       Legere             1</p>
<p class="indent">We can also query the <span class="literal">employees</span> table <span class="ent">➍</span> to see that, in fact, Suzanne Legere was added to the full table. The view queries the <span class="literal">employees</span> table each time we access it.</p>
<p class="programs">emp_id    first_name    last_name    salary    dept_id<br/>------    ----------    ---------    ------    -------<br/>     1    Nancy         Jones         62500          1<br/>     2    Lee           Smith         59300          1<br/><span epub:type="pagebreak" id="page_274"/>     3    Soo           Nguyen        83000          2<br/>     4    Janet         King          95000          2<br/>     5    Suzanne       Legere                       1</p>
<p class="indent">As you can see from the addition of “Suzanne Legere,” the data we add using a view is also added to the underlying table. However, because the view doesn’t include the <span class="literal">salary</span> column, its value in her row is <span class="literal">NULL</span>. If you attempt to insert a salary value using this view, you would receive the error message <span class="literal">column "salary" of relation "employees_tax_dept" does not exist</span>. The reason is that even though the <span class="literal">salary</span> column exists in the underlying <span class="literal">employees</span> table, it’s not referenced in the view. Again, this is one way to limit access to sensitive data. Check the links I provided in the note on <a href="ch15.xhtml#page_268">page 268</a> to learn more about granting permissions to users if you plan to take on database administrator responsibilities.</p>
<h5 class="h5" id="lev272">Updating Rows Using the employees_tax_dept View</h5>
<p class="noindent">The same restrictions on accessing data in an underlying table apply when we make updates on data in the <span class="literal">employees_tax_dept</span> view. <a href="ch15.xhtml#ch15list7">Listing 15-7</a> shows a standard query to update the spelling of Suzanne’s last name using <span class="literal">UPDATE</span> (as a person with more than one uppercase letter in his last name, I can confirm misspelling names isn’t unusual).</p>
<p class="programs">UPDATE employees_tax_dept<br/>SET last_name = 'Le Gere'<br/>WHERE emp_id = 5;<br/><br/>SELECT * FROM employees_tax_dept;</p>
<p class="listing" id="ch15list7"><em>Listing 15-7: Updating a row via the <span class="literal">employees_tax_dept</span> view</em></p>
<p class="indent">Run the code, and the result from the <span class="literal">SELECT</span> query should show the updated last name, which occurs in the underlying <span class="literal">employees</span> table:</p>
<p class="programs">emp_id    first_name    last_name    dept_id<br/>------    ----------    ---------    -------<br/>     1    Nancy         Jones              1<br/>     2    Lee           Smith              1<br/>     5    Suzanne       Le Gere            1</p>
<p class="indent">Suzanne’s last name is now correctly spelled as “Le Gere,” not “Legere.”</p>
<p class="indent">However, if we try to update the name of an employee who is not in the Tax Department, the query fails just as it did when we tried to insert Jamil White in <a href="ch15.xhtml#ch15list6">Listing 15-6</a>. In addition, trying to use this view to update the salary of an employee—even one in the Tax Department—will fail with the same error I noted in the previous section. If the view doesn’t reference a <span epub:type="pagebreak" id="page_275"/>column in the underlying table, you cannot access that column through the view. Again, the fact that updates on views are restricted in this way offers ways to ensure privacy and security for certain pieces of data.</p>
<h5 class="h5" id="lev273">Deleting Rows Using the employees_tax_dept View</h5>
<p class="noindent">Now, let’s explore how to delete rows using a view. The restrictions on which data you can affect apply here as well. For example, if Suzanne Le Gere in the Tax Department gets a better offer from another firm and decides to join the other company, you could remove her from the employees table through the <span class="literal">employees_tax_dept</span> view. <a href="ch15.xhtml#ch15list8">Listing 15-8</a> shows the query in the standard <span class="literal">DELETE</span> syntax:</p>
<p class="programs">DELETE FROM employees_tax_dept<br/>WHERE emp_id = 5;</p>
<p class="listing" id="ch15list8"><em>Listing 15-8: Deleting a row via the <span class="literal">employees_tax_dept</span> view</em></p>
<p class="indent">Run the query, and PostgreSQL should respond with <span class="literal">DELETE 1</span>. However, when you try to delete a row for an employee in a department other than the Tax Department, PostgreSQL won’t allow it and will report <span class="literal">DELETE 0</span>.</p>
<p class="indent">In summary, views not only give you control over access to data, but also shortcuts for working with data. Next, let’s explore how to use functions to save more time.</p>
<h3 class="h3" id="lev274">Programming Your Own Functions</h3>
<p class="noindent">You’ve used plenty of functions throughout the book, whether to capitalize letters with <span class="literal">upper()</span> or add numbers with <span class="literal">sum()</span>. Behind these functions is a significant amount of (sometimes complex) programming that takes an input, transforms it or initiates an action, and returns a response. You saw that extent of code in <a href="ch05.xhtml#ch05list14">Listing 5-14</a> on <a href="ch05.xhtml#page_69">page 69</a> when you created a <span class="literal">median()</span> function, which uses 30 lines of code to find the middle value in a group of numbers. PostgreSQL’s built-in functions and other functions database programmers develop to automate processes can use even more lines of code, including links to external code written in another language, such as C.</p>
<p class="indent">We won’t write complicated code here, but we’ll work through some examples of building functions that you can use as a launching pad for your own ideas. Even simple, user-created functions can help you avoid repeating code when you’re analyzing data.</p>
<p class="indent">The code in this section is specific to PostgreSQL and is not part of the ANSI SQL standard. In some databases, notably Microsoft SQL Server and MySQL, implementing reusable code happens in a <em>stored procedure</em>. If you’re using another database management system, check its documentation for specifics.</p>
<h4 class="h4" id="lev275"><span epub:type="pagebreak" id="page_276"/><em>Creating the percent_change() Function</em></h4>
<p class="noindent">To learn the syntax for creating a function, let’s write a function to simplify calculating the percent change of two values, which is a staple of data analysis. In <a href="ch05.xhtml#ch05">Chapter 5</a>, you learned that the percent change formula can be expressed this way:</p>
<p class="programs">percent change = (<em>New Number</em> – <em>Old Number</em>) / <em>Old Number</em></p>
<p class="indent">Rather than writing that formula each time we need it, we can create a function called <span class="literal">percent_change()</span> that takes the new and old numbers as inputs and returns the result rounded to a user-specified number of decimal places. Let’s walk through the code in <a href="ch15.xhtml#ch15list9">Listing 15-9</a> to see how to declare a simple SQL function:</p>
<p class="programs"><span class="ent">➊</span> CREATE OR REPLACE FUNCTION<br/><span class="ent">➋</span> percent_change(new_value numeric,<br/>                 old_value numeric,<br/>                 decimal_places integer <span class="ent">➌</span>DEFAULT 1)<br/><span class="ent">➍</span> RETURNS numeric AS<br/><span class="ent">➎</span> 'SELECT round(<br/>          ((new_value - old_value) / old_value) * 100, decimal_places<br/>  );'<br/><span class="ent">➏</span> LANGUAGE SQL<br/><span class="ent">➐</span> IMMUTABLE<br/><span class="ent">➑</span> RETURNS NULL ON NULL INPUT;</p>
<p class="listing" id="ch15list9"><em>Listing 15-9: Creating a <span class="literal">percent_change()</span> function</em></p>
<p class="indent">A lot is happening in this code, but it’s not as complicated as it looks. We start with the command <span class="literal">CREATE OR REPLACE FUNCTION</span> <span class="ent">➊</span>, followed by the name of the function <span class="ent">➋</span> and, in parentheses, a list of <em>arguments</em> that are the function’s inputs. Each argument has a name and data type. For example, we specify that <span class="literal">new_value</span> and <span class="literal">old_value</span> are <span class="literal">numeric</span>, whereas <span class="literal">decimal_places</span> (which specifies the number of places to round results) is <span class="literal">integer</span>. For <span class="literal">decimal_places</span>, we specify <span class="literal">1</span> as the <span class="literal">DEFAULT</span> <span class="ent">➌</span> value to indicate that we want the results to display only one decimal place. Because we set a default value, the argument will be optional when we call the function later.</p>
<p class="indent">We then use the keywords <span class="literal">RETURNS numeric AS</span> <span class="ent">➍</span> to tell the function to return its calculation as type <span class="literal">numeric</span>. If this were a function to concatenate strings, we might return <span class="literal">text</span>.</p>
<p class="indent">Next, we write the meat of the function that performs the calculation. Inside single quotes, we place a <span class="literal">SELECT</span> query <span class="ent">➎</span> that includes the percent change calculation nested inside a <span class="literal">round()</span> function. In the formula, we use the function’s argument names instead of numbers.</p>
<p class="indent">We then supply a series of keywords that define the function’s attributes and behavior. The <span class="literal">LANGUAGE</span> <span class="ent">➏</span> keyword specifies that we’ve written this function using plain SQL, which is one of several languages PostgreSQL supports in functions. Another common option is a PostgreSQL-specific <em>procedural language</em> called PL/pgSQL that, in addition to providing the <span epub:type="pagebreak" id="page_277"/>means to create functions, adds features not found in standard SQL, such as logical control structures (<span class="literal">IF ... THEN ... ELSE</span>). PL/pgSQL is the default procedural language installed with PostgreSQL, but you can install others, such as PL/Perl and PL/Python, to use the Perl and Python programming languages in your database. Later in this chapter, I’ll show examples of PL/pgSQL and Python.</p>
<p class="indent">Next, the <span class="literal">IMMUTABLE</span> keyword <span class="ent">➐</span> indicates that the function won’t be making any changes to the database, which can improve performance. The line <span class="literal">RETURNS NULL ON NULL INPUT</span> <span class="ent">➑</span> guarantees that the function will supply a <span class="literal">NULL</span> response if any input that is not supplied by default is a <span class="literal">NULL</span>.</p>
<p class="indent">Run the code using pgAdmin to create the <span class="literal">percent_change()</span> function. The server should respond with the message <span class="literal">CREATE FUNCTION</span>.</p>
<h4 class="h4" id="lev276"><em>Using the percent_change() Function</em></h4>
<p class="noindent">To test the new <span class="literal">percent_change()</span> function, run it by itself using <span class="literal">SELECT</span>, as shown in <a href="ch15.xhtml#ch15list10">Listing 15-10</a>:</p>
<p class="programs">SELECT percent_change(110, 108, 2);</p>
<p class="listing" id="ch15list10"><em>Listing 15-10: Testing the <span class="literal">percent_change()</span> function</em></p>
<p class="indent">This example uses a value of <span class="literal">110</span> for the new number, <span class="literal">108</span> for the old number, and <span class="literal">2</span> as the desired number of decimal places to round the result.</p>
<p class="indent">Run the code; the result should look like this:</p>
<p class="programs">percent_change<br/>--------------<br/>          1.85</p>
<p class="indent">The result indicates that there is a 1.85 percent increase between 108 and 110. You can experiment with other numbers to see how the results change. Also, try changing the <span class="literal">decimal_places</span> argument to values including <span class="literal">0</span>, or omit it, to see how that affects the output. You should see results that have more or fewer numbers after the decimal point, based on your input.</p>
<p class="indent">Of course, we created this function to avoid having to write the full percent change formula in queries. Now let’s use it to calculate the percent change using a version of the Decennial Census population change query we wrote in <a href="ch06.xhtml#ch06">Chapter 6</a>, as shown in <a href="ch15.xhtml#ch15list11">Listing 15-11</a>:</p>
<p class="programs">SELECT c2010.geo_name,<br/>       c2010.state_us_abbreviation AS st,<br/>       c2010.p0010001 AS pop_2010,<br/>     <span class="ent">➊</span> percent_change(c2010.p0010001, c2000.p0010001) AS pct_chg_func,<br/>     <span class="ent">➋</span> round( (CAST(c2010.p0010001 AS numeric(8,1)) - c2000.p0010001)<br/>           / c2000.p0010001 * 100, 1 ) AS pct_chg_formula<br/>FROM us_counties_2010 c2010 INNER JOIN us_counties_2000 c2000<br/>ON c2010.state_fips = c2000.state_fips<br/>   AND c2010.county_fips = c2000.county_fips<br/><span epub:type="pagebreak" id="page_278"/>ORDER BY pct_chg_func DESC<br/>LIMIT 5;</p>
<p class="listing" id="ch15list11"><em>Listing 15-11: Testing <span class="literal">percent_change()</span> on census data</em></p>
<p class="indent"><a href="ch15.xhtml#ch15list11">Listing 15-11</a> uses the original query in <a href="ch06.xhtml#ch06list13">Listing 6-13</a> and adds the <span class="literal">p</span><span class="literal">ercent</span><span class="literal">_change()</span> function <span class="ent">➊</span> as a column before the formula <span class="ent">➋</span> so we can compare results. As inputs, we use the 2010 total population column (<span class="literal">c2010.p0010001</span>) as the new number and the 2000 total population as the old (<span class="literal">c2000.p0010001</span>).</p>
<p class="indent">When you run the query, the results should display the five counties with the greatest percent change in population, and the results from the function should match the results from the formula entered directly into the query <span class="ent">➋</span>.</p>
<div class="image"><img alt="image" src="../images/prog_page_278.jpg"/></div>
<p class="indent">Each result displays one decimal place, the function’s default value, because we didn’t provide the optional third argument when we called the function. Now that we know the function works as intended, we can use <span class="literal">percent_change()</span> any time we need to solve that calculation. Using a function is much faster than having to write a formula each time we need to use it!</p>
<h4 class="h4" id="lev277"><em>Updating Data with a Function</em></h4>
<p class="noindent">We can also use a function to simplify routine updates to data. In this section, we’ll write a function that assigns the correct number of personal days available to a teacher (in addition to vacation) based on their hire date. We’ll use the <span class="literal">teachers</span> table from the first lesson in <a href="ch01.xhtml#ch01">Chapter 1</a>, <a href="ch01.xhtml#lev13">“Creating a Table”</a> on <a href="ch01.xhtml#page_5">page 5</a>. If you skipped that section, you can return to it to create the table and insert the data using the example code in <a href="ch01.xhtml#ch01list2">Listing 1-2</a> on <a href="ch01.xhtml#page_6">page 6</a> and <a href="ch01.xhtml#ch01list3">Listing 1-3</a> on <a href="ch01.xhtml#page_8">page 8</a>.</p>
<p class="indent">Let’s start by adding a column to <span class="literal">teachers</span> to hold the personal days using the code in <a href="ch15.xhtml#ch15list12">Listing 15-12</a>:</p>
<p class="programs">ALTER TABLE teachers ADD COLUMN personal_days integer;<br/>SELECT first_name,<br/>       last_name,<br/>       hire_date,<br/>       personal_days<br/>FROM teachers;</p>
<p class="listing" id="ch15list12"><em>Listing 15-12: Adding a column to the <span class="literal">teachers</span> table and seeing the data</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_279"/><a href="ch15.xhtml#ch15list12">Listing 15-12</a> updates the <span class="literal">teachers</span> table using <span class="literal">ALTER</span> and adds the <span class="literal">personal_days</span> column using the keywords <span class="literal">ADD COLUMN</span>. Run the <span class="literal">SELECT</span> statement to view the data. When both queries finish, you should see the following six rows:</p>
<p class="programs">first_name    last_name    hire_date     personal_days<br/>----------    ---------    ----------    -------------<br/>Janet         Smith        2011-10-30<br/>Lee           Reynolds     1993-05-22<br/>Samuel        Cole         2005-08-01<br/>Samantha      Bush         2011-10-30<br/>Betty         Diaz         2005-08-30<br/>Kathleen      Roush        2010-10-22      </p>
<p class="indent">The <span class="literal">personal_days</span> column holds <span class="literal">NULL</span> values because we haven’t provided any values yet.</p>
<p class="indent">Now, let’s create a function called <span class="literal">update_personal_days()</span> that updates the <span class="literal">personal_days</span> column with the correct personal days based on the teacher’s hire date. We’ll use the following rules to update the data in the <span class="literal">personal_days</span> column:</p>
<ul>
<li class="noindent">Less than five years since hire: 3 personal days</li>
<li class="noindent">Between five and 10 years since hire: 4 personal days</li>
<li class="noindent">More than 10 years since hire: 5 personal days</li>
</ul>
<p class="indent">The code in <a href="ch15.xhtml#ch15list13">Listing 15-13</a> is similar to the code we used to create the <span class="literal">percent_change()</span> function, but this time we’ll use the PL/pgSQL language instead of plain SQL. Let’s walk through some differences.</p>
<p class="programs">  CREATE OR REPLACE FUNCTION update_personal_days()<br/><span class="ent">➊</span> RETURNS void AS <span class="ent">➋</span>$$<br/><span class="ent">➌</span> BEGIN<br/>      UPDATE teachers<br/>      SET personal_days = <br/>        <span class="ent">➍</span> CASE WHEN (now() - hire_date) BETWEEN '5 years'::interval<br/>                                        AND '10 years'::interval THEN 4<br/>               WHEN (now() - hire_date) &gt; '10 years'::interval THEN 5<br/>               ELSE 3<br/>          END;<br/>   <span class="ent">➎</span> RAISE NOTICE 'personal_days updated!';<br/>  END;<br/><span class="ent">➏</span> $$ LANGUAGE plpgsql;</p>
<p class="listing" id="ch15list13"><em>Listing 15-13: Creating an <span class="literal">update_personal_days()</span> function</em></p>
<p class="indent">We begin with <span class="literal">CREATE OR REPLACE FUNCTION</span>, followed by the function’s name. This time, we provide no arguments because no user input is required. The function operates on predetermined columns with set rules for calculating intervals. Also, we use <span class="literal">RETURNS void</span> <span class="ent">➊</span> to note that the function returns no data; it simply updates the <span class="literal">personal_days</span> column.</p>
<p class="indent"><span epub:type="pagebreak" id="page_280"/>Often, when writing PL/pgSQL-based functions, the PostgreSQL convention is to use the non-ANSI SQL standard dollar-quote (<span class="literal">$$</span>) <span class="ent">➋</span> to mark the start and end of the string that contains all the function’s commands. (As with the <span class="literal">percent_change()</span> function earlier, you could use single quote marks to enclose the string, but then any single quotes in the string would need to be doubled, and that looks messy.) So, everything between the pairs of <span class="literal">$$</span> is the code that does the work. You can also add some text between the dollar signs, like <span class="literal">$namestring$</span>, to create a unique pair of beginning and ending quotes. This is useful, for example, if you need to quote a query inside the function.</p>
<p class="indent">Right after the first <span class="literal">$$</span> we start a <span class="literal">BEGIN ... END;</span> <span class="ent">➌</span> block to denote the function; inside it we place an <span class="literal">UPDATE</span> statement that uses a <span class="literal">CASE</span> statement <span class="ent">➍</span> to determine the number of days each teacher gets. We subtract the <span class="literal">hire_date</span> from the current date, which is retrieved from the server by the <span class="literal">now()</span> function. Depending on which range <span class="literal">now() - hire_date</span> falls into, the <span class="literal">CASE</span> statement returns the correct number of days off corresponding to the range. We use <span class="literal">RAISE NOTICE</span> <span class="ent">➎</span> to display a message in pgAdmin that the function is done. At the end, we use the <span class="literal">LANGUAGE</span> <span class="ent">➏</span> keyword to specify that we’ve written this function using PL/pgSQL.</p>
<p class="indent">Run the code in <a href="ch15.xhtml#ch15list13">Listing 15-13</a> to create the <span class="literal">update_personal_days()</span> function. Then use the following line to run it in pgAdmin:</p>
<p class="programs">SELECT update_personal_days();</p>
<p class="indent">Now when you rerun the <span class="literal">SELECT</span> statement in <a href="ch15.xhtml#ch15list12">Listing 15-12</a>, you should see that each row of the <span class="literal">personal_days</span> column is filled with the appropriate values. Note that your results may vary depending on when you run this function, because the result of <span class="literal">now()</span> is constantly updated with the passage of time.</p>
<p class="programs">first_name    last_name    hire_date     personal_days<br/>----------    ---------    ----------    -------------<br/>Janet         Smith        2011-10-30                4<br/>Lee           Reynolds     1993-05-22                5<br/>Samuel        Cole         2005-08-01                5<br/>Samantha      Bush         2011-10-30                4<br/>Betty         Diaz         2005-08-30                5<br/>Kathleen      Roush        2010-10-22                4</p>
<p class="indent">You could use the <span class="literal">update_personal_days()</span> function to regularly update data manually after performing certain tasks, or you could use a task scheduler such as pgAgent (a separate open source tool) to run it automatically. You can learn about pgAgent and other tools in <a href="appendix.xhtml#lev330">“PostgreSQL Utilities, Tools, and Extensions”</a> on <a href="appendix.xhtml#page_334">page 334</a>.</p>
<h4 class="h4" id="lev278"><span epub:type="pagebreak" id="page_281"/><em>Using the Python Language in a Function</em></h4>
<p class="noindent">Previously, I mentioned that PL/pgSQL is the default procedural language within PostgreSQL, but the database also supports creating functions using open source languages, such as Perl and Python. This support allows you to take advantage of those languages’ features as well as related modules within functions you create. For example, with Python, you can use the <span class="literal">pandas</span> library for data analysis. The documentation at <em><a href="https://www.postgresql.org/docs/current/static/server-programming.html">https://www.postgresql.org/docs/current/static/server-programming.html</a></em> provides a comprehensive review of the available languages, but here I’ll show you a very simple function using Python.</p>
<p class="indent">To enable PL/Python, you must add the extension using the code in <a href="ch15.xhtml#ch15list14">Listing 15-14</a>. If you get an error, such as <span class="literal">could not access file</span> <span class="literal">"$libdir/plpython2"</span>, that means PL/Python wasn’t included when you installed PostgreSQL. Refer back to the troubleshooting links for each operating system in <a href="intro.xhtml#lev6">“Installing PostgreSQL”</a> on page xxviii.</p>
<p class="programs">CREATE EXTENSION plpythonu;</p>
<p class="listing" id="ch15list14"><em>Listing 15-14: Enabling the PL/Python procedural language</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The extension <span class="literal">plpythonu</span> currently installs Python version 2.</em>x. <em>If you want to use Python 3.</em>x, <em>install the extension <span class="literal">plpython3u</span> instead. However, available versions might vary based on PostgreSQL distribution.</em></p>
</div>
<p class="indent">After enabling the extension, create a function following the same syntax you just learned in <a href="ch15.xhtml#ch15list9">Listing 15-9</a> and <a href="ch15.xhtml#ch15list13">Listing 15-13</a>, but use Python for the body of the function. <a href="ch15.xhtml#ch15list15">Listing 15-15</a> shows how to use PL/Python to create a function called <span class="literal">trim_county()</span> that removes the word “County” from the end of a string. We’ll use this function to clean up names of counties in the census data.</p>
<p class="programs">  CREATE OR REPLACE FUNCTION trim_county(input_string text)<br/><span class="ent">➊</span> RETURNS text AS $$<br/>    <span class="ent">➋</span> import re<br/>    <span class="ent">➌</span> cleaned = re.sub(r' County', '', input_string)<br/>      return cleaned<br/><span class="ent">➍</span> $$ LANGUAGE plpythonu;</p>
<p class="listing" id="ch15list15"><em>Listing 15-15: Using PL/Python to create the <span class="literal">trim_county()</span> function</em></p>
<p class="indent">The structure should look familiar with some exceptions. Unlike the example in <a href="ch15.xhtml#ch15list13">Listing 15-13</a>, we don’t follow the <span class="literal">$$</span> <span class="ent">➊</span> with a <span class="literal">BEGIN ... END;</span> block. That is a PL/pgSQL–specific requirement that we don’t need in PL/Python. Instead, we get straight to the Python code by starting with a statement to import the Python <span epub:type="pagebreak" id="page_282"/>regular expressions module, <span class="literal">re</span> <span class="ent">➋</span>. Even if you don’t know much about Python, you can probably deduce that the next two lines of code <span class="ent">➌</span> set a variable called <span class="literal">cleaned</span> to the results of a Python regular expression function called <span class="literal">sub()</span>. That function looks for a space followed by the word <em>County</em> in the <span class="literal">input_string</span> passed into the function and substitutes an empty string, which is denoted by two apostrophes. Then the function returns the content of the variable <span class="literal">cleaned</span>. To end, we specify <span class="literal">LANGUAGE plpythonu</span> <span class="ent">➍</span> to note we’re writing the function with PL/Python.</p>
<p class="indent">Run the code to create the function, and then execute the <span class="literal">SELECT</span> statement in <a href="ch15.xhtml#ch15list16">Listing 15-16</a> to see it in action.</p>
<p class="programs">SELECT geo_name,<br/>       trim_county(geo_name)<br/>FROM us_counties_2010<br/>ORDER BY state_fips, county_fips<br/>LIMIT 5;</p>
<p class="listing" id="ch15list16"><em>Listing 15-16: Testing the <span class="literal">trim_county()</span> function</em></p>
<p class="indent">We use the <span class="literal">geo_name</span> column in the <span class="literal">us_counties_2010</span> table as input to <span class="literal">trim_county()</span>. That should return these results:</p>
<p class="programs">geo_name          trim_county<br/>--------------    -----------<br/>Autauga County    Autauga<br/>Baldwin County    Baldwin<br/>Barbour County    Barbour<br/>Bibb County       Bibb<br/>Blount County     Blount</p>
<p class="indent">As you can see, the <span class="literal">trim_county()</span> function evaluated each value in the <span class="literal">geo_name</span> column and removed a space and the word <em>County</em> when present. Although this is a trivial example, it shows how easy it is to use Python—or one of the other supported procedural languages—inside a function.</p>
<p class="indent">Next, you’ll learn how to use triggers to automate your database.</p>
<h3 class="h3" id="lev279">Automating Database Actions with Triggers</h3>
<p class="noindent">A database <em>trigger</em> executes a function whenever a specified event, such as an <span class="literal">INSERT</span>, <span class="literal">UPDATE</span>, or <span class="literal">DELETE</span>, occurs on a table or a view. You can set a trigger to fire before, after, or instead of the event, and you can also set it to fire once for each row affected by the event or just once per operation. For example, let’s say you delete 20 rows from a table. You could set the trigger to fire once for each of the 20 rows deleted or just one time.</p>
<p class="indent">We’ll work through two examples. The first example keeps a log of changes made to grades at a school. The second automatically classifies temperatures each time we collect a reading.</p>
<h4 class="h4" id="lev280"><em>Logging Grade Updates to a Table</em></h4>
<p class="noindent">Let’s say we want to automatically track changes made to a student <span class="literal">grades</span> table in our school’s database. Every time a row is updated, we want to <span epub:type="pagebreak" id="page_283"/>record the old and new grade plus the time the change occurred (search for “David Lightman and grades” and you’ll see why this might be worth tracking). To handle this task automatically, we’ll need three items:</p>
<ul>
<li class="noindent">A <span class="literal">grades_history</span> table to record the changes to grades in a <span class="literal">grades</span> table</li>
<li class="noindent">A trigger to run a function every time a change occurs in the <span class="literal">grades</span> table, which we’ll name <span class="literal">grades_update</span></li>
<li class="noindent">The function the trigger will execute; we’ll call this function <span class="literal">record_if_grade_changed()</span></li>
</ul>
<h5 class="h5" id="lev281">Creating Tables to Track Grades and Updates</h5>
<p class="noindent">Let’s start by making the tables we need. <a href="ch15.xhtml#ch15list17">Listing 15-17</a> includes the code to first create and fill <span class="literal">grades</span> and then create <span class="literal">grades_history</span>:</p>
<p class="programs"><span class="ent">➊</span> CREATE TABLE grades (<br/>      student_id bigint,<br/>      course_id bigint,<br/>      course varchar(30) NOT NULL,<br/>      grade varchar(5) NOT NULL,<br/>  PRIMARY KEY (student_id, course_id)<br/>  );<br/><br/><span class="ent">➋</span> INSERT INTO grades<br/>  VALUES<br/>      (1, 1, 'Biology 2', 'F'),<br/>      (1, 2, 'English 11B', 'D'),<br/>      (1, 3, 'World History 11B', 'C'),<br/>      (1, 4, 'Trig 2', 'B');<br/><br/><span class="ent">➌</span> CREATE TABLE grades_history (<br/>      student_id bigint NOT NULL,<br/>      course_id bigint NOT NULL,<br/>      change_time timestamp with time zone NOT NULL,<br/>      course varchar(30) NOT NULL,<br/>      old_grade varchar(5) NOT NULL,<br/>      new_grade varchar(5) NOT NULL,<br/>  PRIMARY KEY (student_id, course_id, change_time)<br/>  );</p>
<p class="listing" id="ch15list17"><em>Listing 15-17: Creating the <span class="literal">grades</span> and <span class="literal">grades_history</span> tables</em></p>
<p class="indent">These commands are straightforward. We use <span class="literal">CREATE</span> to make a <span class="literal">grades</span> table <span class="ent">➊</span> and add four rows using <span class="literal">INSERT</span> <span class="ent">➋</span>, where each row represents a student’s grade in a class. Then we use <span class="literal">CREATE TABLE</span> to make the <span class="literal">grades_history</span> table <span class="ent">➌</span> to hold the data we log each time an existing grade is altered. The <span class="literal">grades_history</span> table has columns for the new grade, old grade, and the time of the change. Run the code to create the tables and fill the <span class="literal">grades</span> table. We insert no data into <span class="literal">grades_history</span> here because the trigger process will handle that task.</p>
<h5 class="h5" id="lev282"><span epub:type="pagebreak" id="page_284"/>Creating the Function and Trigger</h5>
<p class="noindent">Next, let’s write the <span class="literal">record_if_grade_changed()</span> function the trigger will execute. We must write the function before naming it in the trigger. Let’s go through the code in <a href="ch15.xhtml#ch15list18">Listing 15-18</a>:</p>
<p class="programs">CREATE OR REPLACE FUNCTION record_if_grade_changed()<br/><span class="ent">➊</span> RETURNS trigger AS<br/>$$<br/>BEGIN<br/>  <span class="ent">➋</span> IF NEW.grade &lt;&gt; OLD.grade THEN<br/>    INSERT INTO grades_history (<br/>        student_id,<br/>        course_id,<br/>        change_time,<br/>        course,<br/>        old_grade,<br/>        new_grade)<br/>    VALUES<br/>        (OLD.student_id,<br/>         OLD.course_id,<br/>         now(),<br/>         OLD.course,<br/>       <span class="ent">➌</span> OLD.grade,<br/>       <span class="ent">➍</span> NEW.grade);<br/>    END IF;<br/>  <span class="ent">➎</span> RETURN NEW;<br/>END;<br/>$$ LANGUAGE plpgsql;</p>
<p class="listing" id="ch15list18"><em>Listing 15-18: Creating the <span class="literal">record_if_grade_changed()</span> function</em></p>
<p class="indent">The <span class="literal">record_if_grade_changed()</span> function follows the pattern of earlier examples in the chapter but with exceptions specific to working with triggers. First, we specify <span class="literal">RETURNS trigger</span> <span class="ent">➊</span> instead of a data type or <span class="literal">void</span>. Because <span class="literal">record_if_grade_changed()</span> is a PL/pgSQL function, we place the procedure inside the <span class="literal">BEGIN ... END;</span> block. We start the procedure using an <span class="literal">IF ... THEN</span> statement <span class="ent">➋</span>, which is one of the control structures PL/pgSQL provides. We use it here to run the <span class="literal">INSERT</span> statement only if the updated grade is different from the old grade, which we check using the <span class="literal">&lt;&gt;</span> operator.</p>
<p class="indent">When a change occurs to the <span class="literal">grades</span> table, the trigger (which we’ll create next) will execute. For each row that is changed, the trigger will pass two collections of data into <span class="literal">record_if_grade_changed()</span>. The first is the row values <em>before</em> they were changed, noted with the prefix <span class="literal">OLD</span>. The second is the row values <em>after</em> they were changed, noted with the prefix <span class="literal">NEW</span>. The function can access the original row values and the updated row values, which it will use for a comparison. If the <span class="literal">IF ... THEN</span> statement evaluates as <span class="literal">true</span>, which means that the old and new <span class="literal">grade</span> values are different, we use <span class="literal">INSERT</span> to add a row to <span class="literal">grades_history</span> that contains both <span class="literal">OLD.grade</span> <span class="ent">➌</span> and <span class="literal">NEW.grade</span> <span class="ent">➍</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_285"/>A trigger must have a <span class="literal">RETURN</span> statement <span class="ent">➎</span>, although the PostgreSQL documentation at <em><a href="https://www.postgresql.org/docs/current/static/plpgsql-trigger.html">https://www.postgresql.org/docs/current/static/plpgsql-trigger.html</a></em> details the scenarios in which a trigger return value actually matters (sometimes it is ignored). The documentation also explains that you can use statements to return a <span class="literal">NULL</span> or raise an exception in case of error.</p>
<p class="indent">Run the code in <a href="ch15.xhtml#ch15list18">Listing 15-18</a> to create the function. Next, add the <span class="literal">grades_update</span> trigger to the <span class="literal">grades</span> table using <a href="ch15.xhtml#ch15list19">Listing 15-19</a>:</p>
<p class="programs"><span class="ent">➊</span> CREATE TRIGGER grades_update<br/><span class="ent">➋</span>  AFTER UPDATE<br/>    ON grades<br/><span class="ent">➌</span>  FOR EACH ROW<br/><span class="ent">➍</span>  EXECUTE PROCEDURE record_if_grade_changed();</p>
<p class="listing" id="ch15list19"><em>Listing 15-19: Creating the <span class="literal">grades_update</span> trigger</em></p>
<p class="indent">In PostgreSQL, the syntax for creating a trigger follows the ANSI SQL standard (although the contents of the trigger function do not). The code begins with a <span class="literal">CREATE TRIGGER</span> <span class="ent">➊</span> statement, followed by clauses that control when the trigger runs and how it behaves. We use <span class="literal">AFTER UPDATE</span> <span class="ent">➋</span> to specify that we want the trigger to fire after the update occurs on the <span class="literal">grades</span> row. We could also use the keywords <span class="literal">BEFORE</span> or <span class="literal">INSTEAD OF</span> depending on the situation.</p>
<p class="indent">We write <span class="literal">FOR EACH ROW</span> <span class="ent">➌</span> to tell the trigger to execute the procedure once for each row updated in the table. For example, if someone ran an update that affected three rows, the procedure would run three times. The alternate (and default) is <span class="literal">FOR EACH STATEMENT</span>, which runs the procedure once. If we didn’t care about capturing changes to each row and simply wanted to record that grades were changed at a certain time, we could use that option. Finally, we use <span class="literal">EXECUTE PROCEDURE</span> <span class="ent">➍</span> to name <span class="literal">record_if_grade_changed()</span> as the function the trigger should run.</p>
<p class="indent">Create the trigger by running the code in <a href="ch15.xhtml#ch15list19">Listing 15-19</a> in pgAdmin. The database should respond with the message <span class="literal">CREATE TRIGGER</span>.</p>
<h5 class="h5" id="lev283">Testing the Trigger</h5>
<p class="noindent">Now that we’ve created the trigger and the function it should run, let’s make sure they work. First, when you run <span class="literal">SELECT * FROM grades_history;</span>, you’ll see that the table is empty because we haven’t made any changes to the <span class="literal">grades</span> table yet and there’s nothing to track. Next, when you run <span class="literal">SELECT * FROM grades;</span> you should see the grade data, as shown here:</p>
<p class="programs">student_id    course_id    course               grade<br/>----------    ---------    -----------------    -----<br/>         1            1    Biology 2            F<br/>         1            2    English 11B          D<br/>         1            3    World History 11B    C<br/>         1            4    Trig 2               B</p>
<p class="indent"><span epub:type="pagebreak" id="page_286"/>That Biology 2 grade doesn’t look very good. Let’s update it using the code in <a href="ch15.xhtml#ch15list20">Listing 15-20</a>:</p>
<p class="programs">UPDATE grades<br/>SET grade = 'C'<br/>WHERE student_id = 1 AND course_id = 1;</p>
<p class="listing" id="ch15list20"><em>Listing 15-20: Testing the <span class="literal">grades_update</span> trigger</em></p>
<p class="indent">When you run the <span class="literal">UPDATE</span>, pgAdmin doesn’t display anything to let you know that the trigger executed in the background. It just reports <span class="literal">UPDATE 1</span>, meaning the row with grade F was updated. But our trigger did run, which we can confirm by examining columns in <span class="literal">grades_history</span> using this <span class="literal">SELECT</span> query:</p>
<p class="programs">SELECT student_id,<br/>       change_time,<br/>       course,<br/>       old_grade,<br/>       new_grade<br/>FROM grades_history;</p>
<p class="indent">When you run this query, you should see that the <span class="literal">grades_history</span> table, which contains all changes to grades, now has one row:</p>
<div class="image"><img alt="image" src="../images/prog_page_286.jpg"/></div>
<p class="indent">This row displays the old Biology 2 grade of <span class="literal">F</span>, the new value <span class="literal">C</span>, and <span class="literal">change_time</span>, showing the time of the change made (your result should reflect your date and time). Note that the addition of this row to <span class="literal">grades_history</span> happened in the background without the knowledge of the person making the update. But the <span class="literal">UPDATE</span> event on the table caused the trigger to fire, which executed the <span class="literal">record_if_grade_changed()</span> function.</p>
<p class="indent">If you’ve used a content management system, such as WordPress or Drupal, this sort of revision tracking might be familiar. It provides a helpful record of changes made to content for reference and auditing purposes, and, unfortunately, can lead to occasional finger-pointing. Regardless, the ability to trigger actions on a database automatically gives you more control over your data.</p>
<h4 class="h4" id="lev284"><em>Automatically Classifying Temperatures</em></h4>
<p class="noindent">In <a href="ch12.xhtml#ch12">Chapter 12</a>, we used the SQL <span class="literal">CASE</span> statement to reclassify temperature readings into descriptive categories. The <span class="literal">CASE</span> statement (with a slightly different syntax) is also part of the PL/pgSQL procedural language, and we can use its capability to assign values to variables to automatically store those category names in a table each time we add a temperature reading. If we’re <span epub:type="pagebreak" id="page_287"/>routinely collecting temperature readings, using this technique to automate the classification spares us from having to handle the task manually.</p>
<p class="indent">We’ll follow the same steps we used for logging the grade changes: we first create a function to classify the temperatures, and then create a trigger to run the function each time the table is updated. Use <a href="ch15.xhtml#ch15list21">Listing 15-21</a> to create a <span class="literal">temperature_test</span> table for the exercise:</p>
<p class="programs">CREATE TABLE temperature_test (<br/>    station_name varchar(50),<br/>    observation_date date,<br/>    max_temp integer,<br/>    min_temp integer,<br/>    max_temp_group varchar(40),<br/>PRIMARY KEY (station_name, observation_date)<br/>);</p>
<p class="listing" id="ch15list21"><em>Listing 15-21: Creating a <span class="literal">temperature_test</span> table</em></p>
<p class="indent">In <a href="ch15.xhtml#ch15list21">Listing 15-21</a>, the <span class="literal">temperature_test</span> table contains columns to hold the name of the station and date of the temperature observation. Let’s imagine that we have some process to insert a row once a day that provides the maximum and minimum temperature for that location, and we need to fill the <span class="literal">max_temp_group</span> column with a descriptive classification of the day’s high reading to provide text to a weather forecast we’re distributing.</p>
<p class="indent">To do this, we first make a function called <span class="literal">classify_max_temp()</span>, as shown in <a href="ch15.xhtml#ch15list22">Listing 15-22</a>:</p>
<p class="programs">CREATE OR REPLACE FUNCTION classify_max_temp()<br/>    RETURNS trigger AS<br/>$$<br/>BEGIN<br/>  <span class="ent">➊</span> CASE <br/>       WHEN NEW.max_temp &gt;= 90 THEN<br/>           NEW.max_temp_group := 'Hot';<span class="ent">➋</span><br/>       WHEN NEW.max_temp BETWEEN 70 AND 89 THEN<br/>           NEW.max_temp_group := 'Warm';<br/>       WHEN NEW.max_temp BETWEEN 50 AND 69 THEN<br/>           NEW.max_temp_group := 'Pleasant';<br/>       WHEN NEW.max_temp BETWEEN 33 AND 49 THEN<br/>           NEW.max_temp_group :=  'Cold';<br/>       WHEN NEW.max_temp BETWEEN 20 AND 32 THEN<br/>           NEW.max_temp_group :=  'Freezing';<br/>       ELSE NEW.max_temp_group :=  'Inhumane';<br/>    END CASE;<br/>    RETURN NEW;<br/>END;<br/>$$ LANGUAGE plpgsql;</p>
<p class="listing" id="ch15list22"><em>Listing 15-22: Creating the <span class="literal">classify_max_temp()</span> function</em></p>
<p class="indent">By now, these functions should look familiar. What is new here is the PL/pgSQL version of the <span class="literal">CASE</span> syntax <span class="ent">➊</span>, which differs slightly from the <span epub:type="pagebreak" id="page_288"/>SQL syntax in that the PL/pgSQL syntax includes a semicolon after each <span class="literal">WHEN ... THEN</span> clause <span class="ent">➋</span>. Also new is the <em>assignment operator</em> (<span class="literal">:=</span>), which we use to assign the descriptive name to the <span class="literal">NEW.max_temp_group</span> column based on the outcome of the <span class="literal">CASE</span> function. For example, the statement <span class="literal">NEW.max_temp_group := 'Cold'</span> assigns the string <span class="literal">'Cold'</span> to <span class="literal">NEW.max_temp_group</span> when the temperature value is between 33 and 49 degrees Fahrenheit, and when the function returns the <span class="literal">NEW</span> row to be inserted in the table, it will include the string value <span class="literal">Cold</span>. Run the code to create the function.</p>
<p class="indent">Next, using the code in <a href="ch15.xhtml#ch15list23">Listing 15-23</a>, create a trigger to execute the function each time a row is added to <span class="literal">temperature_test</span>:</p>
<p class="programs">CREATE TRIGGER temperature_insert<br/>  <span class="ent">➊</span> BEFORE INSERT<br/>    ON temperature_test<br/>  <span class="ent">➋</span> FOR EACH ROW<br/>  <span class="ent">➌</span> EXECUTE PROCEDURE classify_max_temp();</p>
<p class="listing" id="ch15list23"><em>Listing 15-23: Creating the <span class="literal">temperature_insert</span> trigger</em></p>
<p class="indent">In this example, we classify <span class="literal">max_temp</span> and create a value for <span class="literal">max_temp_group</span> prior to inserting the row into the table. Doing so is more efficient than performing a separate update after the row is inserted. To specify that behavior, we set the <span class="literal">temperature_insert</span> trigger to fire <span class="literal">BEFORE INSERT</span> <span class="ent">➊</span>.</p>
<p class="indent">We also want the trigger to fire <span class="literal">FOR EACH ROW</span> inserted <span class="ent">➋</span> because we want each <span class="literal">max_temp</span> recorded in the table to get a descriptive classification. The final <span class="literal">EXECUTE PROCEDURE</span> statement names the <span class="literal">classify_max_temp()</span> function <span class="ent">➌</span> we just created. Run the <span class="literal">CREATE TRIGGER</span> statement in pgAdmin, and then test the setup using <a href="ch15.xhtml#ch15list24">Listing 15-24</a>:</p>
<p class="programs">INSERT INTO temperature_test (station_name, observation_date, max_temp, min_temp)<br/>VALUES<br/>    ('North Station', '1/19/2019', 10, -3),<br/>    ('North Station', '3/20/2019', 28, 19),<br/>    ('North Station', '5/2/2019', 65, 42),<br/>    ('North Station', '8/9/2019', 93, 74);<br/><br/>SELECT * FROM temperature_test;</p>
<p class="listing" id="ch15list24"><em>Listing 15-24: Inserting rows to test the <span class="literal">temperature_insert</span> trigger</em></p>
<p class="indent">Here we insert four rows into <span class="literal">temperature_test</span>, and we expect the <span class="literal">t</span><span class="literal">emperature</span><span class="literal">_insert</span> trigger to fire for each row—and it does! The <span class="literal">SELECT</span> statement in the listing should display these results:</p>
<div class="image"><img alt="image" src="../images/prog_page_288.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_289"/>Due to the trigger and function we created, each <span class="literal">max_temp</span> inserted automatically receives the appropriate classification in the <span class="literal">max_temp_group</span> column.</p>
<p class="indent">This temperature example and the earlier grade-change auditing example are rudimentary, but they give you a glimpse of how useful triggers and functions can be in simplifying data maintenance.</p>
<h3 class="h3" id="lev285">Wrapping Up</h3>
<p class="noindent">Although the techniques you learned in this chapter begin to merge with those of a database administrator, you can apply the concepts to reduce the amount of time you spend repeating certain tasks. I hope these approaches will help you free up more time to find interesting stories in your data.</p>
<p class="indent">This chapter concludes our discussion of analysis techniques and the SQL language. The next two chapters offer workflow tips to help you increase your command of PostgreSQL. They include how to connect to a database and run queries from your computer’s command line, and how to maintain your database.</p>
<div class="sidebar" id="ch15sb1">
<p class="sidebart"><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Review the concepts in the chapter with these exercises:</p>
<ol>
<li class="noindent"><p class="list">Create a view that displays the number of New York City taxi trips per hour. Use the taxi data in <a href="ch11.xhtml#ch11">Chapter 11</a> and the query in <a href="ch11.xhtml#ch11list8">Listing 11-8</a> on <a href="ch11.xhtml#page_182">page 182</a>.</p></li>
<li class="noindent"><p class="list">In <a href="ch10.xhtml#ch10">Chapter 10</a>, you learned how to calculate rates per thousand. Turn that formula into a <span class="literal">rates_per_thousand()</span> function that takes three arguments to calculate the result: <span class="literal">observed_number</span>, <span class="literal">base_number</span>, and <span class="literal">decimal_places</span>.</p></li>
<li class="noindent"><p class="list">In <a href="ch09.xhtml#ch09">Chapter 9</a>, you worked with the <span class="literal">meat_poultry_egg_inspect</span> table that listed food processing facilities. Write a trigger that automatically adds an inspection date each time you insert a new facility into the table. Use the <span class="literal">inspection_date</span> column added in <a href="ch09.xhtml#ch09list19">Listing 9-19</a> on <a href="ch09.xhtml#page_146">page 146</a>, and set the date to be six months from the current date. You should be able to describe the steps needed to implement a trigger and how the steps relate to each other.<span epub:type="pagebreak" id="page_290"/></p></li>
</ol>
</div>
</body>
</html>