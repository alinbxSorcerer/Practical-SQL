<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_211"/><strong><span class="big">13</span></strong><br/><strong>MINING TEXT TO FIND MEANINGFUL DATA</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">Although it might not be obvious at first glance, you can extract data and even quantify data from text in speeches, reports, press releases, and other documents. Even though most text exists as <em>unstructured</em> or <em>semi-structured data</em>, which is not organized in rows and columns, as in a table, you can use SQL to derive meaning from it.</p>
<p class="indent">One way to do this is to transform the text into <em>structured data</em>. You search for and extract elements such as dates or codes from the text, load them into a table, and analyze them. Another way to find meaning from textual data is to use advanced text analysis features, such as PostgreSQL’s full text search. Using these techniques, ordinary text can reveal facts or trends that might otherwise remain hidden.</p>
<p class="indent">In this chapter, you’ll learn how to use SQL to analyze and transform text. You’ll start with simple text wrangling using string formatting and pattern matching before moving on to more advanced analysis functions. We’ll <span epub:type="pagebreak" id="page_212"/>use two data sets as examples: a small collection of crime reports from a sheriff’s department near Washington, D.C., and a set of State of the Union addresses delivered by former U.S. presidents.</p>
<h3 class="h3" id="lev219">Formatting Text Using String Functions</h3>
<p class="noindent">Whether you’re looking for data in text or simply want to change how it looks in a report, you first need to transform it into a format you can use. PostgreSQL has more than 50 built-in string functions that handle routine but necessary tasks, such as capitalizing letters, combining strings, and removing unwanted spaces. Some are part of the ANSI SQL standard, and others are specific to PostgreSQL. You’ll find a complete list of string functions at <em><a href="https://www.postgresql.org/docs/current/static/functions-string.html">https://www.postgresql.org/docs/current/static/functions-string.html</a></em>, but in this section we’ll examine several that you’ll likely use most often.</p>
<p class="indent">You can use these functions inside a variety of queries. Let’s try one now using a simple query that places a function after <span class="literal">SELECT</span> and runs it in the pgAdmin Query Tool, like this: <span class="literal">SELECT upper('hello');</span>. Examples of each function plus code for all the listings in this chapter are available at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>.</p>
<h4 class="h4" id="lev220"><em>Case Formatting</em></h4>
<p class="noindent">The capitalization functions format the text’s case. The <span class="literal">upper(</span><span class="codeitalic">string</span><span class="literal">)</span> function capitalizes all alphabetical characters of a string passed to it. Nonalphabet characters, such as numbers, remain unchanged. For example, <span class="literal">upper('Neal7')</span> returns <span class="literal">NEAL7</span>. The <span class="literal">lower(</span><span class="codeitalic">string</span><span class="literal">)</span> function lowercases all alphabetical characters while keeping nonalphabet characters unchanged. For example, <span class="literal">lower('Randy')</span> returns <span class="literal">randy</span>.</p>
<p class="indent">The <span class="literal">initcap(</span><span class="codeitalic">string</span><span class="literal">)</span> function capitalizes the first letter of each word. For example, <span class="literal">initcap('at the end of the day')</span> returns <span class="literal">At The End Of The Day</span>. This function is handy for formatting titles of books or movies, but because it doesn’t recognize acronyms, it’s not always the perfect solution. For example, <span class="literal">initcap('Practical SQL')</span> would return <span class="literal">Practical Sql</span>, because it doesn’t recognize SQL as an acronym.</p>
<p class="indent">The <span class="literal">upper()</span> and <span class="literal">lower()</span> functions are ANSI SQL standard commands, but <span class="literal">initcap()</span> is PostgreSQL-specific. These three functions give you enough options to rework a column of text into the case you prefer. Note that capitalization does not work with all locales or languages.</p>
<h4 class="h4" id="lev221"><em>Character Information</em></h4>
<p class="noindent">Several functions return data about the string rather than transforming it. These functions are helpful on their own or combined with other functions. For example, the <span class="literal">char_length(</span><span class="codeitalic">string</span><span class="literal">)</span> function returns the number of characters in a string, including any spaces. For example, <span class="literal">char_length</span><span class="literal">(' Pat ')</span> returns a value of <span class="literal">5</span>, because the three letters in <span class="literal">Pat</span> and the spaces on either <span epub:type="pagebreak" id="page_213"/>end total five characters. You can also use the non-ANSI SQL function <span class="literal">length(</span><span class="codeitalic">string</span><span class="literal">)</span> to count strings, which has a variant that lets you count the length of binary strings.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The <span class="literal">length()</span> function can return a different value than <span class="literal">char_length()</span> when used with multibyte encodings, such as character sets covering the Chinese, Japanese, or Korean languages.</em></p>
</div>
<p class="indent">The <span class="literal">position(</span><span class="codeitalic">substring</span> <span class="literal">in</span> <span class="codeitalic">string</span><span class="literal">)</span> function returns the location of the substring characters in the string. For example, <span class="literal">position(', ' in 'Tan, Bella')</span> returns <span class="literal">4</span>, because the comma and space characters (<span class="literal">,</span> ) specified in the substring passed as the first parameter start at the fourth index position in the main string <span class="literal">Tan, Bella</span>.</p>
<p class="indent">Both <span class="literal">char_length()</span> and <span class="literal">position()</span> are in the ANSI SQL standard.</p>
<h4 class="h4" id="lev222"><em>Removing Characters</em></h4>
<p class="noindent">The <span class="literal">trim(</span><span class="codeitalic">characters</span> <span class="literal">from</span> <span class="codeitalic">string</span><span class="literal">)</span> function removes unwanted characters from strings. To declare one or more characters to remove, add them to the function followed by the keyword <span class="literal">from</span> and the main string you want to change. Options to remove <span class="literal">leading</span> characters (at the front of the string), <span class="literal">trailing</span> characters (at the end of the string), or <span class="literal">both</span> make this function super flexible.</p>
<p class="indent">For example, <span class="literal">trim('s' from 'socks')</span> removes all <span class="literal">s</span> characters and returns <span class="literal">ock</span>. To remove only the <span class="literal">s</span> at the end of the string, add the <span class="literal">trailing</span> keyword before the character to trim: <span class="literal">trim(trailing 's' from 'socks')</span> returns <span class="literal">sock</span>.</p>
<p class="indent">If you don’t specify any characters to remove, <span class="literal">trim()</span> removes any spaces in the string by default. For example, <span class="literal">trim(' Pat ')</span> returns <span class="literal">Pat</span> without the leading or trailing spaces. To confirm the length of the trimmed string, we can nest <span class="literal">trim()</span> inside <span class="literal">char_length()</span> like this:</p>
<p class="programs">SELECT char_length(trim(' Pat '));</p>
<p class="indent">This query should return <span class="literal">3</span>, the number of letters in <span class="literal">Pat</span>, which is the result of <span class="literal">trim(' Pat ')</span>.</p>
<p class="indent">The <span class="literal">ltrim(</span><span class="codeitalic">string,</span> <span class="codeitalic">characters</span><span class="literal">)</span> and <span class="literal">rtrim(</span><span class="codeitalic">string,</span> <span class="codeitalic">characters</span><span class="literal">)</span> functions are PostgreSQL-specific variations of the <span class="literal">trim()</span> function. They remove characters from the left or right ends of a string. For example, <span class="literal">rtrim('socks', 's')</span> returns <span class="literal">sock</span> by removing only the <span class="literal">s</span> on the right end of the string.</p>
<h4 class="h4" id="lev223"><em>Extracting and Replacing Characters</em></h4>
<p class="noindent">The <span class="literal">left(</span><span class="codeitalic">string,</span> <span class="codeitalic">number</span><span class="literal">)</span> and <span class="literal">right(</span><span class="codeitalic">string,</span> <span class="codeitalic">number</span><span class="literal">)</span> functions, both ANSI SQL standard, extract and return selected characters from a string. For example, to get just the <span class="literal">703</span> area code from the phone number <span class="literal">703-555-1212</span>, use <span class="literal">left('703-555-1212', 3)</span> to specify that you want the first three characters of the string starting from the left. Likewise, <span class="literal">right('703-555-1212', 8)</span> returns eight characters from the right: <span class="literal">555-1212</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_214"/>To substitute characters in a string, use the <span class="literal">replace(</span><span class="codeitalic">string,</span> <span class="codeitalic">from,</span> <span class="codeitalic">to</span><span class="literal">)</span> function. To change <span class="literal">bat</span> to <span class="literal">cat</span>, for example, you would use <span class="literal">replace('bat', 'b', 'c')</span> to specify that you want to replace the <span class="literal">b</span> in <span class="literal">bat</span> with a <span class="literal">c</span>.</p>
<p class="indent">Now that you know basic functions for manipulating strings, let’s look at how to match more complex patterns in text and turn those patterns into data we can analyze.</p>
<h3 class="h3" id="lev224">Matching Text Patterns with Regular Expressions</h3>
<p class="noindent"><em>Regular expressions</em> (or <em>regex</em>) are a type of notational language that describes text patterns. If you have a string with a noticeable pattern (say, four digits followed by a hyphen and then two more digits), you can write a regular expression that describes the pattern. You can then use the notation in a <span class="literal">WHERE</span> clause to filter rows by the pattern or use regular expression functions to extract and wrangle text that contains the same pattern.</p>
<p class="indent">Regular expressions can seem inscrutable to beginning programmers; they take practice to comprehend because they use single-character symbols that aren’t intuitive. Getting an expression to match a pattern can involve trial and error, and each programming language has subtle differences in the way it handles regular expressions. Still, learning regular expressions is a good investment because you gain superpower-like abilities to search text using many programming languages, text editors, and other applications.</p>
<p class="indent">In this section, I’ll provide enough regular expression basics to work through the exercises. To learn more, I recommend interactive online code testers, such as <em><a href="https://regexr.com/">https://regexr.com/</a></em> or <em><a href="http://www.regexpal.com/">http://www.regexpal.com/</a></em>, which have notation references.</p>
<h4 class="h4" id="lev225"><em>Regular Expression Notation</em></h4>
<p class="noindent">Matching letters and numbers using regular expression notation is straightforward because letters and numbers (and certain symbols) are literals that indicate the same characters. For example, <span class="literal">Al</span> matches the first two characters in <span class="literal">Alicia</span>.</p>
<p class="indent">For more complex patterns, you’ll use combinations of the regular expression elements in <a href="ch13.xhtml#ch13tab1">Table 13-1</a>.</p>
<p class="tabcap" id="ch13tab1"><strong>Table 13-1:</strong> Regular Expression Notation Basics</p>
<table class="topbot-d">
<thead>
<tr>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Expression</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">.</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">A dot is a wildcard that finds any character except a newline.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">[FGz]</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Any character in the square brackets. Here, F, G, or z.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">[a-z]</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">A range of characters. Here, lowercase a to z.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">[^a-z]</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">The caret negates the match. Here, not lowercase a to z.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">\w</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Any word character or underscore. Same as <span class="literal">[A-Za-z0-9_]</span>.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">\d</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Any digit.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span epub:type="pagebreak" id="page_215"/><span class="literal">\s</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">A space.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">\t</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Tab character.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">\n</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Newline character.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">\r</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Carriage return character.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">^</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Match at the start of a string.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">$</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Match at the end of a string.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">?</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Get the preceding match zero or one time.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">*</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Get the preceding match zero or more times.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">+</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Get the preceding match one or more times.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">{<em>m</em>}</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Get the preceding match exactly <em>m</em> times.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">{<em>m</em>,<em>n</em>}</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Get the preceding match between <em>m</em> and <em>n</em> times.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><em>a</em><span class="literal">|</span><em>b</em></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">The pipe denotes alternation. Find either <em>a</em> or <em>b</em>.</p></td>
</tr>
<tr>
<td class="table-c" style="vertical-align: top;"><p class="taba"><span class="literal">( )</span></p></td>
<td class="table-c" style="vertical-align: top;"><p class="taba">Create and report a capture group or set precedence.</p></td>
</tr>
<tr>
<td class="table-ca" style="vertical-align: top;"><p class="taba"><span class="literal">(?: )</span></p></td>
<td class="table-ca" style="vertical-align: top;"><p class="taba">Negate the reporting of a capture group.</p></td>
</tr>
</tbody>
</table>
<p class="indent">Using these basic regular expressions, you can match various kinds of characters and also indicate how many times and where to match them. For example, placing characters inside square brackets (<span class="literal">[]</span>) lets you match any single character or a range. So, <span class="literal">[FGz]</span> matches a single <span class="literal">F</span>, <span class="literal">G</span>, or <span class="literal">z</span>, whereas <span class="literal">[A-Za-z]</span> will match any uppercase or lowercase letter.</p>
<p class="indent">The backslash (<span class="literal">\</span>) precedes a designator for special characters, such as a tab (<span class="literal">\t</span>), digit (<span class="literal">\d</span>), or newline (<span class="literal">\n</span>), which is a line ending character in text files.</p>
<p class="indent">There are several ways to indicate how many times to match a character. Placing a number inside curly brackets indicates you want to match it that many times. For example, <span class="literal">\d{4}</span> matches four digits in a row, and <span class="literal">\d{1,4}</span> matches a digit between one and four times.</p>
<p class="indent">The <span class="literal">?</span>, <span class="literal">*</span>, and <span class="literal">+</span> characters provide a useful shorthand notation for the number of matches. For example, the plus sign (<span class="literal">+</span>) after a character indicates to match it one or more times. So, the expression <span class="literal">a+</span> would find the <span class="literal">aa</span> characters in the string <span class="literal">aardvark</span>.</p>
<p class="indent">Additionally, parentheses indicate a <em>capture group</em>, which you can use to specify just a portion of the matched text to display in the query results. This is useful for reporting back just a part of a matched expression. For example, if you were hunting for an <span class="codeitalic">HH:</span><span class="codeitalic">MM:</span><span class="codeitalic">SS</span> time format in text and wanted to report only the hour, you could use an expression such as <span class="literal">(\d{2}):\d{2}:\d{2}</span>. This looks for two digits (<span class="literal">\d{2}</span>) of the hour followed by a colon, another two digits for the minutes and a colon, and then the two-digit seconds. By placing the first <span class="literal">\d{2}</span> inside parentheses, you can extract only those two digits, even though the entire expression matches the full time.</p>
<p class="indent"><a href="ch13.xhtml#ch13tab2">Table 13-2</a> shows examples of combining regular expressions to capture different portions of the sentence “The game starts at 7 p.m. on May 2, 2019.”</p>
<p class="tabcap" id="ch13tab2"><span epub:type="pagebreak" id="page_216"/><strong>Table 13-2:</strong> Regular Expression Matching Examples</p>
<table class="topbot-d">
<thead>
<tr>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Expression</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>What it matches</strong></p></td>
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Result</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">.+</span></p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba">Any character one or more times</p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">The game starts at 7 p.m. on May 2, 2019.</span></p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">\d{1,2} (?:a.m.|p.m.)</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">One or two digits followed by a space and <em>a.m.</em> or <em>p.m.</em> in a noncapture group</p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">7 p.m.</span></p></td>
</tr>
<tr>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">^\w+</span></p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba">One or more word characters at the start</p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">The</span></p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">\w+.$</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">One or more word characters followed by any character at the end</p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">2019.</span></p></td>
</tr>
<tr>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">May|June</span></p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba">Either of the words <em>May</em> or <em>June</em></p></td>
<td class="table-a" style="vertical-align: top;"><p class="taba"><span class="literal">May</span></p></td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">\d{4}</span></p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba">Four digits</p></td>
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">2019</span></p></td>
</tr>
<tr>
<td class="tableba" style="vertical-align: top;"><p class="taba"><span class="literal">May \d, \d{4}</span></p></td>
<td class="tableba" style="vertical-align: top;"><p class="taba"><em>May</em> followed by a space, digit, comma, space, and four digits</p></td>
<td class="tableba" style="vertical-align: top;"><p class="taba"><span class="literal">May 2, 2019</span></p></td>
</tr>
</tbody>
</table>
<p class="indent">These results show the usefulness of regular expressions for selecting only the parts of the string that interest us. For example, to find the time, we use the expression <span class="literal">\d{1,2} (?:a.m.|p.m.)</span> to look for either one or two digits because the time could be a single or double digit followed by a space. Then we look for either <span class="literal">a.m.</span> or <span class="literal">p.m.</span>; the pipe symbol separating the terms indicates the either-or condition, and placing them in parentheses separates the logic from the rest of the expression. We need the <span class="literal">?:</span> symbol to indicate that we don’t want to treat the terms inside the parentheses as a capture group, which would report <span class="literal">a.m.</span> or <span class="literal">p.m.</span> only. The <span class="literal">?:</span> ensures that the full match will be returned.</p>
<p class="indent">You can use any of these regular expressions in pgAdmin by placing the text and regular expression inside the <span class="literal">substring(</span><span class="codeitalic">string from</span> <span class="codeitalic">pattern</span><span class="literal">)</span> function to return the matched text. For example, to find the four-digit year, use the following query:</p>
<p class="programs">SELECT substring('The game starts at 7 p.m. on May 2, 2019.' from '\d{4}');</p>
<p class="indent">This query should return <span class="literal">2019</span>, because we specified that the pattern should look for any digit that is four characters long, and 2019 is the only digit in this string that matches these criteria. You can check out sample <span class="literal">substring()</span> queries for all the examples in <a href="ch13.xhtml#ch13tab2">Table 13-2</a> in the book’s code resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>.</p>
<p class="indent">The lesson here is that if you can identify a pattern in the text, you can use a combination of regular expression symbols to locate it. This technique is particularly useful when you have repeating patterns in text that you want to turn into a set of data to analyze. Let’s practice how to use regular expression functions using a real-world example.</p>
<h4 class="h4" id="lev226"><em>Turning Text to Data with Regular Expression Functions</em></h4>
<p class="noindent">A sheriff’s department in one of the Washington, D.C., suburbs publishes daily reports that detail the date, time, location, and description <span epub:type="pagebreak" id="page_217"/>of incidents the department investigates. These reports would be great to analyze, except they post the information in Microsoft Word documents saved as PDF files, which is not the friendliest format for importing into a database.</p>
<p class="indent">If I copy and paste incidents from the PDF into a text editor, the result is blocks of text that look something like <a href="ch13.xhtml#ch13list1">Listing 13-1</a>:</p>
<p class="programs"><span class="ent">➊</span> 4/16/17-4/17/17<br/><span class="ent">➋</span> 2100-0900 hrs.<br/><span class="ent">➌</span> 46000 Block Ashmere Sq.<br/><span class="ent">➍</span> Sterling<br/><span class="ent">➎</span> Larceny: <span class="ent">➏</span>The victim reported that a<br/>  bicycle was stolen from their opened<br/>  garage door during the overnight hours.<br/><span class="ent">➐</span> C0170006614<br/><br/>  04/10/17<br/>  1605 hrs.<br/>  21800 block Newlin Mill Rd.<br/>  Middleburg<br/>  Larceny: A license plate was reported<br/>  stolen from a vehicle.<br/>  SO170006250</p>
<p class="listing" id="ch13list1"><em>Listing 13-1: Crime reports text</em></p>
<p class="indent">Each block of text includes dates <span class="ent">➊</span>, times <span class="ent">➋</span>, a street address <span class="ent">➌</span>, city or town <span class="ent">➍</span>, the type of crime <span class="ent">➎</span>, and a description of the incident <span class="ent">➏</span>. The last piece of information is a code <span class="ent">➐</span> that might be a unique ID for the incident, although we’d have to check with the sheriff’s department to be sure. There are slight inconsistencies. For example, the first block of text has two dates (<span class="literal">4/16/17-4/17/17</span>) and two times (<span class="literal">2100-0900 hrs.</span>), meaning the exact time of the incident is unknown and likely occurred within that time span. The second block has one date and time.</p>
<p class="indent">If you compile these reports regularly, you can expect to find some good insights that could answer important questions: Where do crimes tend to occur? Which crime types occur most frequently? Do they happen more often on weekends or weekdays? Before you can start answering these questions, you’ll need to extract the text into table columns using regular expressions.</p>
<h5 class="h5">Creating a Table for Crime Reports</h5>
<p class="noindent">I’ve collected five of the crime incidents into a file named <em>crime_reports.csv</em> that you can download at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>. Download the file and save it on your computer. Then use the code in <a href="ch13.xhtml#ch13list2">Listing 13-2</a> to build a table that has a column for each data element you can parse from the text using a regular expression.</p>
<p class="programs"><span epub:type="pagebreak" id="page_218"/>CREATE TABLE crime_reports (<br/>    crime_id bigserial PRIMARY KEY,<br/>    date_1 timestamp with time zone,<br/>    date_2 timestamp with time zone,<br/>    street varchar(250),<br/>    city varchar(100),<br/>    crime_type varchar(100),<br/>    description text,<br/>    case_number varchar(50),<br/>    original_text text NOT NULL<br/>);<br/><br/>COPY crime_reports (original_text)<br/>FROM '<em>C:\YourDirectory\</em>crime_reports.csv'<br/>WITH (FORMAT CSV, HEADER OFF, QUOTE '"');</p>
<p class="listing" id="ch13list2"><em>Listing 13-2: Creating and loading the <span class="literal">crime_reports</span> table</em></p>
<p class="indent">Run the <span class="literal">CREATE TABLE</span> statement in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>, and then use <span class="literal">COPY</span> to load the text into the column <span class="literal">original_text</span>. The rest of the columns will be <span class="literal">NULL</span> until we fill them.</p>
<p class="indent">When you run <span class="literal">SELECT original_text FROM crime_reports;</span> in pgAdmin, the results grid should display five rows and the first several words of each report. When you hover your cursor over any cell, pgAdmin shows all the text in that row, as shown in <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>.</p>
<div class="image"><a id="ch13fig1"/><img alt="image" src="../images/f0218-01.jpg"/></div>
<p class="figcap"><em>Figure 13-1: Displaying additional text in the pgAdmin results grid</em></p>
<p class="indent">Now that you’ve loaded the text you’ll be parsing, let’s explore this data using PostgreSQL regular expression functions.</p>
<h5 class="h5" id="ch13lev3sec1">Matching Crime Report Date Patterns</h5>
<p class="noindent">The first piece of data we want to extract from the report <span class="literal">original_text</span> is the date or dates of the crime. Most of the reports have one date, although one has two. The reports also have associated times, and we’ll combine the extracted date and time into a timestamp. We’ll fill <span class="literal">date_1</span> with the first (or only) date and time in each report. In cases where a second date or second time exists, we’ll create a timestamp and add it to <span class="literal">date_2</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_219"/>For extracting data, we’ll use the <span class="literal">regexp_match(</span><span class="codeitalic">string</span><span class="literal">,</span> <span class="codeitalic">pattern</span><span class="literal">)</span> function, which is similar to <span class="literal">substring()</span> with a few exceptions. One is that it returns each match as text in an array. Also, if there are no matches, it returns <span class="literal">NULL</span>. As you might recall from <a href="ch05.xhtml#ch05">Chapter 5</a>, arrays are a list of elements; in one exercise, you used an array to pass a list of values into the <span class="literal">percentile_cont()</span> function to calculate quartiles. I’ll show you how to work with results that come back as an array when we parse the crime reports.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The <span class="literal">regexp_match()</span> function was introduced in PostgreSQL 10 and is not available in earlier versions.</em></p>
</div>
<p class="indent">To start, let’s use <span class="literal">regexp_match()</span> to find dates in each of the five incidents in <span class="literal">crime_reports</span>. The general pattern to match is <span class="codeitalic">MM/</span><span class="codeitalic">DD/</span><span class="codeitalic">YY</span>, although there may be one or two digits for both the month and date. Here’s a regular expression that matches the pattern:</p>
<p class="programs">\d{1,2}\/\d{1,2}\/\d{2}</p>
<p class="indent">In this expression, <span class="literal">\d{1,2}</span> indicates the month. The numbers inside the curly brackets specify that you want at least one digit and at most two digits. Next, you want to look for a forward slash (/), but because a forward slash can have special meaning in regular expressions, you must <em>escape</em> that character by placing a backslash (\) in front of it, like this <span class="literal">\/</span>. Escaping a character in this context simply means we want to treat it as a literal rather than letting it take on special meaning. So, the combination of the backslash and forward slash (<span class="literal">\/</span>) indicates you want a forward slash.</p>
<p class="indent">Another <span class="literal">\d{1,2}</span> follows for a single- or double-digit day of the month. The expression ends with a second escaped forward slash and <span class="literal">\d{2}</span> to indicate the two-digit year. Let’s pass the expression <span class="literal">\d{1,2}\/\d{1,2}\/\d{2}</span> to <span class="literal">regexp_match()</span>, as shown in <a href="ch13.xhtml#ch13list3">Listing 13-3</a>:</p>
<p class="programs">SELECT crime_id,<br/>       regexp_match(original_text, '\d{1,2}\/\d{1,2}\/\d{2}')<br/>FROM crime_reports;</p>
<p class="listing" id="ch13list3"><em>Listing 13-3: Using <span class="literal">regexp_match()</span> to find the first date</em></p>
<p class="indent">Run that code in pgAdmin, and the results should look like this:</p>
<p class="programs">crime_id    regexp_match<br/>--------    ------------<br/>       1    {4/16/17}<br/>       2    {4/8/17}<br/>       3    {4/4/17}<br/>       4    {04/10/17}<br/>       5    {04/09/17}</p>
<p class="indent"><span epub:type="pagebreak" id="page_220"/>Note that each row shows the first date listed for the incident, because <span class="literal">regexp_match()</span> returns the first match it finds by default. Also note that each date is enclosed in curly brackets. That’s PostgreSQL indicating that <span class="literal">r</span><span class="literal">egexp_match</span><span class="literal">()</span> returns each result in an array, or list of elements. In “Extracting Text from the <span class="literal">regexp_match()</span> Result” on <a href="ch13.xhtml#page_224">page 224</a>, I’ll show you how to access those elements from the array. You can also read more about using arrays in PostgreSQL at <em><a href="https://www.postgresql.org/docs/current/static/arrays.html">https://www.postgresql.org/docs/current/static/arrays.html</a></em>.</p>
<h5 class="h5">Matching the Second Date When Present</h5>
<p class="noindent">We’ve successfully extracted the first date from each report. But recall that one of the five incidents has a second date. To find and display all the dates in the text, you must use the related <span class="literal">regexp_matches()</span> function and pass in an option in the form of the flag <span class="literal">g</span>, as shown in <a href="ch13.xhtml#ch13list4">Listing 13-4</a>.</p>
<p class="programs">SELECT crime_id,<br/>       regexp_matches(original_text, '\d{1,2}\/\d{1,2}\/\d{2}', 'g'<span class="ent">➊</span>)<br/>FROM crime_reports;</p>
<p class="listing" id="ch13list4"><em>Listing 13-4: Using the <span class="literal">regexp_matches()</span> function with the <span class="literal">'g'</span> flag</em></p>
<p class="indent">The <span class="literal">regexp_matches()</span> function, when supplied the <span class="literal">g</span> flag <span class="ent">➊</span>, differs from <span class="literal">regexp_match()</span> by returning each match the expression finds as a row in the results rather than returning just the first match.</p>
<p class="indent">Run the code again with this revision; you should now see two dates for the incident that has a <span class="literal">crime_id</span> of <span class="literal">1</span>, like this:</p>
<p class="programs">crime_id    regexp_matches<br/>--------    --------------<br/>       1    {4/16/17}<br/>       1    {4/17/17}<br/>       2    {4/8/17}<br/>       3    {4/4/17}<br/>       4    {04/10/17}<br/>       5    {04/09/17}</p>
<p class="indent">Any time a crime report has a second date, we want to load it and the associated time into the <span class="literal">date_2</span> column. Although adding the <span class="literal">g</span> flag shows us all the dates, to extract just the second date in a report, we can use the pattern we always see when two dates exist. In <a href="ch13.xhtml#ch13list1">Listing 13-1</a>, the first block of text showed the two dates separated by a hyphen, like this:</p>
<p class="programs">4/16/17-4/17/17</p>
<p class="indent">This means you can switch back to <span class="literal">regexp_match()</span> and write a regular expression to look for a hyphen followed by a date, as shown in <a href="ch13.xhtml#ch13list5">Listing 13-5</a>.</p>
<p class="programs"><span epub:type="pagebreak" id="page_221"/>SELECT crime_id,<br/>       regexp_match(original_text, '-\d{1,2}\/\d{1,2}\/\d{2}')<br/>FROM crime_reports;</p>
<p class="listing" id="ch13list5"><em>Listing 13-5: Using <span class="literal">regexp_match()</span> to find the second date</em></p>
<p class="indent">Although this query finds the second date in the first item (and returns a <span class="literal">NULL</span> for the rest), there’s an unintended consequence: it displays the hyphen along with it.</p>
<p class="programs">crime_id    regexp_match<br/>--------    ------------<br/>       1    {-4/17/17}<br/>       2    <br/>       3    <br/>       4<br/>       5</p>
<p class="indent">You don’t want to include the hyphen, because it’s an invalid format for the <span class="literal">timestamp</span> data type. Fortunately, you can specify the exact part of the regular expression you want to return by placing parentheses around it to create a capture group, like this:</p>
<p class="programs">-(\d{1,2}/\d{1,2}/\d{1,2})</p>
<p class="indent">This notation returns only the part of the regular expression you want. Run the modified query in <a href="ch13.xhtml#ch13list6">Listing 13-6</a> to report only the data in parentheses.</p>
<p class="programs">SELECT crime_id,<br/>       regexp_match(original_text, '-(\d{1,2}\/\d{1,2}\/\d{1,2})')<br/>FROM crime_reports;</p>
<p class="listing" id="ch13list6"><em>Listing 13-6: Using a capture group to return only the date</em></p>
<p class="indent">The query in <a href="ch13.xhtml#ch13list6">Listing 13-6</a> should return just the second date without the leading hyphen, as shown here:</p>
<p class="programs">crime_id    regexp_match<br/>--------    ------------<br/>       1    {4/17/17}<br/>       2<br/>       3<br/>       4<br/>       5</p>
<p class="indent">The process you’ve just completed is typical. You start with text to analyze, and then write and refine the regular expression until it finds the data you want. So far, we’ve created regular expressions to match the first date and a second date, if it exists. Now, let’s use regular expressions to extract additional data elements.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_222"/>Matching Additional Crime Report Elements</h5>
<p class="noindent">In this section, we’ll capture times, addresses, crime type, description, and case number from the crime reports. Here are the expressions for capturing this information:</p>
<p class="noindentt"><strong>First hour <span class="literal">\/\d{2}\n(\d{4})</span></strong></p>
<p class="noindent1">The first hour, which is the hour the crime was committed or the start of the time range, always follows the date in each crime report, like this:</p>
<p class="programs">4/16/17-4/17/17<br/>2100-0900 hrs.</p>
<p class="indentv">To find the first hour, we start with an escaped forward slash and <span class="literal">\d{2}</span>, which represents the two-digit year preceding the first date (<span class="literal">17</span>). The <span class="literal">\n</span> character indicates the newline because the hour always starts on a new line, and <span class="literal">\d{4}</span> represents the four-digit hour (<span class="literal">2100</span>). Because we just want to return the four digits, we put <span class="literal">\d{4}</span> inside parentheses as a capture group.</p>
<p class="noindentt"><strong>Second hour <span class="literal">\/\d{2}\n\d{4}-(\d{4})</span></strong></p>
<p class="noindent1">If the second hour exists, it will follow a hyphen, so we add a hyphen and another <span class="literal">\d{4}</span> to the expression we just created for the first hour. Again, the second <span class="literal">\d{4}</span> goes inside a capture group, because <span class="literal">0900</span> is the only hour we want to return.</p>
<p class="noindentt"><strong>Street <span class="literal">hrs.\n(\d+ .+(?:Sq.|Plz.|Dr.|Ter.|Rd.))</span></strong></p>
<p class="noindent1">In this data, the street always follows the time’s <span class="literal">hrs.</span> designation and a newline (<span class="literal">\n</span>), like this:</p>
<p class="programs">04/10/17<br/>1605 hrs.<br/>21800 block Newlin Mill Rd.</p>
<p class="indentv">The street address always starts with some number that varies in length and ends with an abbreviated suffix of some kind. To describe this pattern, we use <span class="literal">\d+</span> to match any digit that appears one or more times. Then we specify a space and look for any character one or more times using the dot wildcard and plus sign (<span class="literal">.+</span>) notation. The expression ends with a series of terms separated by the alternation pipe symbol that looks like this: <span class="literal">(?:Sq.|Plz.|Dr.|Ter.|Rd.)</span>. The terms are inside parentheses, so the expression will match one or another of those terms. When we group terms like this, if we don’t want the parentheses to act as a capture group, we need to add <span class="literal">?:</span> to negate that effect.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In a large data set, it’s likely roadway names would end with suffixes beyond the five in our regular expression. After making an initial pass at extracting the street, you can run a query to check for unmatched rows to find additional suffixes to match.</em></p>
</div>
<p class="noindentt"><span epub:type="pagebreak" id="page_223"/><strong>City <span class="literal">(?:Sq.|Plz.|Dr.|Ter.|Rd.)\n(\w+ \w+|\w+)\n</span></strong></p>
<p class="noindent1">Because the city always follows the street suffix, we reuse the terms separated by the alternation symbol we just created for the street. We follow that with a newline (<span class="literal">\n</span>) and then use a capture group to look for two words or one word <span class="literal">(\w+ \w+|\w+)</span> before a final newline, because a town or city name can be more than a single word.</p>
<p class="noindentt"><strong>Crime type <span class="literal">\n(?:\w+ \w+|\w+)\n(.*):</span></strong></p>
<p class="noindent1">The type of crime always precedes a colon (the only time a colon is used in each report) and might consist of one or more words, like this:</p>
<p class="programs"><em>--snip--</em><br/>Middleburg<br/>Larceny: A license plate was reported<br/>stolen from a vehicle.<br/>SO170006250<br/><em>--snip--</em></p>
<p class="indentv">To create an expression that matches this pattern, we follow a newline with a nonreporting capture group that looks for the one- or two-word city. Then we add another newline and match any character that occurs zero or more times before a colon using <span class="literal">(.*):</span>.</p>
<p class="noindentt"><strong>Description <span class="literal">:\s(.+)(?:C0|SO)</span></strong></p>
<p class="noindent1">The crime description always comes between the colon after the crime type and the case number. The expression starts with the colon, a space character (<span class="literal">\s</span>), and then a capture group to find any character that appears one or more times using the <span class="literal">.+</span> notation. The nonreporting capture group <span class="literal">(?:C0|SO)</span> tells the program to stop looking when it encounters either <span class="literal">C0</span> or <span class="literal">SO</span>, the two character pairs that start each case number (a C followed by a zero, and an S followed by a capital O). We have to do this because the description might have one or more line breaks.</p>
<p class="noindentt"><strong>Case number <span class="literal">(?:C0|SO)[0-9]+</span></strong></p>
<p class="noindent1">The case number starts with either <span class="literal">C0</span> or <span class="literal">SO</span>, followed by a set of digits. To match this pattern, the expression looks for either <span class="literal">C0</span> or <span class="literal">SO</span> in a nonreporting capture group followed by any digit from 0 to 9 that occurs one or more times using the <span class="literal">[0-9]</span> range notation.</p>
<p class="indentt">Now let’s pass these regular expressions to <span class="literal">regexp_match()</span> to see them in action. <a href="ch13.xhtml#ch13list7">Listing 13-7</a> shows a sample <span class="literal">regexp_match()</span> query that retrieves the case number, first date, crime type, and city:</p>
<p class="programs">SELECT<br/>    regexp_match(original_text, '(?:C0|SO)[0-9]+') AS case_number,<br/>    regexp_match(original_text, '\d{1,2}\/\d{1,2}\/\d{2}') AS date_1,<br/>    regexp_match(original_text, '\n(?:\w+ \w+|\w+)\n(.*):') AS crime_type,<br/>    regexp_match(original_text, '(?:Sq.|Plz.|Dr.|Ter.|Rd.)\n(\w+ \w+|\w+)\n')<br/>        AS city<br/>FROM crime_reports;</p>
<p class="listing" id="ch13list7"><em>Listing 13-7: Matching case number, date, crime type, and city</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_224"/>Run the code, and the results should look like this:</p>
<div class="image"><img alt="image" src="../images/prog_page_224.jpg"/></div>
<p class="indent">After all that wrangling, we’ve transformed the text into a structure that is more suitable for analysis. Of course, you would have to include many more incidents to count the frequency of crime type by city or the number of crimes per month to identify any trends.</p>
<p class="indent">To load each parsed element into the table’s columns, we’ll create an <span class="literal">UPDATE</span> query. But before you can insert the text into a column, you’ll need to learn how to extract the text from the array that <span class="literal">regexp_match()</span> returns.</p>
<h5 class="h5">Extracting Text from the regexp_match() Result</h5>
<p class="noindent">In <a href="ch13.xhtml#ch13lev3sec1">“Matching Crime Report Date Patterns”</a> on <a href="ch13.xhtml#page_218">page 218</a>, I mentioned that <span class="literal">regexp_match()</span> returns an array containing text values. Two clues reveal that these are text values. The first is that the data type designation in the column header shows <span class="literal">text[]</span> instead of <span class="literal">text</span>. The second is that each result is surrounded by curly brackets. <a href="ch13.xhtml#ch13fig2">Figure 13-2</a> shows how pgAdmin displays the results of the query in <a href="ch13.xhtml#ch13list7">Listing 13-7</a>.</p>
<div class="image"><a id="ch13fig2"/><img alt="image" src="../images/f0224-01.jpg"/></div>
<p class="figcap"><em>Figure 13-2: Array values in the pgAdmin results grid</em></p>
<p class="indent">The <span class="literal">crime_reports</span> columns we want to update are not array types, so rather than passing in the array values returned by <span class="literal">regexp_match()</span>, we need to extract the values from the array first. We do this by using array notation, as shown in <a href="ch13.xhtml#ch13list8">Listing 13-8</a>.</p>
<p class="programs">SELECT<br/>    crime_id,<br/>  <span class="ent">➊</span> (regexp_match(original_text, '(?:C0|SO)[0-9]+'))[1]<span class="ent">➋</span><br/>        AS case_number<br/>FROM crime_reports;</p>
<p class="listing" id="ch13list8"><em>Listing 13-8: Retrieving a value from within an array</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_225"/>First, we wrap the <span class="literal">regexp_match()</span> function <span class="ent">➊</span> in parentheses. Then, at the end, we provide a value of <span class="literal">1</span>, which represents the first element in the array, enclosed in square brackets <span class="ent">➋</span>. The query should produce the following results:</p>
<p class="programs">crime_id    case_number<br/>--------    -----------<br/>       1    C0170006614<br/>       2    C0170006162<br/>       3    C0170006079<br/>       4    SO170006250<br/>       5    SO170006211</p>
<p class="indent">Now the data type designation in the pgAdmin column header should show <span class="literal">text</span> instead of <span class="literal">text[]</span>, and the values are no longer enclosed in curly brackets. We can now insert these values into <span class="literal">crime_reports</span> using an <span class="literal">UPDATE</span> query.</p>
<h5 class="h5">Updating the crime_reports Table with Extracted Data</h5>
<p class="noindent">With each element currently available as text, we can update columns in the <span class="literal">crime_reports</span> table with the appropriate data from the original crime report. To start, <a href="ch13.xhtml#ch13list9">Listing 13-9</a> combines the extracted first date and time into a single <span class="literal">timestamp</span> value for the column <span class="literal">date_1</span>.</p>
<p class="programs">  UPDATE crime_reports<br/><span class="ent">➊</span> SET date_1 =<br/>  (<br/>    <span class="ent">➋</span> (regexp_match(original_text, '\d{1,2}\/\d{1,2}\/\d{2}'))[1]<br/>        <span class="ent">➌</span> || ' ' ||<br/>    <span class="ent">➍</span> (regexp_match(original_text, '\/\d{2}\n(\d{4})'))[1]<br/>        <span class="ent">➎</span> ||' US/Eastern'<br/><span class="ent">➏</span> )::timestamptz;<br/><br/>  SELECT crime_id,<br/>         date_1,<br/>         original_text<br/>  FROM crime_reports;</p>
<p class="listing" id="ch13list9"><em>Listing 13-9: Updating the <span class="literal">crime_reports</span> <span class="literal">date_1</span> column</em></p>
<p class="indent">Because the <span class="literal">date_1</span> column is of type <span class="literal">timestamp</span>, we must provide an input in that data type. To do that, we’ll use the PostgreSQL double-pipe (<span class="literal">||</span>) concatenation operator to combine the extracted date and time in a format that’s acceptable for <span class="literal">timestamp with time zone</span> input. In the <span class="literal">SET</span> clause <span class="ent">➊</span>, we start with the regex pattern that matches the first date <span class="ent">➋</span>. Next, we concatenate the date with a space using two single quotes <span class="ent">➌</span> and repeat the concatenation operator. This step combines the date with a space before connecting it to the regex pattern that matches the time <span class="ent">➍</span>. Then we include the time zone for the Washington, D.C., area by concatenating that at the end of the string <span class="ent">➎</span> using the <span class="literal">US/Eastern</span> designation. <span epub:type="pagebreak" id="page_226"/>Concatenating these elements creates a string in the pattern of <span class="codeitalic">MM/</span><span class="codeitalic">DD/</span><span class="codeitalic">YY</span> <span class="codeitalic">HHMM</span> <span class="codeitalic">TIMEZONE</span>, which is acceptable as a <span class="literal">timestamp</span> input. We cast the string to a <span class="literal">timestamp with time zone</span> data type <span class="ent">➏</span> using the PostgreSQL double-colon shorthand and the <span class="literal">timestamptz</span> abbreviation.</p>
<p class="indent">When you run the <span class="literal">UPDATE</span> portion of the code, PostgreSQL should return the message <span class="literal">UPDATE 5</span>. Running the <span class="literal">SELECT</span> statement in pgAdmin should show the now-filled <span class="literal">date_1</span> column alongside a portion of the <span class="literal">original_text</span> column, like this:</p>
<div class="image"><img alt="image" src="../images/prog_page_226.jpg"/></div>
<p class="indent">At a glance, you can see that <span class="literal">date_1</span> accurately captures the first date and time that appears in the original text and puts it into a useable format that we can analyze. Note that if you’re not in the Eastern time zone, the timestamps will instead reflect your pgAdmin client’s time zone. As you learned in <a href="ch11.xhtml#lev175">“Setting the Time Zone”</a> on <a href="ch11.xhtml#page_178">page 178</a>, you can use the command <span class="literal">SET t</span><span class="literal">imezone</span> <span class="literal">TO 'US/Eastern';</span> to change the client to reflect Eastern time.</p>
<h5 class="h5">Using CASE to Handle Special Instances</h5>
<p class="noindent">You could write an <span class="literal">UPDATE</span> statement for each remaining data element, but combining those statements into one would be more efficient. <a href="ch13.xhtml#ch13list10">Listing 13-10</a> updates all the <span class="literal">crime_reports</span> columns using a single statement while handling inconsistent values in the data.</p>
<p class="programs"><br/>UPDATE crime_reports<br/>SET date_1<span class="ent">➊</span> =<br/>    (<br/>      (regexp_match(original_text, '\d{1,2}\/\d{1,2}\/\d{2}'))[1]<br/>          || ' ' ||<br/>      (regexp_match(original_text, '\/\d{2}\n(\d{4})'))[1] <br/>          ||' US/Eastern'<br/>    )::timestamptz,<br/>            <br/>    date_2<span class="ent">➋</span> = <br/>    CASE<span class="ent">➌</span> <br/>        WHEN<span class="ent">➍</span> (SELECT regexp_match(original_text, '-(\d{1,2}\/\d{1,2}\/\d{1,2})') IS NULL<span class="ent">➎</span>)<br/>                AND (SELECT regexp_match(original_text, '\/\d{2}\n\d{4}-(\d{4})') IS NOT NULL<span class="ent">➏</span>)<br/>        THEN<span class="ent">➐</span> <br/>          ((regexp_match(original_text, '\d{1,2}\/\d{1,2}\/\d{2}'))[1]<br/>              || ' ' ||<br/>          (regexp_match(original_text, '\/\d{2}\n\d{4}-(\d{4})'))[1] <br/>              ||' US/Eastern'<br/>          )::timestamptz<br/><span epub:type="pagebreak" id="page_227"/>        WHEN<span class="ent">➑</span> (SELECT regexp_match(original_text, '-(\d{1,2}\/\d{1,2}\/\d{1,2})') IS NOT NULL)<br/>                AND (SELECT regexp_match(original_text, '\/\d{2}\n\d{4}-(\d{4})') IS NOT NULL)<br/>        THEN<br/>          ((regexp_match(original_text, '-(\d{1,2}\/\d{1,2}\/\d{1,2})'))[1]<br/>              || ' ' ||<br/>          (regexp_match(original_text, '\/\d{2}\n\d{4}-(\d{4})'))[1]<br/>              ||' US/Eastern'<br/>          )::timestamptz<br/><br/>        ELSE NULL<span class="ent">➒</span><br/>    END,<br/>    street = (regexp_match(original_text, 'hrs.\n(\d+ .+(?:Sq.|Plz.|Dr.|Ter.|Rd.))'))[1],<br/>    city = (regexp_match(original_text,<br/>                           '(?:Sq.|Plz.|Dr.|Ter.|Rd.)\n(\w+ \w+|\w+)\n'))[1],<br/>    crime_type = (regexp_match(original_text, '\n(?:\w+ \w+|\w+)\n(.*):'))[1],<br/>    description = (regexp_match(original_text, ':\s(.+)(?:C0|SO)'))[1],<br/>    case_number = (regexp_match(original_text, '(?:C0|SO)[0-9]+'))[1];</p>
<p class="listing" id="ch13list10"><em>Listing 13-10: Updating all <span class="literal">crime_reports</span> columns</em></p>
<p class="indent">This <span class="literal">UPDATE</span> statement might look intimidating, but it’s not if we break it down by column. First, we use the same code from <a href="ch13.xhtml#ch13list9">Listing 13-9</a> to update the <span class="literal">date_1</span> column <span class="ent">➊</span>. But to update <span class="literal">date_2</span> <span class="ent">➋</span>, we need to account for the inconsistent presence of a second date and time. In our limited data set, there are three possibilities:</p>
<ol>
<li class="noindent"><p class="list">A second hour exists but not a second date. This occurs when a report covers a range of hours on one date.</p></li>
<li class="noindent"><p class="list">A second date and second hour exist. This occurs when a report covers more than one date.</p></li>
<li class="noindent"><p class="list">Neither a second date nor a second hour exists.</p></li>
</ol>
<p class="indent">To insert the correct value in <span class="literal">date_2</span> for each scenario, we use the <span class="literal">CASE</span> statement syntax you learned in <a href="ch12.xhtml#lev216">“Reclassifying Values with <span class="literal">CASE</span>”</a> on <a href="ch12.xhtml#page_207">page 207</a> to test for each possibility. After the <span class="literal">CASE</span> keyword <span class="ent">➌</span>, we use a series of <span class="literal">WHEN ... THEN</span> statements to check for the first two conditions and provide the value to insert; if neither condition exists, we use an <span class="literal">ELSE</span> keyword to provide a <span class="literal">NULL</span>.</p>
<p class="indent">The first <span class="literal">WHEN</span> statement <span class="ent">➍</span> checks whether <span class="literal">regexp_match()</span> returns a <span class="literal">NULL</span> <span class="ent">➎</span> for the second date and a value for the second hour (using <span class="literal">IS NOT NULL</span> <span class="ent">➏</span>). If that condition evaluates as <span class="literal">true</span>, the <span class="literal">THEN</span> statement <span class="ent">➐</span> concatenates the first date with the second hour to create a timestamp for the update.</p>
<p class="indent">The second <span class="literal">WHEN</span> statement <span class="ent">➑</span> checks that <span class="literal">regexp_match()</span> returns a value for the second hour and second date. If <span class="literal">true</span>, the <span class="literal">THEN</span> statement concatenates the second date with the second hour to create a timestamp.</p>
<p class="indent">If neither of the two <span class="literal">WHEN</span> statements returns <span class="literal">true</span>, the <span class="literal">ELSE</span> statement <span class="ent">➒</span> provides a <span class="literal">NULL</span> for the update because there is only a first date and first time.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The <span class="literal">WHEN</span> statements handle the possibilities that exist in our small sample data set. If you are working with more data, you might need to handle additional variations, such as a second date but not a second time.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_228"/>When we run the full query in <a href="ch13.xhtml#ch13list10">Listing 13-10</a>, PostgreSQL should report <span class="literal">UPDATE 5</span>. Success! Now that we’ve updated all the columns with the appropriate data while accounting for elements that have additional data, we can examine all the columns of the table and find the parsed elements from <span class="literal">original_text</span>. <a href="ch13.xhtml#ch13list11">Listing 13-11</a> queries four of the columns:</p>
<p class="programs">SELECT date_1,<br/>       street,<br/>       city,<br/>       crime_type<br/>FROM crime_reports;</p>
<p class="listing" id="ch13list11"><em>Listing 13-11: Viewing selected crime data</em></p>
<p class="indent">The results of the query should show a nicely organized set of data that looks something like this:</p>
<div class="image"><img alt="image" src="../images/prog_page_228.jpg"/></div>
<p class="indent">You’ve successfully transformed raw text into a table that can answer questions and reveal storylines about crime in this area.</p>
<h5 class="h5">The Value of the Process</h5>
<p class="noindent">Writing regular expressions and coding a query to update a table can take time, but there is value to identifying and collecting data this way. In fact, some of the best data sets you’ll encounter are those you build yourself. Everyone can download the same data sets, but the ones you build are yours alone. You get to be first person to find and tell the story behind the data.</p>
<p class="indent">Also, after you set up your database and queries, you can use them again and again. In this example, you could collect crime reports every day (either by hand or by automating downloads using a programming language such as Python) for an ongoing data set that you can mine continually for trends.</p>
<p class="indent">In the next section, we’ll finish our exploration of regular expressions using additional PostgreSQL functions.</p>
<h4 class="h4" id="lev227"><em>Using Regular Expressions with WHERE</em></h4>
<p class="noindent">You’ve filtered queries using <span class="literal">LIKE</span> and <span class="literal">ILIKE</span> in <span class="literal">WHERE</span> clauses. In this section, you’ll learn to use regular expressions in <span class="literal">WHERE</span> clauses so you can perform more complex matches.</p>
<p class="indent">We use a tilde (<span class="literal">~</span>) to make a case-sensitive match on a regular expression and a tilde-asterisk (<span class="literal">~*</span>) to perform a case-insensitive match. You can negate either expression by adding an exclamation point in front. <span epub:type="pagebreak" id="page_229"/>For example, <span class="literal">!~*</span> indicates to <em>not</em> match a regular expression that is case-insensitive. <a href="ch13.xhtml#ch13list12">Listing 13-12</a> shows how this works using the 2010 Census table <span class="literal">us_counties_2010</span> from previous exercises:</p>
<p class="programs">  SELECT geo_name<br/>  FROM us_counties_2010<br/><span class="ent">➊</span> WHERE geo_name ~* '(.+lade.+|.+lare.+)'<br/>  ORDER BY geo_name;<br/><br/>  SELECT geo_name<br/>  FROM us_counties_2010<br/><span class="ent">➋</span> WHERE geo_name ~* '.+ash.+' AND geo_name !~ 'Wash.+'<br/>  ORDER BY geo_name;</p>
<p class="listing" id="ch13list12"><em>Listing 13-12: Using regular expressions in a <span class="literal">WHERE</span> clause</em></p>
<p class="indent">The first <span class="literal">WHERE</span> clause <span class="ent">➊</span> uses the tilde-asterisk (<span class="literal">~*</span>) to perform a case-insensitive match on the regular expression <span class="literal">(.+lade.+|.+lare.+)</span> to find any county names that contain either the letters <span class="literal">lade</span> or <span class="literal">lare</span> between other characters. The results should show eight rows:</p>
<p class="programs">geo_name<br/>-------------------<br/>Bladen County<br/>Clare County<br/>Clarendon County<br/>Glades County<br/>Langlade County<br/>Philadelphia County<br/>Talladega County<br/>Tulare County</p>
<p class="indent">As you can see, the county names include the letters <span class="literal">lade</span> or <span class="literal">lare</span> between other characters.</p>
<p class="indent">The second <span class="literal">WHERE</span> clause <span class="ent">➋</span> uses the tilde-asterisk (<span class="literal">~*</span>) as well as a negated tilde (<span class="literal">!~</span>) to find county names containing the letters <span class="literal">ash</span> but excluding those starting with <span class="literal">Wash</span>. This query should return the following:</p>
<p class="programs">geo_name<br/>--------------<br/>Nash County<br/>Wabash County<br/>Wabash County<br/>Wabasha County</p>
<p class="indent">All four counties in this output have names that contain the letters <span class="literal">ash</span> but don’t start with <span class="literal">Wash</span>.</p>
<p class="indent">These are fairly simple examples, but you can do more complex matches using regular expressions that you wouldn’t be able to perform with the wildcards available with just <span class="literal">LIKE</span> and <span class="literal">ILIKE</span>.</p>
<h4 class="h4" id="lev228"><span epub:type="pagebreak" id="page_230"/><em>Additional Regular Expression Functions</em></h4>
<p class="noindent">Let’s look at three more regular expression functions you might find useful when working with text. <a href="ch13.xhtml#ch13list13">Listing 13-13</a> shows several regular expression functions that replace and split text:</p>
<p class="programs"><span class="ent">➊</span> SELECT regexp_replace('05/12/2018', '\d{4}', '2017');<br/><br/><span class="ent">➋</span> SELECT regexp_split_to_table('Four,score,and,seven,years,ago', ',');<br/><br/><span class="ent">➌</span> SELECT regexp_split_to_array('Phil Mike Tony Steve', ',');</p>
<p class="listing" id="ch13list13"><em>Listing 13-13: Regular expression functions to replace and split text</em></p>
<p class="indent">The <span class="literal">regexp_replace(</span><span class="codeitalic">string,</span> <span class="codeitalic">pattern,</span> <span class="codeitalic">replacement text</span><span class="literal">)</span> function lets you substitute a matched pattern with replacement text. In the example at <span class="ent">➊</span>, we’re searching the date string <span class="literal">05/12/2018</span> for any set of four digits in a row using <span class="literal">\d{4}</span>. When found, we replace them with the replacement text <span class="literal">2017</span>. The result of that query is <span class="literal">05/12/2017</span> returned as text.</p>
<p class="indent">The <span class="literal">regexp_split_to_table(</span><span class="codeitalic">string</span><span class="literal">,</span> <span class="codeitalic">pattern</span><span class="literal">)</span> function splits delimited text into rows. <a href="ch13.xhtml#ch13list13">Listing 13-13</a> uses this function to split the string <span class="literal">'</span><span class="literal">Four,score</span><span class="literal">,and,seven,years,ago'</span> on commas <span class="ent">➋</span>, resulting in a set of rows that has one word in each row:</p>
<p class="programs">regexp_split_to_table<br/>---------------------<br/>Four<br/>score<br/>and<br/>seven<br/>years<br/>ago</p>
<p class="indent">Keep this function in mind as you tackle the “Try It Yourself” exercises at the end of the chapter.</p>
<p class="indent">The <span class="literal">regexp_split_to_array(</span><span class="codeitalic">string,</span> <span class="codeitalic">pattern</span><span class="literal">)</span> function splits delimited text into an array. The example splits the string <span class="literal">Phil Mike Tony Steve</span> on spaces <span class="ent">➌</span>, returning a text array that should look like this in pgAdmin:</p>
<p class="programs">regexp_split_to_array<br/>----------------------<br/>{Phil,Mike,Tony,Steve}</p>
<p class="indent">The <span class="literal">text[]</span> notation in pgAdmin’s column header along with curly brackets around the results confirms that this is indeed an array type, which provides another means of analysis. For example, you could then use a function such as <span class="literal">array_length()</span> to count the number of words, as shown in <a href="ch13.xhtml#ch13list14">Listing 13-14</a>.</p>
<p class="programs"><span epub:type="pagebreak" id="page_231"/>SELECT array_length(regexp_split_to_array('Phil Mike Tony Steve', ' '), 1);</p>
<p class="listing" id="ch13list14"><em>Listing 13-14: Finding an array length</em></p>
<p class="indent">The query should return <span class="literal">4</span> because four elements are in this array. You can read more about <span class="literal">array_length()</span> and other array functions at <em><a href="https://www.postgresql.org/docs/current/static/functions-array.html">https://www.postgresql.org/docs/current/static/functions-array.html</a></em>.</p>
<h3 class="h3" id="lev229">Full Text Search in PostgreSQL</h3>
<p class="noindent">PostgreSQL comes with a powerful full text search engine that gives you more options when searching for information in large amounts of text. You’re familiar with Google or other web search engines and similar technology that powers search on news websites or research databases, such as LexisNexis. Although the implementation and capability of full text search demands several chapters, here I’ll walk you through a simple example of setting up a table for text search and functions for searching using PostgreSQL.</p>
<p class="indent">For this example, I assembled 35 speeches by former U.S. presidents who served after World War II through the Gerald R. Ford administration. Consisting mostly of State of the Union addresses, these public texts are available through the Internet Archive at <em><a href="https://archive.org/">https://archive.org/</a></em> and the University of California’s American Presidency Project at <em><a href="http://www.presidency.ucsb.edu/ws/index.php/">http://www.presidency.ucsb.edu/ws/index.php/</a></em>. You can find the data in the <em>sotu-1946-1977.csv</em> file along with the book’s resources at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>.</p>
<p class="indent">Let’s start with the data types unique to full text search.</p>
<h4 class="h4" id="lev230"><em>Text Search Data Types</em></h4>
<p class="noindent">PostgreSQL’s implementation of text search includes two data types. The <span class="literal">tsvector</span> data type represents the text to be searched and to be stored in an optimized form. The <span class="literal">tsquery</span> data type represents the search query terms and operators. Let’s look at the details of both.</p>
<h5 class="h5">Storing Text as Lexemes with tsvector</h5>
<p class="noindent">The <span class="literal">tsvector</span> data type reduces text to a sorted list of <em>lexemes</em>, which are units of meaning in language. Think of lexemes as words without the variations created by suffixes. For example, the <span class="literal">tsvector</span> format would store the words <em>washes</em>, <em>washed</em>, and <em>washing</em> as the lexeme <em>wash</em> while noting each word’s position in the original text. Converting text to <span class="literal">tsvector</span> also removes small <em>stop words</em> that usually don’t play a role in search, such as <em>the</em> or <em>it</em>.</p>
<p class="indent">To see how this data type works, let’s convert a string to <span class="literal">tsvector</span> format. <a href="ch13.xhtml#ch13list15">Listing 13-15</a> uses the PostgreSQL search function <span class="literal">to_tsvector()</span>, which normalizes the text “I am walking across the sitting room to sit with you” to lexemes:</p>
<p class="programs">SELECT to_tsvector('I am walking across the sitting room to sit with you.');</p>
<p class="listing" id="ch13list15"><em>Listing 13-15: Converting text to <span class="literal">tsvector</span> data</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_232"/>Execute the code, and it should return the following output in <span class="literal">tsvector</span> format:</p>
<p class="programs">'across':4 'room':7 'sit':6,9 'walk':3</p>
<p class="indent">The <span class="literal">to_tsvector()</span> function reduces the number of words from eleven to four, eliminating words such as <em>I</em>, <em>am</em>, and <em>the</em>, which are not helpful search terms. The function removes suffixes, changing <em>walking</em> to <em>walk</em> and <em>sitting</em> to <em>sit</em>. It also orders the words alphabetically, and the number following each colon indicates its position in the original string, taking stop words into account. Note that <em>sit</em> is recognized as being in two positions, one for <em>sitting</em> and one for <em>sit</em>.</p>
<h5 class="h5">Creating the Search Terms with tsquery</h5>
<p class="noindent">The <span class="literal">tsquery</span> data type represents the full text search query, again optimized as lexemes. It also provides operators for controlling the search. Examples of operators include the ampersand (<span class="literal">&amp;</span>) for AND, the pipe symbol (<span class="literal">|</span>) for OR, and the exclamation point (<span class="literal">!</span>) for NOT. A special <span class="literal">&lt;-&gt;</span> operator lets you search for adjacent words or words a certain distance apart.</p>
<p class="indent"><a href="ch13.xhtml#ch13list16">Listing 13-16</a> shows how the <span class="literal">to_tsquery()</span> function converts search terms to the <span class="literal">tsquery</span> data type.</p>
<p class="programs">SELECT to_tsquery('walking &amp; sitting');</p>
<p class="listing" id="ch13list16"><em>Listing 13-16: Converting search terms to <span class="literal">tsquery</span> data</em></p>
<p class="indent">After running the code, you should see that the resulting <span class="literal">tsquery</span> data type has normalized the terms into lexemes, which match the format of the data to search:</p>
<p class="programs">'walk' &amp; 'sit'</p>
<p class="indent">Now you can use terms stored as <span class="literal">tsquery</span> to search text optimized as <span class="literal">tsvector</span>.</p>
<h5 class="h5">Using the @@ Match Operator for Searching</h5>
<p class="noindent">With the text and search terms converted to the full text search data types, you can use the double at sign (<span class="literal">@@</span>) match operator to check whether a query matches text. The first query in <a href="ch13.xhtml#ch13list17">Listing 13-17</a> uses <span class="literal">to_tsquery()</span> to search for the words <em>walking</em> and <em>sitting</em>, which we combine with the <span class="literal">&amp;</span> operator. It returns a Boolean value of <span class="literal">true</span> because both <em>walking</em> and <em>sitting</em> are present in the text converted by <span class="literal">to_tsvector()</span>.</p>
<p class="programs">SELECT to_tsvector('I am walking across the sitting room') @@ to_tsquery('walking &amp; sitting');<br/>SELECT to_tsvector('I am walking across the sitting room') @@ to_tsquery('walking &amp; running');</p>
<p class="listing" id="ch13list17"><em>Listing 13-17: Querying a <span class="literal">tsvector</span> type with a <span class="literal">tsquery</span></em></p>
<p class="indent"><span epub:type="pagebreak" id="page_233"/>However, the second query returns <span class="literal">false</span> because both <em>walking</em> and <em>running</em> are not present in the text. Now let’s build a table for searching the speeches.</p>
<h4 class="h4" id="lev231"><em>Creating a Table for Full Text Search</em></h4>
<p class="noindent">Let’s start by creating a table to hold the speech text. The code in <a href="ch13.xhtml#ch13list18">Listing 13-18</a> creates and fills <span class="literal">president_speeches</span> so it contains a column for the original speech text as well as a column of type <span class="literal">tsvector</span>. The reason is that we need to convert the original speech text into that <span class="literal">tsvector</span> column to optimize it for searching. We can’t easily do that conversion during import, so let’s handle that as a separate step. Be sure to change the file path to match the location of your saved CSV file:</p>
<p class="programs">CREATE TABLE president_speeches (<br/>    sotu_id serial PRIMARY KEY,<br/>    president varchar(100) NOT NULL,<br/>    title varchar(250) NOT NULL,<br/>    speech_date date NOT NULL,<br/>    speech_text text NOT NULL,<br/>    search_speech_text tsvector<br/>);<br/><br/>COPY president_speeches (president, title, speech_date, speech_text)<br/>FROM '<em>C:\YourDirectory\</em>sotu-1946-1977.csv'<br/>WITH (FORMAT CSV, DELIMITER '|', HEADER OFF, QUOTE '@');</p>
<p class="listing" id="ch13list18"><em>Listing 13-18: Creating and filling the <span class="literal">president_speeches</span> table</em></p>
<p class="indent">After executing the query, run <span class="literal">SELECT * FROM president_speeches;</span> to see the data. In pgAdmin, hover your mouse over any cell to see extra words not visible in the results grid. You should see a sizeable amount of text in each row of the <span class="literal">speech_text</span> column.</p>
<p class="indent">Next, we copy the contents of <span class="literal">speech_text</span> to the <span class="literal">tsvector</span> column <span class="literal">search_speech_text</span> and transform it to that data type at the same time. The <span class="literal">UPDATE</span> query in <a href="ch13.xhtml#ch13list19">Listing 13-19</a> handles the task:</p>
<p class="programs">  UPDATE president_speeches<br/><span class="ent">➊</span> SET search_speech_text = to_tsvector('english', speech_text);</p>
<p class="listing" id="ch13list19"><em>Listing 13-19: Converting speeches to <span class="literal">tsvector</span> in the <span class="literal">search_speech_text</span> column</em></p>
<p class="indent">The <span class="literal">SET</span> clause <span class="ent">➊</span> fills <span class="literal">search_speech_text</span> with the output of <span class="literal">to</span><span class="literal">_tsvector()</span>. The first argument in the function specifies the language for parsing the lexemes. We’re using the default of <span class="literal">english</span> here, but you can substitute <span class="literal">spanish</span>, <span class="literal">german</span>, <span class="literal">french</span>, or whatever language you want to use (some languages may require you to find and install additional dictionaries). The second argument is the name of the input column. Run the code to fill the column.</p>
<p class="indent">Finally, we want to index the <span class="literal">search_speech_text</span> column to speed up searches. You learned about indexing in <a href="ch07.xhtml#ch07">Chapter 7</a>, which focused <span epub:type="pagebreak" id="page_234"/>on PostgreSQL’s default index type, B-Tree. For full text search, the PostgreSQL documentation recommends using the <em>Generalized Inverted Index</em> (<em>GIN</em>; see <em><a href="https://www.postgresql.org/docs/current/static/textsearch-indexes.html">https://www.postgresql.org/docs/current/static/textsearch-indexes.html</a></em>). You can add a GIN index using <span class="literal">CREATE INDEX</span> in <a href="ch13.xhtml#ch13list20">Listing 13-20</a>:</p>
<p class="programs">CREATE INDEX search_idx ON president_speeches USING gin(search_speech_text);</p>
<p class="listing" id="ch13list20"><em>Listing 13-20: Creating a GIN index for text search</em></p>
<p class="indent">The GIN index contains an entry for each lexeme and its location, allowing the database to find matches more quickly.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Another way to set up a column for search is to create an index on a text column using the <span class="literal">to_tsvector()</span> function. See</em> <a href="https://www.postgresql.org/docs/current/static/textsearch-tables.html">https://www.postgresql.org/docs/current/static/textsearch-tables.html</a> <em>for details</em>.</p>
</div>
<p class="indent">Now you’re ready to use search functions.</p>
<h4 class="h4" id="lev232"><em>Searching Speech Text</em></h4>
<p class="noindent">Thirty-two years’ worth of presidential speeches is fertile ground for exploring history. For example, the query in <a href="ch13.xhtml#ch13list21">Listing 13-21</a> lists the speeches in which the president mentioned Vietnam:</p>
<p class="programs">  SELECT president, speech_date<br/>  FROM president_speeches<br/><span class="ent">➊</span> WHERE search_speech_text @@ to_tsquery('Vietnam')<br/>  ORDER BY speech_date;</p>
<p class="listing" id="ch13list21"><em>Listing 13-21: Finding speeches containing the word</em> Vietnam</p>
<p class="indent">In the <span class="literal">WHERE</span> clause, the query uses the double at sign (<span class="literal">@@</span>) match operator <span class="ent">➊</span> between the <span class="literal">search_speech_text</span> column (of data type <span class="literal">tsvector</span>) and the query term <em>Vietnam</em>, which <span class="literal">to_tsquery()</span> transforms into <span class="literal">tsquery</span> data. The results should list 10 speeches, showing that the first mention of Vietnam came up in a 1961 special message to Congress by John F. Kennedy and became a recurring topic starting in 1966 as America’s involvement in the Vietnam War escalated.</p>
<p class="programs">president            speech_date<br/>-----------------    -----------<br/>John F. Kennedy      1961-05-25<br/>Lyndon B. Johnson    1966-01-12<br/>Lyndon B. Johnson    1967-01-10<br/>Lyndon B. Johnson    1968-01-17<br/>Lyndon B. Johnson    1969-01-14<br/>Richard M. Nixon     1970-01-22<br/>Richard M. Nixon     1972-01-20<br/>Richard M. Nixon     1973-02-02<br/>Gerald R. Ford       1975-01-15<br/>Gerald R. Ford       1977-01-12</p>
<p class="indent"><span epub:type="pagebreak" id="page_235"/>Before we try more searches, let’s add a method for showing the location of our search term in the text.</p>
<h5 class="h5">Showing Search Result Locations</h5>
<p class="noindent">To see where our search terms appear in text, we can use the <span class="literal">ts_headline()</span> function. It displays one or more highlighted search terms surrounded by adjacent words. Options for this function give you flexibility in how to format the display. <a href="ch13.xhtml#ch13list22">Listing 13-22</a> highlights how to display a search for a specific instance of <em>Vietnam</em> using <span class="literal">ts_headline()</span>:</p>
<p class="programs">SELECT president,<br/>       speech_date,<br/>     <span class="ent">➊</span> ts_headline(speech_text, to_tsquery('Vietnam'),<br/>                 <span class="ent">➋</span> 'StartSel = &lt;,<br/>                    StopSel = &gt;,<br/>                    MinWords=5,<br/>                    MaxWords=7,<br/>                    MaxFragments=1')<br/>FROM president_speeches<br/>WHERE search_speech_text @@ to_tsquery('Vietnam');</p>
<p class="listing" id="ch13list22"><em>Listing 13-22: Displaying search results with <span class="literal">ts_headline()</span></em></p>
<p class="indent">To declare <span class="literal">ts_headline()</span> <span class="ent">➊</span>, we pass the original <span class="literal">speech_text</span> column rather than the <span class="literal">tsvector</span> column we used in the search and relevance functions as the first argument. Then, as the second argument, we pass a <span class="literal">to_tsquery()</span> function that specifies the word to highlight. We follow this with a third argument that lists optional formatting parameters <span class="ent">➋</span> separated by commas. Here, we specify the characters to identify the start and end of the highlighted word (<span class="literal">StartSel</span> and <span class="literal">StopSel</span>). We also set the minimum and maximum number of words to display (<span class="literal">MinWords</span> and <span class="literal">MaxWords</span>), plus the maximum number of fragments to show using <span class="literal">MaxFragments</span>. These settings are optional, and you can adjust them according to your needs.</p>
<p class="indent">The results of this query should show at most seven words per speech, highlighting the word <em>Vietnam</em>:</p>
<div class="image"><img alt="image" src="../images/prog_page_235.jpg"/></div>
<p class="indent">Using this technique, we can quickly see the context of the term we searched. You might also use this function to provide flexible display options for a search feature on a web application. Let’s continue trying forms of searches.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_236"/>Using Multiple Search Terms</h5>
<p class="noindent">As another example, we could look for speeches in which a president mentioned the word <em>transportation</em> but didn’t discuss <em>roads</em>. We might want to do this to find speeches that focused on broader policy rather than a specific roads program. To do this, we use the syntax in <a href="ch13.xhtml#ch13list23">Listing 13-23</a>:</p>
<p class="programs">  SELECT president,<br/>       speech_date<br/>     <span class="ent">➊</span> ts_headline(speech_text, to_tsquery('transportation &amp; !roads'),<br/>                   'StartSel = &lt;,<br/>                    StopSel = &gt;,<br/>                    MinWords=5,<br/>                    MaxWords=7,<br/>                    MaxFragments=1')<br/>  FROM president_speeches<br/><span class="ent">➋</span> WHERE search_speech_text @@ to_tsquery('transportation &amp; !roads');</p>
<p class="listing" id="ch13list23"><em>Listing 13-23: Finding speeches with the word</em> transportation <em>but not</em> roads</p>
<p class="indent">Again, we use <span class="literal">ts_headline()</span> <span class="ent">➊</span> to highlight the terms our search finds. In the <span class="literal">to_tsquery()</span> function in the <span class="literal">WHERE</span> clause <span class="ent">➋</span>, we pass <span class="literal">transportation</span> and <span class="literal">roads</span>, combining them with the ampersand (<span class="literal">&amp;</span>) operator. We use the exclamation point (<span class="literal">!</span>) in front of <span class="literal">roads</span> to indicate that we want speeches that do not contain this word. This query should find eight speeches that fit the criteria. Here are the first four rows:</p>
<div class="image"><img alt="image" src="../images/prog_page_236.jpg"/></div>
<p class="indent">Notice that the highlighted words in the <span class="literal">ts_headline</span> column include <span class="literal">transportation</span> and <span class="literal">transport</span>. The reason is that the <span class="literal">to_tsquery()</span> function converted <span class="literal">transportation</span> to the lexeme <span class="literal">transport</span> for the search term. This database behavior is extremely useful in helping to find relevant related words.</p>
<h5 class="h5">Searching for Adjacent Words</h5>
<p class="noindent">Finally, we’ll use the distance (<span class="literal">&lt;-&gt;</span>) operator, which consists of a hyphen between the less than and greater than signs, to find adjacent words. Alternatively, you can place a number between the signs to find terms that many words apart. For example, <a href="ch13.xhtml#ch13list24">Listing 13-24</a> searches for any speeches that include the word <em>military</em> immediately followed by <em>defense</em>:</p>
<p class="programs">SELECT president,<br/>       speech_date,<br/><span epub:type="pagebreak" id="page_237"/>       ts_headline(speech_text, to_tsquery('military &lt;-&gt; defense'),<br/>                   'StartSel = &lt;,<br/>                    StopSel = &gt;,<br/>                    MinWords=5,<br/>                    MaxWords=7,<br/>                    MaxFragments=1')<br/>FROM president_speeches<br/>WHERE search_speech_text @@ to_tsquery('military &lt;-&gt; defense');</p>
<p class="listing" id="ch13list24"><em>Listing 13-24: Finding speeches where</em> defense <em>follows</em> military</p>
<p class="indent">This query should find four speeches, and because <span class="literal">to_tsquery()</span> converts the search terms to lexemes, the words identified in the speeches should include plurals, such as <em>military defenses</em>. The following shows the four speeches that have the adjacent terms:</p>
<div class="image"><img alt="image" src="../images/prog_page_237.jpg"/></div>
<p class="indent">If you changed the query terms to <span class="literal">military &lt;2&gt; defense</span>, the database would return matches where the terms are exactly two words apart, as in the phrase “our military and defense commitments.”</p>
<h4 class="h4" id="lev233"><em>Ranking Query Matches by Relevance</em></h4>
<p class="noindent">You can also rank search results by relevance using two of PostgreSQL’s full text search functions. These functions are helpful when you’re trying to understand which piece of text, or speech in this case, is most relevant to your particular search terms.</p>
<p class="indent">One function, <span class="literal">ts_rank()</span>, generates a rank value (returned as a variable-precision <span class="literal">real</span> data type) based on how often the lexemes you’re searching for appear in the text. The other function, <span class="literal">ts_rank_cd()</span>, considers how close the lexemes searched are to each other. Both functions can take optional arguments to take into account document length and other factors. The rank value they generate is an arbitrary decimal that’s useful for sorting but doesn’t have any inherent meaning. For example, a value of <span class="literal">0.375</span> generated during one query isn’t directly comparable to the same value generated during a different query.</p>
<p class="indent">As an example, <a href="ch13.xhtml#ch13list25">Listing 13-25</a> uses <span class="literal">ts_rank()</span> to rank speeches containing all the words <em>war</em>, <em>security</em>, <em>threat</em>, and <em>enemy</em>:</p>
<p class="programs">  SELECT president,<br/>         speech_date,<br/>       <span class="ent">➊</span> ts_rank(search_speech_text,<br/>                 to_tsquery('war &amp; security &amp; threat &amp; enemy')) AS score<br/><span epub:type="pagebreak" id="page_238"/>  FROM president_speeches<br/><span class="ent">➋</span> WHERE search_speech_text @@ to_tsquery('war &amp; security &amp; threat &amp; enemy')<br/>  ORDER BY score DESC/<br/>  LIMIT 5</p>
<p class="listing" id="ch13list25"><em>Listing 13-25: Scoring relevance with <span class="literal">ts_rank()</span></em></p>
<p class="indent">In this query, the <span class="literal">ts_rank()</span> function <span class="ent">➊</span> takes two arguments: the <span class="literal">search_speech_text</span> column and the output of a <span class="literal">to_tsquery()</span> function containing the search terms. The output of the function receives the alias <span class="literal">score</span>. In the <span class="literal">WHERE</span> clause <span class="ent">➋</span> we filter the results to only those speeches that contain the search terms specified. Then we order the results in <span class="literal">score</span> in descending order and return just five of the highest-ranking speeches. The results should be as follows:</p>
<p class="programs">president               speech_date    score<br/>--------------------    -----------    ---------<br/>Harry S. Truman         1946-01-21      0.257522<br/>Lyndon B. Johnson       1968-01-17      0.186296<br/>Dwight D. Eisenhower    1957-01-10      0.140851<br/>Harry S. Truman         1952-01-09     0.0982469<br/>Richard M. Nixon        1972-01-20     0.0973585</p>
<p class="indent">Harry S. Truman’s 1946 State of the Union message, just four months after the end of World War II, contains the words <em>war</em>, <em>security</em>, <em>threat</em>, and <em>enemy</em> more often than the other speeches. However, it also happens to be the longest speech in the table (which you can determine by using <span class="literal">char_length()</span>, as you learned earlier in the chapter). The length of the speeches influences these rankings because <span class="literal">ts_rank()</span> factors in the number of matching terms in a given text. Lyndon B. Johnson’s 1968 State of the Union address, delivered at the height of the Vietnam War, comes in second.</p>
<p class="indent">It would be ideal to compare frequencies between speeches of identical lengths to get a more accurate ranking, but this isn’t always possible. However, we can factor in the length of each speech by adding a normalization code as a third parameter of the <span class="literal">ts_rank()</span> function, as shown in <a href="ch13.xhtml#ch13list26">Listing 13-26</a>:</p>
<p class="programs">SELECT president,<br/>       speech_date,<br/>       ts_rank(search_speech_text,<br/>               to_tsquery('war &amp; security &amp; threat &amp; enemy'), 2<span class="ent">➊</span>)::numeric<br/>               AS score<br/>FROM president_speeches<br/>WHERE search_speech_text @@ to_tsquery('war &amp; security &amp; threat &amp; enemy')<br/>ORDER BY score DESC<br/>LIMIT 5;</p>
<p class="listing" id="ch13list26"><em>Listing 13-26: Normalizing <span class="literal">ts_rank()</span> by speech length</em></p>
<p class="indent">Adding the optional code <span class="literal">2</span> <span class="ent">➊</span> instructs the function to divide the <span class="literal">score</span> by the length of the data in the <span class="literal">search_speech_text</span> column. This quotient then <span epub:type="pagebreak" id="page_239"/>represents a score normalized by the document length, giving an apples-to-apples comparison among the speeches. The PostgreSQL documentation at <em><a href="https://www.postgresql.org/docs/current/static/textsearch-controls.html">https://www.postgresql.org/docs/current/static/textsearch-controls.html</a></em> lists all the options available for text search, including using the document length and dividing by the number of unique words.</p>
<p class="indent">After running the code in <a href="ch13.xhtml#ch13list26">Listing 13-26</a>, the rankings should change:</p>
<p class="programs">president               speech_date    score<br/>--------------------    -----------    ------------<br/>Lyndon B. Johnson       1968-01-17     0.0000728288<br/>Dwight D. Eisenhower    1957-01-10     0.0000633609<br/>Richard M. Nixon        1972-01-20     0.0000497998<br/>Harry S. Truman         1952-01-09     0.0000365366<br/>Dwight D. Eisenhower    1958-01-09     0.0000355315</p>
<p class="indent">In contrast to the ranking results in <a href="ch13.xhtml#ch13list25">Listing 13-25</a>, Johnson’s 1968 speech now tops the rankings, and Truman’s 1946 message falls out of the top five. This might be a more meaningful ranking than the first sample output, because we normalized it by length. But four of the five top-ranked speeches are the same between the two sets, and you can be reasonably certain that each of these four is worthy of closer examination to understand more about wartime presidential speeches.</p>
<h3 class="h3" id="lev234">Wrapping Up</h3>
<p class="noindent">Far from being boring, text offers abundant opportunities for data analysis. In this chapter, you’ve learned valuable techniques for turning ordinary text into data you can extract, quantify, search, and rank. In your work or studies, keep an eye out for routine reports that have facts buried inside chunks of text. You can use regular expressions to dig them out, turn them into structured data, and analyze them to find trends. You can also use search functions to analyze the text.</p>
<p class="indent">In the next chapter, you’ll learn how PostgreSQL can help you analyze geographic information.</p>
<div class="sidebar" id="ch13sb1">
<p class="sidebart"><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Use your new text-wrangling skills to tackle these tasks:</p>
<ol>
<li class="noindent"><p class="list">The style guide of a publishing company you’re writing for wants you to avoid commas before suffixes in names. But there are several names like <span class="literal">Alvarez, Jr.</span> and <span class="literal">Williams, Sr.</span> in your database. Which functions can you use to remove the comma? Would a regular expression function help? How would you capture just the suffixes to place them into a separate column?</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_240"/>Using any one of the State of the Union addresses, count the number of unique words that are five characters or more. (Hint: You can use <span class="literal">regexp</span><span class="literal">_split</span><span class="literal">_to_table()</span> in a subquery to create a table of words to count.) Bonus: Remove commas and periods at the end of each word.</p></li>
<li class="noindent"><p class="list">Rewrite the query in <a href="ch13.xhtml#ch13list25">Listing 13-25</a> using the <span class="literal">ts_rank_cd()</span> function instead of <span class="literal">ts_rank()</span>. According to the PostgreSQL documentation, <span class="literal">ts_rank_cd()</span> computes cover density, which takes into account how close the lexeme search terms are to each other. Does using the <span class="literal">ts_rank_cd()</span> function significantly change the results?</p></li>
</ol>
</div>
</body>
</html>