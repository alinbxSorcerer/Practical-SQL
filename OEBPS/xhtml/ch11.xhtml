<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
<head>
<title>Practical SQL: A Beginner’s Guide to Storytelling with Data</title>
<link href="../styles/9781593278458.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c3d53d4c-356a-4b39-bef0-591c04016b72" name="Adept.expected.resource"/>
</head>
<body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_171"/><strong><span class="big">11</span></strong><br/><strong>WORKING WITH DATES AND TIMES</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">Columns filled with dates and times can indicate <em>when</em> events happened or <em>how long</em> they took, and that can lead to interesting lines of inquiry. What patterns exist in the moments on a timeline? Which events were shortest or longest? What relationships exist between a particular activity and the time of day or season in which it occurred?</p>
<p class="indent">In this chapter, we’ll explore these kinds of questions using SQL data types for dates and times and their related functions. We’ll start with a closer look at data types and functions related to dates and times. Then we’ll explore a data set that contains information on trips by New York City taxicabs to look for patterns and try to discover what, if any, story the data tells. We’ll also explore time zones using Amtrak data to calculate the duration of train trips across the United States.</p>
<h3 class="h3" id="lev168"><span epub:type="pagebreak" id="page_172"/>Data Types and Functions for Dates and Times</h3>
<p class="noindent"><a href="ch03.xhtml#ch03">Chapter 3</a> explored primary SQL data types, but to review, here are the four data types related to dates and times:</p>
<p class="hang"><span class="codestrong">date</span> Records only the date. PostgreSQL accepts several date formats. For example, valid formats for adding the 21st day of September 2018 are <span class="literal">September 21, 2018</span> or <span class="literal">9/21/2018</span>. I recommend using <span class="codeitalic">YYYY-MM-DD</span> (or <span class="literal">2018-09-21</span>), which is the ISO 8601 international standard format and also the default PostgreSQL date output. Using the ISO format helps avoid confusion when sharing data internationally.</p>
<p class="hang"><span class="codestrong">time</span> Records only the time. Adding <span class="literal">with time zone</span> makes the column time zone aware. The ISO 8601 format is <span class="codeitalic">HH:MM:SS</span>, where <span class="codeitalic">HH</span> represents the hour, <span class="codeitalic">MM</span> the minutes, and <span class="codeitalic">SS</span> the seconds. You can add an optional time zone designator. For example, 2:24 <small>PM</small> in San Francisco during standard time in fall and winter would be <span class="literal">14:24 PST</span>.</p>
<p class="hang"><span class="literal"><strong>timestamp</strong></span> Records the date and time. You can add <span class="literal">with time zone</span> to make the column time zone aware. The format <span class="literal">timestamp with time zone</span> is part of the SQL standard, but with PostgreSQL, you can use the shorthand <span class="literal">timestamptz</span>, which combines the date and time formats plus a time zone designator at the end: <span class="codeitalic">YYYY-MM-DD HH:MM:SS TZ</span>. You can specify time zones in three different formats: its UTC offset, an area/location designator, or a standard abbreviation.</p>
<p class="hang"><span class="codestrong">interval</span> Holds a value that represents a unit of time expressed in the format <span class="codeitalic">quantity unit</span>. It doesn’t record the start or end of a period, only its duration. Examples include <span class="literal">12 days</span> or <span class="literal">8 hours</span>.</p>
<p class="indentt">The first three data types, <span class="literal">date</span>, <span class="literal">time</span>, and <span class="literal">timestamp</span>, are known as <em>datetime types</em> whose values are called <em>datetimes</em>. The <span class="literal">interval</span> value is an <em>interval type</em> whose values are <em>intervals</em>. All four data types can track the system clock and the nuances of the calendar. For example, <span class="literal">date</span> and <span class="literal">timestamp</span> recognize that June has 30 days. Therefore, June 31 is an invalid datetime value that causes the database to throw an error. Likewise, the date February 29 is valid only in a leap year, such as 2020.</p>
<h3 class="h3" id="lev169">Manipulating Dates and Times</h3>
<p class="noindent">We can use SQL functions to perform calculations on dates and times or extract components from them. For example, we can retrieve the day of the week from a timestamp or extract just the month from a date. ANSI SQL outlines a handful of functions to do this, but many database managers (including MySQL and Microsoft SQL Server) deviate from the standard to implement their own date and time data types, syntax, and function names. If you’re using a database other than PostgreSQL, check its documentation.</p>
<p class="indent">Let’s review how to manipulate dates and times using PostgreSQL functions.</p>
<h4 class="h4" id="lev170"><span epub:type="pagebreak" id="page_173"/><em>Extracting the Components of a timestamp Value</em></h4>
<p class="noindent">It’s not unusual to need just one piece of a date or time value for analysis, particularly when you’re aggregating results by month, year, or even minute. We can extract these components using the PostgreSQL <span class="literal">date_part()</span> function. Its format looks like this:</p>
<p class="programs">date_part(<em>text</em>, <em>value</em>)</p>
<p class="indent">The function takes two inputs. The first is a string in <span class="literal">text</span> format that represents the part of the date or time to extract, such as <span class="literal">hour</span>, <span class="literal">minute</span>, or <span class="literal">week</span>. The second is the <span class="literal">date</span>, <span class="literal">time</span>, or <span class="literal">timestamp</span> value. To see the <span class="literal">date_part()</span> function in action, we’ll execute it multiple times on the same value using the code in <a href="ch11.xhtml#ch11list1">Listing 11-1</a>. In the listing, we format the string as a <span class="literal">timestamp with time zone</span> using the PostgreSQL-specific shorthand <span class="literal">timestamptz</span>. We also assign a column name to each with <span class="literal">AS</span>.</p>
<p class="programs">SELECT <br/>    date_part('year', '2019-12-01 18:37:12 EST'::timestamptz) AS "year",<br/>    date_part('month', '2019-12-01 18:37:12 EST'::timestamptz) AS "month",<br/>    date_part('day', '2019-12-01 18:37:12 EST'::timestamptz) AS "day",<br/>    date_part('hour', '2019-12-01 18:37:12 EST'::timestamptz) AS "hour",<br/>    date_part('minute', '2019-12-01 18:37:12 EST'::timestamptz) AS "minute",<br/>    date_part('seconds', '2019-12-01 18:37:12 EST'::timestamptz) AS "seconds",<br/>    date_part('timezone_hour', '2019-12-01 18:37:12 EST'::timestamptz) AS "tz",<br/>    date_part('week', '2019-12-01 18:37:12 EST'::timestamptz) AS "week",<br/>    date_part('quarter', '2019-12-01 18:37:12 EST'::timestamptz) AS "quarter",<br/>    date_part('epoch', '2019-12-01 18:37:12 EST'::timestamptz) AS "epoch";</p>
<p class="listing" id="ch11list1"><em>Listing 11-1: Extracting components of a <span class="literal">timestamp</span> value using <span class="literal">date_part()</span></em></p>
<p class="indent">Each column statement in this <span class="literal">SELECT</span> query first uses a string to name the component we want to extract: <span class="literal">year</span>, <span class="literal">month</span>, <span class="literal">day</span>, and so on. The second input uses the string <span class="literal">2019-12-01 18:37:12 EST</span> cast as a <span class="literal">timestamp with time zone</span> with the PostgreSQL double-colon syntax and the <span class="literal">timestamptz</span> shorthand. In December, the United States is observing standard time, which is why we can designate the Eastern time zone using the Eastern Standard Time (EST) designation.</p>
<p class="indent">Here’s the output as shown on my computer, which is located in the U.S. Eastern time zone. (The database converts the values to reflect your PostgreSQL time zone setting, so your output might be different; for example, if it’s set to the U.S. Pacific time zone, the hour will show as <span class="literal">15</span>):</p>
<div class="image"><img alt="image" src="../images/prog_page_173.jpg"/></div>
<p class="indent">Each column contains a single value that represents 6:37:12 <small>PM</small> on December 1, 2019, in the U.S. Eastern time zone. Even though you designated the time zone using <span class="literal">EST</span> in the string, PostgreSQL reports back the <em>UTC offset</em> of that time zone, which is the number of hours plus or minus <span epub:type="pagebreak" id="page_174"/>from UTC. UTC refers to Coordinated Universal Time, a world time standard, as well as the value of UTC +/−00:00, the time zone that covers the United Kingdom and Western Africa. Here, the UTC offset is <span class="literal">-5</span> (because <span class="literal">EST</span> is five hours behind UTC).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You can derive the UTC offset from the time zone but not vice versa. Each UTC offset can refer to multiple named time zones plus standard and daylight saving time variants.</em></p>
</div>
<p class="indent">The first seven values are easy to recognize from the original timestamp, but the last three are calculated values that deserve an explanation.</p>
<p class="indent">The <span class="literal">week</span> column shows that December 1, 2019, falls in the 48th week of the year. This number is determined by ISO 8601 standards, which start each week on a Monday. That means a week at the end of a year can extend from December into January of the following year.</p>
<p class="indent">The <span class="literal">quarter</span> column shows that our test date is part of the fourth quarter of the year. The <span class="literal">epoch</span> column shows a measurement, which is used in computer systems and programming languages, that represents the number of seconds elapsed before or after 12 <small>AM</small>, January 1, 1970, at UTC 0. A positive value designates a time since that point; a negative value designates a time before it. In this example, 1,575,243,432 seconds elapsed between January 1, 1970, and the timestamp. Epoch is useful if you need to compare two timestamps mathematically on an absolute scale.</p>
<p class="indent">PostgreSQL also supports the SQL-standard <span class="literal">extract()</span> function, which parses datetimes in the same way as the <span class="literal">date_part()</span> function. I’ve featured <span class="literal">date_part()</span> here instead for two reasons. First, its name helpfully reminds us what it does. Second, <span class="literal">extract()</span> isn’t widely supported by database managers. Most notably, it’s absent in Microsoft’s SQL Server. Nevertheless, if you need to use <span class="literal">extract()</span>, the syntax takes this form:</p>
<p class="programs">extract(<em>text</em> from <em>value</em>)</p>
<p class="indent">To replicate the first <span class="literal">date_part()</span> example in <a href="ch11.xhtml#ch11list1">Listing 11-1</a> where we pull the year from the timestamp, we’d set up the function like this:</p>
<p class="programs">extract('year' from '2019-12-01 18:37:12 EST'::timestamptz)</p>
<p class="indent">PostgreSQL provides additional components you can extract or calculate from dates and times. For the full list of functions, see the documentation at <em><a href="https://www.postgresql.org/docs/current/static/functions-datetime.html">https://www.postgresql.org/docs/current/static/functions-datetime.html</a></em>.</p>
<h4 class="h4" id="lev171"><em>Creating Datetime Values from timestamp Components</em></h4>
<p class="noindent">It’s not unusual to come across a data set in which the year, month, and day exist in separate columns, and you might want to create a datetime value from these components. To perform calculations on a date, it’s helpful to combine and format those pieces correctly into one column.</p>
<p class="indent"><span epub:type="pagebreak" id="page_175"/>You can use the following PostgreSQL functions to make datetime objects:</p>
<p class="hang"><strong><span class="literal">make_date(<em>year</em>, <em>month</em>, <em>day</em>)</span></strong> Returns a value of type <span class="literal">date</span></p>
<p class="hang"><strong><span class="literal">make_time(<em>hour</em>, <em>minute</em>, <em>seconds</em>)</span></strong> Returns a value of type <span class="literal">time without time zone</span></p>
<p class="hang"><strong><span class="literal">make_timestamptz(<em>year</em>, <em>month</em>, <em>day</em>, <em>hour</em>, <em>minute</em>, <em>second</em>, <em>time zone</em>)</span></strong> Returns a <span class="literal">timestamp with time zone</span></p>
<p class="indentt">The variables for these three functions take <span class="literal">integer</span> types as input, with two exceptions: seconds are of the type <span class="literal">double precision</span> because you can supply fractions of seconds, and time zones must be specified with a <span class="literal">text</span> string that names the time zone.</p>
<p class="indent"><a href="ch11.xhtml#ch11list2">Listing 11-2</a> shows examples of the three functions in action using components of February 22, 2018, for the date, and 6:04:30.3 <small>PM</small> in Lisbon, Portugal for the time:</p>
<p class="programs">SELECT make_date(2018, 2, 22);<br/>SELECT make_time(18, 4, 30.3);<br/>SELECT make_timestamptz(2018, 2, 22, 18, 4, 30.3, 'Europe/Lisbon');</p>
<p class="listing" id="ch11list2"><em>Listing 11-2: Three functions for making datetimes from components</em></p>
<p class="indent">When I run each query in order, the output on my computer in the U.S. Eastern time zone is as follows. Again, yours may differ depending on your time zone setting:</p>
<p class="programs">2018-02-22<br/>18:04:30.3<br/>2018-02-22 13:04:30.3-05</p>
<p class="indent">Notice that the timestamp in the third line shows <span class="literal">13:04:30.3</span>, which is Eastern Standard Time and is five hours behind (<span class="literal">-05</span>) the time input to the function: <span class="literal">18:04:30.3</span>. In our discussion on time zone–enabled columns in <a href="ch03.xhtml#lev41">“Dates and Times”</a> on <a href="ch03.xhtml#page_32">page 32</a>, I noted that PostgreSQL displays times relative to the client’s time zone or the time zone set in the database session. This output reflects the appropriate time because my location is five hours behind Lisbon. We’ll explore working with time zones in more detail, and you’ll learn to adjust its display in <a href="ch11.xhtml#lev173">“Working with Time Zones”</a> on <a href="ch11.xhtml#page_177">page 177</a>.</p>
<h4 class="h4" id="lev172"><em>Retrieving the Current Date and Time</em></h4>
<p class="noindent">If you need to record the current date or time as part of a query—when updating a row, for example—standard SQL provides functions for that too. The following functions record the time as of the start of the query:</p>
<p class="hang"><span class="codestrong">current_date</span> Returns the date.</p>
<p class="hang"><span class="codestrong">current_time</span> Returns the current time with time zone.</p>
<p class="hang"><span epub:type="pagebreak" id="page_176"/><span class="codestrong">current_timestamp</span> Returns the current timestamp with time zone. A shorthand PostgreSQL-specific version is <span class="literal">now()</span>.</p>
<p class="hang"><span class="codestrong">localtime</span> Returns the current time without time zone.</p>
<p class="hang"><span class="codestrong">localtimestamp</span> Returns the current timestamp without time zone.</p>
<p class="indentt">Because these functions record the time at the start of the query (or a collection of queries grouped under a <em>transaction</em>, which I covered in <a href="ch09.xhtml#ch09">Chapter 9</a>), they’ll provide that same time throughout the execution of a query regardless of how long the query runs. So, if your query updates 100,000 rows and takes 15 seconds to run, any timestamp recorded at the start of the query will be applied to each row, and so each row will receive the same timestamp.</p>
<p class="indent">If, instead, you want the date and time to reflect how the clock changes during the execution of the query, you can use the PostgreSQL-specific <span class="literal">clock_timestamp()</span> function to record the current time as it elapses. That way, if you’re updating 100,000 rows and inserting a timestamp each time, each row gets the time the row updated rather than the time at the start of the query. Note that <span class="literal">clock_timestamp()</span> can slow large queries and may be subject to system limitations.</p>
<p class="indent"><a href="ch11.xhtml#ch11list3">Listing 11-3</a> shows <span class="literal">current_timestamp</span> and <span class="literal">clock_timestamp()</span> in action when inserting a row in a table:</p>
<p class="programs">CREATE TABLE current_time_example (<br/>    time_id bigserial,<br/>  <span class="ent">➊</span> current_timestamp_col timestamp with time zone,<br/>  <span class="ent">➋</span> clock_timestamp_col timestamp with time zone<br/>);<br/><br/>INSERT INTO current_time_example (current_timestamp_col, clock_timestamp_col)<br/>  <span class="ent">➌</span> (SELECT current_timestamp,<br/>            clock_timestamp()<br/>     FROM generate_series(1,1000));<br/><br/>SELECT * FROM current_time_example;</p>
<p class="listing" id="ch11list3"><em>Listing 11-3: Comparing <span class="literal">current_timestamp</span> and <span class="literal">clock_timestamp()</span> during row insert</em></p>
<p class="indent">The code creates a table that includes two <span class="literal">timestamp</span> columns with a time zone. The first holds the result of the <span class="literal">current_timestamp</span> function <span class="ent">➊</span>, which records the time at the start of the <span class="literal">INSERT</span> statement that adds 1,000 rows to the table. To do that, we use the <span class="literal">generate_series()</span> function, which returns a set of integers starting with 1 and ending with 1,000. The second column holds the result of the <span class="literal">clock_timestamp()</span> function <span class="ent">➋</span>, which records the time of insertion of each row. You call both functions as part of the <span class="literal">INSERT</span> statement <span class="ent">➌</span>. Run the query, and the result from the final <span class="literal">SELECT</span> statement should show that the time in the <span class="literal">current_timestamp_col</span> is the same for all rows, whereas the time in <span class="literal">clock_timestamp_col</span> increases with each row inserted.</p>
<h3 class="h3" id="lev173"><span epub:type="pagebreak" id="page_177"/>Working with Time Zones</h3>
<p class="noindent">Time zone data lets the dates and times in your database reflect the location around the globe where those dates and times apply and their UTC offset. A timestamp of 1 <small>PM</small> is only useful, for example, if you know whether the value refers to local time in Asia, Eastern Europe, one of the 12 time zones of Antarctica, or anywhere else on the globe.</p>
<p class="indent">Of course, very often you’ll receive data sets that contain no time zone data in their datetime columns. This isn’t always a deal breaker in terms of whether or not you should continue to use the data. If you know that every event in the data happened in the same location, having the time zone in the timestamp is less critical, and it’s relatively easy to modify all the timestamps of your data to reflect that single time zone.</p>
<p class="indent">Let’s look at some strategies for working with time zones in your data.</p>
<h4 class="h4" id="lev174"><em>Finding Your Time Zone Setting</em></h4>
<p class="noindent">When working with time zones in SQL, you first need know the time zone setting for your database server. If you installed PostgreSQL on your own computer, the default will be your local time zone. If you’re connecting to a PostgreSQL database elsewhere, perhaps on a network or a cloud provider such as Amazon Web Services, the time zone setting may be different than your own. To help avoid confusion, database administrators often set a shared server’s time zone to UTC.</p>
<p class="indent">To find out the default time zone of your PostgreSQL server, use the <span class="literal">SHOW</span> command with <span class="literal">timezone</span>, as shown in <a href="ch11.xhtml#ch11list4">Listing 11-4</a>:</p>
<p class="programs">SHOW timezone;</p>
<p class="listing" id="ch11list4"><em>Listing 11-4: Showing your PostgreSQL server’s default time zone</em></p>
<p class="indent">Entering <a href="ch11.xhtml#ch11list4">Listing 11-4</a> into pgAdmin and running it on my computer returns <span class="literal">US/Eastern</span>, one of several location names that falls into the Eastern time zone, which encompasses eastern Canada and the United States, the Caribbean, and parts of Mexico.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You can use <span class="literal">SHOW ALL;</span> to see the settings of every parameter on your PostgreSQL server.</em></p>
</div>
<p class="indent">You can also use the two commands in <a href="ch11.xhtml#ch11list5">Listing 11-5</a> to list all time zone names, abbreviations, and their UTC offsets:</p>
<p class="programs">SELECT * FROM pg_timezone_abbrevs;<br/>SELECT * FROM pg_timezone_names;</p>
<p class="listing" id="ch11list5"><em>Listing 11-5: Showing time zone abbreviations and names</em></p>
<p class="indent">You can easily filter either of these <span class="literal">SELECT</span> statements with a <span class="literal">WHERE</span> clause to look up specific location names or time zones:</p>
<p class="programs">SELECT * FROM pg_timezone_names<br/>WHERE name LIKE 'Europe%';</p>
<p class="indent"><span epub:type="pagebreak" id="page_178"/>This code should return a table listing that includes the time zone name, abbreviation, UTC offset, and a <span class="literal">boolean</span> column <span class="literal">is_dst</span> that notes whether the time zone is currently observing daylight saving time:</p>
<p class="programs">name                abbrev    utc_offset    is_dst<br/>----------------    ------    ----------    ------<br/>Europe/Amsterdam    CEST      02:00:00      t<br/>Europe/Andorra      CEST      02:00:00      t<br/>Europe/Astrakhan    +04       04:00:00      f<br/>Europe/Athens       EEST      03:00:00      t<br/>Europe/Belfast      BST       01:00:00      t<br/><em>--snip--</em></p>
<p class="indent">This is a faster way of looking up time zones than using Wikipedia. Now let’s look at how to set the time zone to a particular value.</p>
<h4 class="h4" id="lev175"><em>Setting the Time Zone</em></h4>
<p class="noindent">When you installed PostgreSQL, the server’s default time zone was set as a parameter in <em>postgresql.conf</em>, a file that contains dozens of values read by PostgreSQL each time it starts. The location of <em>postgresql.conf</em> in your file system varies depending on your operating system and sometimes on the way you installed PostgreSQL. To make permanent changes to <em>postgresql.conf</em>, you need to edit the file and restart the server, which might be impossible if you’re not the owner of the machine. Changes to configurations might also have unintended consequences for other users or applications.</p>
<p class="indent">I’ll cover working with <em>postgresql.conf</em> in more depth in <a href="ch17.xhtml#ch17">Chapter 17</a>. However, for now you can easily set the pgAdmin client’s time zone on a per-session basis, and the change should last as long as you’re connected to the server. This solution is handy when you want to specify how you view a particular table or handle timestamps in a query.</p>
<p class="indent">To set and change the pgAdmin client’s time zone, we use the command <span class="literal">SET timezone TO</span>, as shown in <a href="ch11.xhtml#ch11list6">Listing 11-6</a>:</p>
<p class="programs"><span class="ent">➊</span> SET timezone TO 'US/Pacific';<br/><br/><span class="ent">➋</span> CREATE TABLE time_zone_test (<br/>      test_date timestamp with time zone<br/>  );<br/><span class="ent">➌</span> INSERT INTO time_zone_test VALUES ('2020-01-01 4:00');<br/><br/><span class="ent">➍</span> SELECT test_date<br/>  FROM time_zone_test;<br/><br/><span class="ent">➎</span> SET timezone TO 'US/Eastern';<br/><br/><span class="ent">➏</span> SELECT test_date<br/>  FROM time_zone_test;<br/><br/><span epub:type="pagebreak" id="page_179"/><span class="ent">➐</span> SELECT test_date AT TIME ZONE 'Asia/Seoul'<br/>  FROM time_zone_test;</p>
<p class="listing" id="ch11list6"><em>Listing 11-6: Setting the time zone for a client session</em></p>
<p class="indent">First, we set the time zone to <span class="literal">US/Pacific</span> <span class="ent">➊</span>, which designates the Pacific time zone that covers western Canada and the United States along with Baja California in Mexico. Second, we create a one-column table <span class="ent">➋</span> with a data type of <span class="literal">timestamp with time zone</span> and insert a single row to display a test result. Notice that the value inserted, <span class="literal">2020-01-01 4:00</span>, is a timestamp with no time zone <span class="ent">➌</span>. You’ll encounter timestamps with no time zone quite often, particularly when you acquire data sets restricted to a specific location.</p>
<p class="indent">When executed, the first <span class="literal">SELECT</span> statement <span class="ent">➍</span> returns <span class="literal">2020-01-01 4:00</span> as a timestamp that now contains time zone data:</p>
<p class="programs">test_date<br/>----------------------<br/>2020-01-01 04:00:00-08</p>
<p class="indent">Recall from our discussion on data types in <a href="ch03.xhtml#ch03">Chapter 3</a> that the <span class="literal">-08</span> at the end of this timestamp is the UTC offset. In this case, the <span class="literal">-08</span> shows that the Pacific time zone is eight hours behind UTC. Because we initially set the pgAdmin client’s time zone to <span class="literal">US/Pacific</span> for this session, any value we now enter into a column that is time zone aware will be in Pacific time and coded accordingly. However, it’s worth noting that on the server, the <span class="literal">timestamp</span> <span class="literal">with time zone</span> data type always stores data as UTC internally; the time zone setting governs how it’s displayed.</p>
<p class="indent">Now comes some fun. We change the time zone for this session to the Eastern time zone using the <span class="literal">SET</span> command <span class="ent">➎</span> and the <span class="literal">US/Eastern</span> designation. Then, when we execute the <span class="literal">SELECT</span> statement <span class="ent">➏</span> again, the result should be as follows:</p>
<p class="programs">test_date<br/>----------------------<br/>2020-01-01 07:00:00-05</p>
<p class="indent">In this example, two components of the timestamp have changed: the time is now <span class="literal">07:00</span>, and the UTC offset is <span class="literal">-05</span> because we’re viewing the timestamp from the perspective of the Eastern time zone: 4 <small>AM</small> Pacific is 7 <small>AM</small> Eastern. The original Pacific time value remains unaltered in the table, and the database converts it to show the time in whatever time zone we set at <span class="ent">➎</span>.</p>
<p class="indent">Even more convenient is that we can view a timestamp through the lens of any time zone without changing the session setting. The final <span class="literal">SELECT</span> statement uses the <span class="literal">AT TIME ZONE</span> keywords <span class="ent">➐</span> to display the timestamp in our session as Korea standard time (KST) by specifying <span class="literal">Asia/Seoul</span>:</p>
<p class="programs">timezone<br/>-------------------<br/>2020-01-01 21:00:00</p>
<p class="indent"><span epub:type="pagebreak" id="page_180"/>Now we know that the database value of 4 <small>AM</small> in <span class="literal">US/Pacific</span> on January 1, 2020, is equivalent to 9 <small>PM</small> that same day in <span class="literal">Asia/Seoul</span>. Again, this syntax changes the output data type, but the data on the server remains unchanged. If the original value is a <span class="literal">timestamp with time zone</span>, the output removes the time zone. If the original value has no time zone, the output is <span class="literal">timestamp with time zone</span>.</p>
<p class="indent">The ability of databases to track time zones is extremely important for accurate calculations of intervals, as you’ll see next.</p>
<h3 class="h3" id="lev176">Calculations with Dates and Times</h3>
<p class="noindent">We can perform simple arithmetic on datetime and interval types the same way we can on numbers. Addition, subtraction, multiplication, and division are all possible in PostgreSQL using the math operators <span class="literal">+</span>, <span class="literal">-</span>, <span class="literal">*</span>, and <span class="literal">/</span>. For example, you can subtract one date from another date to get an integer that represents the difference in days between the two dates. The following code returns an integer of <span class="literal">3</span>:</p>
<p class="programs">SELECT '9/30/1929'::date - '9/27/1929'::date;</p>
<p class="indent">The result indicates that these two dates are exactly three days apart.</p>
<p class="indent">Likewise, you can use the following code to add a time interval to a date to return a new date:</p>
<p class="programs">SELECT '9/30/1929'::date + '5 years'::interval;</p>
<p class="indent">This code adds five years to the date <span class="literal">9/30/1929</span> to return a timestamp value of <span class="literal">9/30/1934</span>.</p>
<p class="indent">You can find more examples of math functions you can use with dates and times in the PostgreSQL documentation at <em><a href="https://www.postgresql.org/docs/current/static/functions-datetime.html">https://www.postgresql.org/docs/current/static/functions-datetime.html</a></em>. Let’s explore some more practical examples using actual transportation data.</p>
<h4 class="h4" id="lev177"><em>Finding Patterns in New York City Taxi Data</em></h4>
<p class="noindent">When I visit New York City, I usually take at least one ride in one of the 13,500 iconic yellow cars that ferry hundreds of thousands of people across the city’s five boroughs each day. The New York City Taxi and Limousine Commission releases data on monthly yellow taxi trips plus other for-hire vehicles. We’ll use this large, rich data set to put date functions to practical use.</p>
<p class="indent">The <em>yellow_tripdata_2016_06_01.csv</em> file available from the book’s resources (at <em><a href="https://www.nostarch.com/practicalSQL/">https://www.nostarch.com/practicalSQL/</a></em>) holds one day of yellow taxi trip records from June 1, 2016. Save the file to your computer and execute the code in <a href="ch11.xhtml#ch11list7">Listing 11-7</a> to build the <span class="literal">nyc_</span><span class="literal">yello</span><span class="literal">w_taxi_trips_2016_06_01</span> table. Remember to change the file path in the <span class="literal">COPY</span> command to the location where you’ve saved the file and adjust the path format to reflect whether you’re using Windows, macOS, or Linux.</p>
<p class="programs"><span epub:type="pagebreak" id="page_181"/><span class="ent">➊</span> CREATE TABLE nyc_yellow_taxi_trips_2016_06_01 (<br/>      trip_id bigserial PRIMARY KEY,<br/>      vendor_id varchar(1) NOT NULL,<br/>      tpep_pickup_datetime timestamp with time zone NOT NULL,<br/>      tpep_dropoff_datetime timestamp with time zone NOT NULL,<br/>      passenger_count integer NOT NULL,<br/>      trip_distance numeric(8,2) NOT NULL,<br/>      pickup_longitude numeric(18,15) NOT NULL,<br/>      pickup_latitude numeric(18,15) NOT NULL,<br/>      rate_code_id varchar(2) NOT NULL,<br/>      store_and_fwd_flag varchar(1) NOT NULL,<br/>      dropoff_longitude numeric(18,15) NOT NULL,<br/>      dropoff_latitude numeric(18,15) NOT NULL,<br/>      payment_type varchar(1) NOT NULL,<br/>      fare_amount numeric(9,2) NOT NULL,<br/>      extra numeric(9,2) NOT NULL,<br/>      mta_tax numeric(5,2) NOT NULL,<br/>      tip_amount numeric(9,2) NOT NULL,<br/>      tolls_amount numeric(9,2) NOT NULL,<br/>      improvement_surcharge numeric(9,2) NOT NULL,<br/>      total_amount numeric(9,2) NOT NULL<br/>  );<br/><br/><span class="ent">➋</span> COPY nyc_yellow_taxi_trips_2016_06_01 (<br/>      vendor_id,<br/>      tpep_pickup_datetime,<br/>      tpep_dropoff_datetime,<br/>      passenger_count,<br/>      trip_distance,<br/>      pickup_longitude,<br/>      pickup_latitude,<br/>      rate_code_id,<br/>      store_and_fwd_flag,<br/>      dropoff_longitude,<br/>      dropoff_latitude,<br/>      payment_type,<br/>      fare_amount,<br/>      extra,<br/>      mta_tax,<br/>      tip_amount,<br/>      tolls_amount,<br/>      improvement_surcharge,<br/>      total_amount <br/>   )<br/>  FROM '<em>C:\YourDirectory\</em>yellow_tripdata_2016_06_01.csv'<br/>  WITH (FORMAT CSV, HEADER, DELIMITER ',');<br/><br/><span class="ent">➌</span> CREATE INDEX tpep_pickup_idx<br/>  ON nyc_yellow_taxi_trips_2016_06_01 (tpep_pickup_datetime);</p>
<p class="listing" id="ch11list7"><em>Listing 11-7: Creating a table and importing NYC yellow taxi data</em></p>
<p class="indent">The code in <a href="ch11.xhtml#ch11list7">Listing 11-7</a> builds the table <span class="ent">➊</span>, imports the rows <span class="ent">➋</span>, and creates an index <span class="ent">➌</span>. In the <span class="literal">COPY</span> statement, we provide the names of columns <span epub:type="pagebreak" id="page_182"/>because the input CSV file doesn’t include the <span class="literal">trip_id</span> column that exists in the target table. That column is of type <span class="literal">bigserial</span>, which you’ve learned is an auto-incrementing integer and will fill automatically. After your import is complete, you should have 368,774 rows, one for each yellow cab ride on June 1, 2016. You can check the number of rows in your table with a count using the following code:</p>
<p class="programs">SELECT count(*) FROM nyc_yellow_taxi_trips_2016_06_01;</p>
<p class="indent">Each row includes data on the number of passengers, the location of pickup and drop-off in latitude and longitude, and the fare and tips in U.S. dollars. The data dictionary that describes all columns and codes is available at <em><a href="http://www.nyc.gov/html/tlc/downloads/pdf/data_dictionary_trip_records_yellow.pdf">http://www.nyc.gov/html/tlc/downloads/pdf/data_dictionary_trip_records_yellow.pdf</a></em>. For these exercises, we’re most interested in the timestamp columns <span class="literal">tpep_pickup_datetime</span> and <span class="literal">tpep_dropoff_datetime</span>, which represent the start and end times of the ride. (The Technology Passenger Enhancements Project [TPEP] is a program that in part includes automated collection of data about taxi rides.)</p>
<p class="indent">The values in both timestamp columns include the time zone provided by the Taxi and Limousine Commission. In all rows of the CSV file, the time zone included with the timestamp is shown as <span class="literal">-4</span>, which is the summertime UTC offset for the Eastern time zone when New York City and the rest of the U.S. East Coast observe daylight saving time. If you’re not or your PostgreSQL server isn’t located in Eastern time, I suggest setting your time zone using the following code so your results will match mine:</p>
<p class="programs">SET timezone TO 'US/Eastern';</p>
<p class="indent">Now let’s explore the patterns we can identify in the data related to these times.</p>
<h5 class="h5" id="lev178">The Busiest Time of Day</h5>
<p class="noindent">One question you might ask after viewing this data set is when taxis provide the most rides. Is it morning or evening rush hour, or is there another time—at least, on this day—when rides spiked? You can determine the answer with a simple aggregation query that uses <span class="literal">date_part()</span>.</p>
<p class="indent"><a href="ch11.xhtml#ch11list8">Listing 11-8</a> contains the query to count rides by hour using the pickup time as the input:</p>
<p class="programs">SELECT<br/>  <span class="ent">➊</span> date_part('hour', tpep_pickup_datetime) AS trip_hour,<br/>  <span class="ent">➋</span> count(*)<br/>FROM nyc_yellow_taxi_trips_2016_06_01<br/>GROUP BY trip_hour<br/>ORDER BY trip_hour;</p>
<p class="listing" id="ch11list8"><em>Listing 11-8: Counting taxi trips by hour</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_183"/>In the query’s first column <span class="ent">➊</span>, <span class="literal">date_part()</span> extracts the hour from <span class="literal">tpep_pickup_datetime</span> so we can group the number of rides by hour. Then we aggregate the number of rides in the second column via the <span class="literal">count()</span> function <span class="ent">➋</span>. The rest of the query follows the standard patterns for grouping and ordering the results, which should return 24 rows, one for each hour of the day:</p>
<p class="programs">trip_hour    count<br/>---------    -----<br/>        0     8182<br/>        1     5003<br/>        2     3070<br/>        3     2275<br/>        4     2229<br/>        5     3925<br/>        6    10825<br/>        7    18287<br/>        8    21062<br/>        9    18975<br/>       10    17367<br/>       11    17383<br/>       12    18031<br/>       13    17998<br/>       14    19125<br/>       15    18053<br/>       16    15069<br/>       17    18513<br/>       18    22689<br/>       19    23190<br/>       20    23098<br/>       21    24106<br/>       22    22554<br/>       23    17765</p>
<p class="indent">Eyeballing the numbers, it’s apparent that on June 1, 2016, New York City taxis had the most passengers between 6 <small>PM</small> and 10 <small>PM</small>, possibly reflecting commutes home plus the plethora of city activities on a summer evening. But to see the overall pattern, it’s best to visualize the data. Let’s do this next.</p>
<h5 class="h5" id="lev179">Exporting to CSV for Visualization in Excel</h5>
<p class="noindent">Charting data with a tool such as Microsoft Excel makes it easier to understand patterns, so I often export query results to a CSV file and work up a quick chart. <a href="ch11.xhtml#ch11list9">Listing 11-9</a> uses the query from the preceding example within a <span class="literal">COPY ... TO</span> statement, similar to <a href="ch04.xhtml#ch04list9">Listing 4-9</a> on <a href="ch04.xhtml#page_52">page 52</a>:</p>
<p class="programs">COPY<br/>    (SELECT<br/>        date_part('hour', tpep_pickup_datetime) AS trip_hour,<br/>        count(*)<br/>    FROM nyc_yellow_taxi_trips_2016_06_01<br/><span epub:type="pagebreak" id="page_184"/>    GROUP BY trip_hour<br/>    ORDER BY trip_hour<br/>    )<br/>TO '<em>C:\YourDirectory\</em>hourly_pickups_2016_06_01.csv'<br/>WITH (FORMAT CSV, HEADER, DELIMITER ',');</p>
<p class="listing" id="ch11list9"><em>Listing 11-9: Exporting taxi pickups per hour to a CSV file</em></p>
<p class="indent">When I load the data into Excel and build a line graph, the day’s pattern becomes more obvious and thought-provoking, as shown in <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>.</p>
<div class="image"><a id="ch11fig1"/><img alt="image" src="../images/f0184-01.jpg"/></div>
<p class="figcap"><em>Figure 11-1: NYC yellow taxi pickups by hour</em></p>
<p class="indent">Rides bottomed out in the wee hours of the morning before rising sharply between 5 <small>AM</small> and 8 <small>AM.</small> Volume remained relatively steady throughout the day and increased again for evening rush hour after 5 <small>PM</small>. But there was a dip between 3 <small>PM</small> and 4 <small>PM</small>—why?</p>
<p class="indent">To answer that question, we would need to dig deeper to analyze data that spanned several days or even several months to see whether our data from June 1, 2016, is typical. We could use the <span class="literal">date_part()</span> function to compare trip volume on weekdays versus weekends by extracting the day of the week. To be even more ambitious, we could check weather reports and compare trips on rainy days versus sunny days. There are many different ways to slice a data set to derive conclusions.</p>
<h5 class="h5" id="lev180">When Do Trips Take the Longest?</h5>
<p class="noindent">Let’s investigate another interesting question: at which hour did taxi trips take the longest? One way to find an answer is to calculate the median trip time for each hour. The median is the middle value in an ordered set of values; it’s often more accurate than an average for making comparisons because a few very small or very large values in the set won’t skew the results as they would with the average.</p>
<p class="indent"><span epub:type="pagebreak" id="page_185"/>In <a href="ch05.xhtml#ch05">Chapter 5</a>, we used the <span class="literal">percentile_cont()</span> function to find medians. We use it again in <a href="ch11.xhtml#ch11list10">Listing 11-10</a> to calculate median trip times:</p>
<p class="programs">SELECT<br/>  <span class="ent">➊</span> date_part('hour', tpep_pickup_datetime) AS trip_hour,<br/>  <span class="ent">➋</span> percentile_cont(.5)<br/>      <span class="ent">➌</span> WITHIN GROUP (ORDER BY<br/>            tpep_dropoff_datetime - tpep_pickup_datetime) AS median_trip<br/>FROM nyc_yellow_taxi_trips_2016_06_01<br/>GROUP BY trip_hour<br/>ORDER BY trip_hour;</p>
<p class="listing" id="ch11list10"><em>Listing 11-10: Calculating median trip time by hour</em></p>
<p class="indent">We’re aggregating data by the hour portion of the timestamp column <span class="literal">tpep_pickup_datetime</span> again, which we extract using <span class="literal">date_part()</span> <span class="ent">➊</span>. For the input to the <span class="literal">percentile_cont()</span> function <span class="ent">➋</span>, we subtract the pickup time from the drop-off time in the <span class="literal">WITHIN GROUP</span> clause <span class="ent">➌</span>. The results show that the 1 <small>PM</small> hour has the highest median trip time of 15 minutes:</p>
<p class="programs">date_part    median_trip<br/>---------    -----------<br/>        0    00:10:04<br/>        1    00:09:27<br/>        2    00:08:59<br/>        3    00:09:57<br/>        4    00:10:06<br/>        5    00:07:37<br/>        6    00:07:54<br/>        7    00:10:23<br/>        8    00:12:28<br/>        9    00:13:11<br/>       10    00:13:46<br/>       11    00:14:20<br/>       12    00:14:49<br/>       13    00:15:00<br/>       14    00:14:35<br/>       15    00:14:43<br/>       16    00:14:42<br/>       17    00:14:15<br/>       18    00:13:19<br/>       19    00:12:25<br/>       20    00:11:46<br/>       21    00:11:54<br/>       22    00:11:37<br/>       23    00:11:14</p>
<p class="indent">As we would expect, trip times are shortest in the early morning hours. This result makes sense because less traffic in the early morning means passengers are more likely to get to their destinations faster.</p>
<p class="indent">Now that we’ve explored ways to extract portions of the timestamp for analysis, let’s dig deeper into analysis that involves intervals.</p>
<h4 class="h4" id="lev181"><span epub:type="pagebreak" id="page_186"/><em>Finding Patterns in Amtrak Data</em></h4>
<p class="noindent">Amtrak, the nationwide rail service in America, offers several packaged trips across the United States. The All American, for example, is a train that departs from Chicago and stops in New York, New Orleans, Los Angeles, San Francisco, and Denver before returning to Chicago. Using data from the Amtrak website (<em><a href="http://www.amtrak.com/">http://www.amtrak.com/</a></em>), we’ll build a table that shows information for each segment of the trip. The trip spans four time zones, so we’ll need to track the time zones each time we enter an arrival or departure time. Then we’ll calculate the duration of the journey at each segment and figure out the length of the entire trip.</p>
<h5 class="h5" id="lev182">Calculating the Duration of Train Trips</h5>
<p class="noindent">Let’s create a table that divides The All American train route into six segments. <a href="ch11.xhtml#ch11list11">Listing 11-11</a> contains SQL to create and fill a table with the departure and arrival time for each leg of the journey:</p>
<p class="programs">SET timezone TO 'US/Central';<span class="ent">➊</span><br/><br/>CREATE TABLE train_rides (<br/>    trip_id bigserial PRIMARY KEY,<br/>    segment varchar(50) NOT NULL,<br/>    departure timestamp with time zone NOT NULL,<span class="ent">➋</span><br/>    arrival timestamp with time zone NOT NULL<br/>);<br/><br/>INSERT INTO train_rides (segment, departure, arrival)<span class="ent">➌</span><br/>VALUES<br/>    ('Chicago to New York', '2017-11-13 21:30 CST', '2017-11-14 18:23 EST'),<br/>    ('New York to New Orleans', '2017-11-15 14:15 EST', '2017-11-16 19:32 CST'),<br/>    ('New Orleans to Los Angeles', '2017-11-17 13:45 CST', '2017-11-18 9:00 PST'),<br/>    ('Los Angeles to San Francisco', '2017-11-19 10:10 PST', '2017-11-19 21:24 PST'),<br/>    ('San Francisco to Denver', '2017-11-20 9:10 PST', '2017-11-21 18:38 MST'),<br/>    ('Denver to Chicago', '2017-11-22 19:10 MST', '2017-11-23 14:50 CST');<br/><br/>SELECT * FROM train_rides;</p>
<p class="listing" id="ch11list11"><em>Listing 11-11: Creating a table to hold train trip data</em></p>
<p class="indent">First, we set the session to the Central time zone, the value for Chicago, using the <span class="literal">US/Central</span> designator <span class="ent">➊</span>. We’ll use Central time as our reference when viewing the timestamps of the data we enter so that regardless of your and my machine’s default time zones, we’ll share the same view of the data.</p>
<p class="indent">Next, we use the standard <span class="literal">CREATE TABLE</span> statement. Note that columns for departures and arrival times are set to <span class="literal">timestamp with time zone</span> <span class="ent">➋</span>. Finally, we insert rows that represent the six legs of the trip <span class="ent">➌</span>. Each timestamp input reflects the time zone of the departure and arrival city. Specifying the city’s time zone is the key to getting an accurate calculation of trip duration and accounting for time zone changes. It also accounts for annual changes to and from daylight saving time if they were to occur during the time span you’re examining.</p>
<p class="indent"><span epub:type="pagebreak" id="page_187"/>The final <span class="literal">SELECT</span> statement should return the contents of the table like this:</p>
<div class="image"><img alt="image" src="../images/prog_page_187.jpg"/></div>
<p class="indent">All timestamps should now carry a UTC offset of <span class="literal">-06</span>, which is equivalent to the Central time zone in the United States during the month of November, after the nation had switched to standard time. Regardless of the time zone we supplied on insert, our view of the data is now in Central time, and the times are adjusted accordingly if they’re in another time zone.</p>
<p class="indent">Now that we’ve created segments corresponding to each leg of the trip, we’ll use <a href="ch11.xhtml#ch11list12">Listing 11-12</a> to calculate the duration of each segment:</p>
<p class="programs">SELECT segment,<br/>     <span class="ent">➊</span> to_char(departure, 'YYYY-MM-DD HH12:MI a.m. TZ') AS departure,<br/>     <span class="ent">➋</span> arrival - departure AS segment_time<br/>FROM train_rides;</p>
<p class="listing" id="ch11list12"><em>Listing 11-12: Calculating the length of each trip segment</em></p>
<p class="indent">This query lists the trip segment, the departure time, and the duration of the segment journey. Before we look at the calculation, notice the additional code around the <span class="literal">departure</span> column <span class="ent">➊</span>. These are PostgreSQL-specific formatting functions that specify how to format different components of the timestamp. In this case, the <span class="literal">to_char()</span> function turns the <span class="literal">departure</span> timestamp column into a string of characters formatted as <span class="literal">YYYY-MM-DD HH12:MI a.m. TZ</span>. The <span class="literal">YYYY-MM-DD</span> portion specifies the ISO format for the date, and the <span class="literal">HH12:MI a.m.</span> portion presents the time in hours and minutes. The <span class="literal">HH12</span> portion specifies the use of a 12-hour clock rather than 24-hour military time. The <span class="literal">a.m.</span> portion specifies that we want to show morning or night times using lowercase characters separated by periods, and the <span class="literal">TZ</span> portion denotes the time zone.</p>
<p class="indent">For a complete list of formatting functions, check out the PostgreSQL documentation at <em><a href="https://www.postgresql.org/docs/current/static/functions-formatting.html">https://www.postgresql.org/docs/current/static/functions-formatting.html</a></em>.</p>
<p class="indent">Last, we subtract <span class="literal">departure</span> from <span class="literal">arrival</span> to determine the <span class="literal">segment_time</span> <span class="ent">➋</span>. When you run the query, the output should look like this:</p>
<div class="image"><img alt="image" src="../images/prog_page_187a.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_188"/>Subtracting one timestamp from another produces an <span class="literal">interval</span> data type, which was introduced in <a href="ch03.xhtml#ch03">Chapter 3</a>. As long as the value is less than 24 hours, PostgreSQL presents the interval in the <span class="codeitalic">HH:MM:SS</span> format. For values greater than 24 hours, it returns the format <span class="literal">1 day 08:28:00</span>, as shown in the San Francisco to Denver segment.</p>
<p class="indent">In each calculation, PostgreSQL accounts for the changes in time zones so we don’t inadvertently add or lose hours when subtracting. If we used a <span class="literal">timestamp without time zone</span> data type, we would end up with an incorrect trip length if a segment spanned multiple time zones.</p>
<h5 class="h5" id="lev183">Calculating Cumulative Trip Time</h5>
<p class="noindent">As it turns out, San Francisco to Denver is the longest leg of the All American train trip. But how long does the entire trip take? To answer this question, we’ll revisit window functions, which you learned about in <a href="ch10.xhtml#lev164">“Ranking with <span class="literal">rank()</span> and <span class="literal">dense_rank()</span>”</a> on <a href="ch10.xhtml#page_164">page 164</a>.</p>
<p class="indent">Our prior query produced an interval, which we labeled <span class="literal">segment_time</span>. It would seem like the natural next step would be to write a query to add those values, creating a cumulative interval after each segment. And indeed, we can use <span class="literal">sum()</span> as a window function, combined with the <span class="literal">OVER</span> clause mentioned in <a href="ch10.xhtml#ch10">Chapter 10</a>, to create running totals. But when we do, the resulting values are odd. To see what I mean, run the code in <a href="ch11.xhtml#ch11list13">Listing 11-13</a>:</p>
<p class="programs">SELECT segment,<br/>       arrival - departure AS segment_time,<br/>       sum(arrival - departure) OVER (ORDER BY trip_id) AS cume_time<br/>FROM train_rides;</p>
<p class="listing" id="ch11list13"><em>Listing 11-13: Calculating cumulative intervals using <span class="literal">OVER</span></em></p>
<p class="indent">In the third column, we sum the intervals generated when we subtract <span class="literal">departure</span> from <span class="literal">arrival</span>. The resulting running total in the <span class="literal">cume_time</span> column is accurate but formatted in an unhelpful way:</p>
<p class="programs">segment                         segment_time      cume_time<br/>----------------------------    --------------    ---------------<br/>Chicago to New York             19:53:00          19:53:00<br/>New York to New Orleans         1 day 06:17:00    1 day 26:10:00<br/>New Orleans to Los Angeles      21:15:00          1 day 47:25:00<br/>Los Angeles to San Francisco    11:14:00          1 day 58:39:00<br/>San Francisco to Denver         1 day 08:28:00    2 days 67:07:00<br/>Denver to Chicago               18:40:00          2 days 85:47:00</p>
<p class="indent">PostgreSQL creates one sum for the day portion of the interval and another for the hours and minutes. So, instead of a more understandable <span epub:type="pagebreak" id="page_189"/>cumulative time of <span class="literal">5 days 13:47:00</span>, the database reports <span class="literal">2 days 85:47:00</span>. Both results amount to the same length of time, but <span class="literal">2 days 85:47:00</span> is harder to decipher. This is an unfortunate limitation of summing the database intervals using this syntax.</p>
<p class="indent">As a workaround, we’ll use the code in <a href="ch11.xhtml#ch11list14">Listing 11-14</a>:</p>
<p class="programs">SELECT segment,<br/>       arrival - departure AS segment_time,<br/>       sum(date_part<span class="ent">➊</span>('epoch', (arrival - departure)))<br/>           OVER (ORDER BY trip_id) * interval '1 second'<span class="ent">➋</span> AS cume_time<br/>FROM train_rides;</p>
<p class="listing" id="ch11list14"><em>Listing 11-14: Better formatting for cumulative trip time</em></p>
<p class="indent">Recall from earlier in this chapter that <span class="literal">epoch</span> is the number of seconds that have elapsed since midnight on January 1, 1970, which makes it useful for calculating duration. In <a href="ch11.xhtml#ch11list14">Listing 11-14</a>, we use <span class="literal">date_part()</span> <span class="ent">➊</span> with the <span class="literal">epoch</span> setting to extract the number of seconds elapsed between the arrival and departure intervals. Then we multiply each sum with an interval of <span class="literal">1 second</span> <span class="ent">➋</span> to convert those seconds to an <span class="literal">interval</span> value. The output is clearer using this method:</p>
<p class="programs">segment                         segment_time      cume_time<br/>----------------------------    --------------    ---------<br/>Chicago to New York             19:53:00          19:53:00<br/>New York to New Orleans         1 day 06:17:00    50:10:00<br/>New Orleans to Los Angeles      21:15:00          71:25:00<br/>Los Angeles to San Francisco    11:14:00          82:39:00<br/>San Francisco to Denver         1 day 08:28:00    115:07:00<br/>Denver to Chicago               18:40:00          133:47:00</p>
<p class="indent">The final <span class="literal">cume_time</span>, now in <span class="codeitalic">HH:MM:SS</span> format, adds all the segments to return the total trip length of 133 hours and 47 minutes. That’s a long time to spend on a train, but I’m sure the scenery is well worth the ride.</p>
<h3 class="h3" id="lev184">Wrapping Up</h3>
<p class="noindent">Handling times and dates in SQL databases adds an intriguing dimension to your analysis, letting you answer questions about when an event occurred along with other temporal concerns in your data. With a solid grasp of time and date formats, time zones, and functions to dissect the components of a timestamp, you can analyze just about any data set you come across.</p>
<p class="indent">Next, we’ll look at advanced query techniques that help answer more complex questions.</p>
<div class="sidebar" id="ch11sb1">
<p class="sidebart"><span epub:type="pagebreak" id="page_190"/><strong>TRY IT YOURSELF</strong></p>
<p class="spara">Try these exercises to test your skills on dates and times.</p>
<ol>
<li class="noindent"><p class="list">Using the New York City taxi data, calculate the length of each ride using the pickup and drop-off timestamps. Sort the query results from the longest ride to the shortest. Do you notice anything about the longest or shortest trips that you might want to ask city officials about?</p></li>
<li class="noindent"><p class="list">Using the <span class="literal">AT TIME ZONE</span> keywords, write a query that displays the date and time for London, Johannesburg, Moscow, and Melbourne the moment January 1, 2100, arrives in New York City.</p></li>
<li class="noindent"><p class="list">As a bonus challenge, use the statistics functions in <a href="ch10.xhtml#ch10">Chapter 10</a> to calculate the correlation coefficient and <em>r</em>-squared values using trip time and the <span class="literal">total_amount</span> column in the New York City taxi data, which represents the total amount charged to passengers. Do the same with the <span class="literal">trip_distance</span> and <span class="literal">total_amount</span> columns. Limit the query to rides that last three hours or less.</p></li>
</ol>
</div>
</body>
</html>